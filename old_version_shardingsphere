commit b17822c3973f59394f7a70d7bd4a4afcf33c2147
Author: Ling Hengqian <linghengqian@outlook.com>
Date:   Wed Jul 17 17:51:07 2024 +0800

    Fixes the incorrect description of Seata TCC Mode in the doc (#32144)

diff --git a/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.cn.md b/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.cn.md
index 62ff6a93a97..a2458d8760b 100644
--- a/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.cn.md
+++ b/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.cn.md
@@ -6,7 +6,6 @@ weight = 7
 ## 背景信息
 
 Apache ShardingSphere 提供 BASE 事务，集成了 Seata 的实现。本文所指 Seata 集成均指向 Seata AT 模式。
-对于 Seata TCC 模式的集成，被 https://github.com/apache/shardingsphere/discussions/32023 阻塞。
 
 ## 前提条件
 
@@ -115,7 +114,7 @@ client {
 ```
 
 一个最小配置的 `seata.conf` 如下。
-请注意，由 ShardingSphere 管理的 `seata.conf` 中， `client.transaction.service.group` 的默认值设置为 `default` 是出于历史原因。
+由 ShardingSphere 管理的 `seata.conf` 中， `client.transaction.service.group` 的默认值设置为 `default` 是出于历史原因。
 假设用户使用的 Seata Server 和 Seata Client 的 `registry.conf` 中，`registry.type` 和 `config.type` 均为 `file`，
 则对于 `registry.conf` 的 `config.file.name` 配置的 `.conf` 文件中，事务分组名在 `apache/incubator-seata:v1.5.1` 之后默认值为 `default_tx_group`，
 反之则为 `my_test_tx_group`。
@@ -132,8 +131,8 @@ ShardingSphere 的 Seata 集成不支持隔离级别。
 
 ShardingSphere 的 Seata 集成将获取到的 Seata 全局事务置入线程的局部变量。
 而 `org.apache.seata.spring.annotation.GlobalTransactionScanner` 则是采用 Dynamic Proxy 的方式对方法进行增强。
-这意味着用户始终不应该针对 ShardingSphere 的 DataSource 使用 `io.seata:seata-all` 的 Java 注解。
-即在使用 ShardingSphere 的 Seata 集成时，用户应避免使用 `io.seata:seata-all` 的 Java API。
+这意味着用户在使用 ShardingSphere 的 Seata 集成时，用户应避免使用 `io.seata:seata-all` 的 Java API，
+除非用户正在混合使用 ShardingSphere 的 Seata 集成与 Seata Client 的 TCC 模式特性。
 
 针对 ShardingSphere 数据源，讨论 6 种情况，
 
@@ -192,6 +191,17 @@ seata:
   enable-auto-data-source-proxy: false
 ```
 
+### 与 Seata TCC 模式特性混合使用
+
+对于设置开启 ShardingSphere 的 Seata 集成的情况下，
+在与 ShardingSphere JDBC DataSource 无关的业务函数中，如需在业务函数使用 Seata Client 的 Seata TCC 模式相关的特性，
+可实例化一个未代理的普通 TCC 接口实现类， 然后使用 `io.seata.integration.tx.api.util.ProxyUtil` 创建一个代理的TCC接口类，
+并调用 TCC 接口实现类 `Try`，`Confirm`，`Cancel` 三个阶段对应的函数。
+
+对于由 Seata TCC 模式而引入的 `io.seata.spring.annotation.GlobalTransactional` 注解或 Seata TCC 模式涉及的业务函数中需要与数据库实例交互，
+此注解标记的业务函数内不应使用 ShardingSphere JDBC DataSource，
+而是应该手动创建`javax.sql.DataSource` 实例，或从自定义的 Spring Bean 中获取 `javax.sql.DataSource` 实例。
+
 ### 跨服务调用的事务传播
 
 跨服务调用场景下的事务传播，并不像单个微服务内的事务操作一样开箱即用。
@@ -214,7 +224,7 @@ seata:
 此 ShardingSphere JDBC DataSource 配置使用连接到 Seata Server 实例 `a-seata-server` 的 Seata AT 集成，其 Seata Application Id 为 `service-a`，
 其 Seata 事务分组为 `default_tx_group`，其 `Virtual Group Mapping` 指向的 Seata Transaction Coordinator 集群分组为 `default`。
 此微服务实例 `a-service` 暴露单个 Restful API 的 GET 端点为 `/hello`，此 Restful API 端点的业务函数 `aMethod` 使用了普通的本地事务注解。
-若此微服务基于 Spring Boot，
+若此微服务基于 Spring Boot 2，
 
 ```java
 import org.springframework.transaction.annotation.Transactional;
@@ -236,7 +246,7 @@ public class DemoController {
 此 ShardingSphere JDBC DataSource 配置使用连接到 Seata Server 实例 `a-seata-server` 的 Seata AT 集成，其 Seata Application Id 为 `service-b`，
 其 Seata 事务分组为 `default_tx_group`，其 `Virtual Group Mapping` 指向的 Seata Transaction Coordinator 集群分组为 `default`。
 此微服务实例 `b-service` 的业务函数 `bMethod` 使用普通的本地事务注解，并在 `bMethod` 通过 HTTP Client 调用微服务实例 `a-service` 的 `/hello` Restful API 端点。
-若此微服务基于 Spring Boot，
+若此微服务基于 Spring Boot 2，
 
 ```java
 import org.springframework.boot.web.client.RestTemplateBuilder;
diff --git a/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.en.md b/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.en.md
index 3b28addf258..24065995243 100644
--- a/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.en.md
+++ b/docs/document/content/user-manual/shardingsphere-jdbc/special-api/transaction/seata.en.md
@@ -7,7 +7,6 @@ weight = 7
 
 Apache ShardingSphere provides BASE transactions that integrate the Seata implementation.
 All references to Seata integration in this article refer to Seata AT mode.
-Integration of Seata TCC mode is blocked by https://github.com/apache/shardingsphere/discussions/32023 .
 
 ## Prerequisites
 
@@ -120,7 +119,7 @@ client {
 ```
 
 A minimally configured `seata.conf` is as follows.
-Please note that in `seata.conf` managed by ShardingSphere, the default value of `client.transaction.service.group` is set to `default` for historical reasons.
+In `seata.conf` managed by ShardingSphere, the default value of `client.transaction.service.group` is set to `default` for historical reasons.
 Assuming that in the `registry.conf` of Seata Server and Seata Client used by the user, `registry.type` and `config.type` are both `file`,
 then for the `.conf` file configured by `config.file.name` of `registry.conf`, 
 the default value of the transaction group name is `default_tx_group` after `apache/incubator-seata:v1.5.1`, otherwise it is `my_test_tx_group`.
@@ -137,8 +136,8 @@ ShardingSphere's Seata integration does not support isolation levels.
 
 ShardingSphere's Seata integration places the obtained Seata global transaction into the thread's local variables.
 And `org.apache.seata.spring.annotation.GlobalTransactionScanner` uses Dynamic Proxy to enhance the method.
-This means that users should never use the `io.seata:seata-all` Java annotation for ShardingSphere's DataSource.
-That is, when using ShardingSphere's Seata integration, users should avoid using the Java API of `io.seata:seata-all`.
+This means that when using ShardingSphere's Seata integration, users should avoid using the Java API of `io.seata:seata-all`, 
+unless the user is mixing ShardingSphere's Seata integration with the TCC mode feature of Seata Client.
 
 For ShardingSphere data source, discuss 6 situations,
 
@@ -199,6 +198,17 @@ seata:
    enable-auto-data-source-proxy: false
 ```
 
+### Mixed use with Seata TCC mode features
+
+For the case of setting up ShardingSphere's Seata integration,
+In business functions unrelated to ShardingSphere JDBC DataSource, if you need to use Seata Client's Seata TCC mode-related features in business functions,
+you can instantiate a non-proxy ordinary TCC interface implementation class, and then use `io.seata.integration.tx.api.util.ProxyUtil` to create a proxy TCC interface class,
+and call the functions corresponding to the three stages of the TCC interface implementation class `Try`, `Confirm`, and `Cancel`.
+
+For the `io.seata.spring.annotation.GlobalTransactional` annotation introduced by the Seata TCC mode or the business functions involved in the Seata TCC mode that need to interact with the database instance, 
+ShardingSphere JDBC DataSource should not be used in the business functions marked by this annotation. Instead, 
+a `javax.sql.DataSource` instance should be created manually or obtained from a custom Spring Bean.
+
 ### Transactional propagation across service calls
 
 Transactional propagationn in cross-service call scenarios is not as out-of-the-box as transaction operations within a single microservice.
@@ -224,7 +234,7 @@ whose Seata Application Id is `service-a`, whose Seata transaction group is `def
 and the Seata Transaction Coordinator cluster group pointed to by its `Virtual Group Mapping` is `default`.
 This microservice instance `a-service` exposes a single Restful API GET endpoint as `/hello`,
 and the business function `aMethod` of this Restful API endpoint uses a common local transaction annotation.
-If this microservice is based on Spring Boot,
+If this microservice is based on Spring Boot 2,
 
 ```java
 import org.springframework.transaction.annotation.Transactional;
@@ -248,7 +258,7 @@ whose Seata Application Id is `service-b`, whose Seata transaction group is `def
 and whose `Virtual Group Mapping` points to the Seata Transaction Coordinator cluster group as `default`.
 The business function `bMethod` of this microservice instance `b-service` uses a normal local transaction annotation, 
 and calls the `/hello` Restful API endpoint of the microservice instance `a-service` through the HTTP Client in `bMethod`.
-If this microservice is based on Spring Boot,
+If this microservice is based on Spring Boot 2,
 
 ```java
 import org.springframework.boot.web.client.RestTemplateBuilder;
