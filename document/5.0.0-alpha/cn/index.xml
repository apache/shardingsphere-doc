<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShardingSphere</title>
    <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/</link>
    <description>Recent content on ShardingSphere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/document/5.0.0-alpha/cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Proxy 启动</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/startup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/startup/</guid>
      <description>启动步骤  下载 ShardingSphere-Proxy 的最新发行版。 如果使用 docker，可以执行 docker pull shardingsphere/shardingsphere-proxy 获取镜像。详细信息请参考Docker镜像。 解压缩后修改 conf/server.yaml和以 config- 前缀开头的文件，如：conf/config-xxx.yaml 文件，进行分片规则、读写分离规则配置。配置方式请参考配置手册。 Linux 操作系统请运行 bin/start.sh，Windows 操作系统请运行 bin/start.bat 启动 ShardingSphere-Proxy。如需配置启动端口、配置文件位置，可参考快速入门。  使用 PostgreSQL  使用任何 PostgreSQL 的客户端连接。如: psql -U root -h 127.0.0.1 -p 3307  使用 MySQL  将 MySQL 的 JDBC 驱动程序复制至目录 ext-lib/。 使用任何 MySQL 的客户端连接。如: mysql -u root -h 127.0.0.1 -P 3307  使用自定义分片算法 当用户需要使用自定义的分片算法类时，无法再通过简单的行表达式在 YAML 文件进行配置。可通过以下方式配置使用自定义分片算法。
 实现 ShardingAlgorithm 接口定义的算法实现类。 将上述 Java 文件打包成 jar 包。 将上述 jar 包拷贝至 ShardingSphere-Proxy 解压后的 conf/lib-ext 目录。 将上述自定义算法实现类的 Java 文件引用配置在 YAML 文件中，具体可参考配置规则。  注意事项  ShardingSphere-Proxy 默认使用 3307 端口，可以通过启动脚本追加参数作为启动端口号。如: bin/start.</description>
    </item>
    
    <item>
      <title>ShardingSphere-JDBC</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-jdbc-quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-jdbc-quick-start/</guid>
      <description>1. 引入 maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${latest.release.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 注意：请将 ${latest.release.version} 更改为实际的版本号。
2. 规则配置 ShardingSphere-JDBC 可以通过 Java，YAML，Spring 命名空间和 Spring Boot Starter 这 4 种方式进行配置，开发者可根据场景选择适合的配置方式。 详情请参见配置手册。
3. 创建数据源 通过 ShardingSphereDataSourceFactory 工厂和规则配置对象获取 ShardingSphereDataSource。 该对象实现自 JDBC 的标准 DataSource 接口，可用于原生 JDBC 开发，或使用 JPA, MyBatis 等 ORM 类库。
DataSource dataSource = ShardingSphereDataSourceFactory.createDataSource(dataSourceMap, configurations, properties); </description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/sql/</guid>
      <description>逻辑表 水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为 10 张表，分别是 t_order_0 到 t_order_9，他们的逻辑表名为 t_order。
真实表 在分片的数据库中真实存在的物理表。即上个示例中的 t_order_0 到 t_order_9。
数据节点 数据分片的最小单元。由数据源名称和数据表组成，例：ds_0.t_order_0。
绑定表 指分片规则一致的主表和子表。例如：t_order 表和 t_order_item 表，均按照 order_id 分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果 SQL 为：
SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11); 在不配置绑定表关系时，假设分片键 order_id 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：
SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11); SELECT i.</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/sql/</guid>
      <description>由于SQL语法灵活复杂，分布式数据库和单机数据库的查询场景又不完全相同，难免有和单机数据库不兼容的SQL出现。
本文详细罗列出已明确可支持的SQL种类以及已明确不支持的SQL种类，尽量让使用者避免踩坑。
其中必然有未涉及到的SQL欢迎补充，未支持的SQL也尽量会在未来的版本中支持。
支持项 路由至单数据节点  100%全兼容（目前仅MySQL，其他数据库完善中）。  路由至多数据节点 全面支持DML、DDL、DCL、TCL和部分DAL。支持分页、去重、排序、分组、聚合、关联查询（不支持跨库关联）。以下用最为复杂的DML举例：
 SELECT主语句  SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...] [WHERE predicates] [GROUP BY {col_name | position} [ASC | DESC], ...] [ORDER BY {col_name | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}]  select_expr  * | [DISTINCT] COLUMN_NAME [AS] [alias] | (MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | COUNT(* | COLUMN_NAME | alias) [AS] [alias]  table_reference  tbl_name [AS] alias] [index_hint_list] | table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)] 不支持项 路由至多数据节点 不支持CASE WHEN、HAVING、UNION (ALL)，有限支持子查询。</description>
    </item>
    
    <item>
      <title>SQL 解析</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/sql-parser/</guid>
      <description>SQLParserFacade    SPI 名称 详细说明     SQLParserFacade 配置用于SQL解析的词法分析器和语法分析器入口       Implementation Class Description     MySQLParserFacade 基于 MySQL 的 SQL 解析器入口   PostgreSQLParserFacade 基于 PostgreSQL 的SQL 解析器入口   SQLServerParserFacade 基于 SQLServer 的SQL 解析器入口   OracleParserFacade 基于 Oracle 的SQL 解析器入口   SQL92ParserFacade 基于 SQL92 的SQL 解析器入口    SQLVisitorFacade    SPI 名称 详细说明     SQLVisitorFacade SQL 语法树访问器入口       Implementation Class Description     MySQLStatementSQLVisitorFacade 基于 MySQL 的提取 SQL 语句的语法树访问器   PostgreSQLStatementSQLVisitorFacade 基于 PostgreSQL 的提取 SQL 语句的语法树访问器   SQLServerStatementSQLVisitorFacade 基于 SQLServer 的提取 SQL 语句的语法树访问器   OracleStatementSQLVisitorFacade 基于 Oracle 的提取 SQL 语句的语法树访问器   SQL92StatementSQLVisitorFacade 基于 SQL92 的SQL 解析器入口    ParsingHook    SPI 名称 详细说明     ParsingHook 用于SQL 解析过程追踪       已知实现类 详细说明     OpenTracingParsingHook 使用 OpenTracing 协议追踪 SQL 解析过程    </description>
    </item>
    
    <item>
      <title>SQL测试用例</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/sql-case/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/sql-case/</guid>
      <description>目标 SQL测试用例的代码位于 sharding-sql-test 模块下。该测试用例的作用主要有两个：
 通过单元测试，测试通配符的替换以及 SQLCasesLoader 的稳定性。 将SQL测试用例中 resources 下定义的所有 SQL 共享给其他项目。  待测试的 SQL 存放在 /sharding-sql-test/src/main/resources/sql/sharding/SQL-TYPE/*.xml文件中。例如：
&amp;lt;sql-cases&amp;gt; &amp;lt;sql-case id=&amp;#34;select_constant_without_table&amp;#34; value=&amp;#34;SELECT 1 as a&amp;#34; /&amp;gt; &amp;lt;sql-case id=&amp;#34;select_with_same_table_name_and_alias&amp;#34; value=&amp;#34;SELECT t_order.* FROM t_order t_order WHERE user_id = ? AND order_id = ?&amp;#34; /&amp;gt; &amp;lt;sql-case id=&amp;#34;select_with_same_table_name_and_alias_column_with_owner&amp;#34; value=&amp;#34;SELECT t_order.order_id,t_order.user_id,status FROM t_order t_order WHERE t_order.user_id = ? AND order_id = ?&amp;#34; db-types=&amp;#34;MySQL,H2&amp;#34;/&amp;gt; &amp;lt;/sql-cases&amp;gt; 开发者通过该文件指定待断言的 SQL 以及该 SQL 所适配的数据库类型。将 sharding-sql-test 提取为单独的模块，以保证每个 SQL 用例可以在不同模块的测试引擎中共享。
流程 如下图为 SQL 测试用例的数据流程：</description>
    </item>
    
    <item>
      <title>XA两阶段事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/concept/2pc-xa-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/concept/2pc-xa-transaction/</guid>
      <description>两阶段事务提交采用的是 X/OPEN 组织所定义的DTP模型所抽象的 AP（应用程序）, TM（事务管理器）和 RM（资源管理器） 概念来保证分布式事务的强一致性。 其中 TM 与 RM 间采用 XA 的协议进行双向通信。 与传统的本地事务相比，XA 事务增加了准备阶段，数据库除了被动接受提交指令外，还可以反向通知调用方事务是否可以被提交。 TM 可以收集所有分支事务的准备结果，并于最后进行原子提交，以保证事务的强一致性。
Java 通过定义 JTA 接口实现了 XA 模型，JTA 接口中的 ResourceManager 需要数据库厂商提供 XA 驱动实现， TransactionManager 则需要事务管理器的厂商实现，传统的事务管理器需要同应用服务器绑定，因此使用的成本很高。 而嵌入式的事务管器可以以 jar 包的形式提供服务，同 Apache ShardingSphere 集成后，可保证分片后跨库事务强一致性。
通常，只有使用了事务管理器厂商所提供的 XA 事务连接池，才能支持 XA 的事务。Apache ShardingSphere 在整合 XA 事务时，采用分离 XA 事务管理和连接池管理的方式，做到对应用程序的零侵入。</description>
    </item>
    
    <item>
      <title>使用 Java API</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/java-api/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-governance&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 ZooKeeper 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-zookeeper-curator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 Etcd 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 以下示例将 ZooKeeper 作为配置中心和注册中心。
// 省略配置数据源以及规则 // ...  // 配置配置/注册中心 GovernanceCenterConfiguration configuration = new GovernanceCenterConfiguration(&amp;#34;Zookeeper&amp;#34;, &amp;#34;localhost:2181&amp;#34;, new Properties()); // 配置治理 Map&amp;lt;String, CenterConfiguration&amp;gt; configurationMap = new HashMap&amp;lt;String, CenterConfiguration&amp;gt;(); configurationMap.put(&amp;#34;governance-shardingsphere-data-source&amp;#34;, configuration); // 创建 GovernanceShardingSphereDataSource DataSource dataSource = GovernanceShardingSphereDataSourceFactory.createDataSource( createDataSourceMap(), createShardingRuleConfig(), new Properties(), new GovernanceConfiguration(&amp;#34;shardingsphere-governance&amp;#34;, configurationMap, true)); 使用 GovernanceShardingSphereDataSource 通过 GovernanceShardingSphereDataSourceFactory 工厂创建的 GovernanceShardingSphereDataSource 实现自 JDBC 的标准接口 DataSource。 可通过 DataSource 选择使用原生 JDBC，或JPA， MyBatis 等 ORM 框架。</description>
    </item>
    
    <item>
      <title>使用 Java API</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/java-api/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 ShardingSphere-JDBC 的 Java API 通过数据源集合、规则集合以及属性配置组成。 以下示例是根据 user_id 取模分库, 且根据 order_id 取模分表的 2 库 2 表的配置。
// 配置真实数据源 Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(); // 配置第 1 个数据源 BasicDataSource dataSource1 = new BasicDataSource(); dataSource1.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource1.setUrl(&amp;#34;jdbc:mysql://localhost:3306/ds0&amp;#34;); dataSource1.setUsername(&amp;#34;root&amp;#34;); dataSource1.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds0&amp;#34;, dataSource1); // 配置第 2 个数据源 BasicDataSource dataSource2 = new BasicDataSource(); dataSource2.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource2.setUrl(&amp;#34;jdbc:mysql://localhost:3306/ds1&amp;#34;); dataSource2.setUsername(&amp;#34;root&amp;#34;); dataSource2.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds1&amp;#34;, dataSource2); // 配置 t_order 表规则 ShardingTableRuleConfiguration orderTableRuleConfig = new ShardingTableRuleConfiguration(&amp;#34;t_order&amp;#34;, &amp;#34;ds${0.</description>
    </item>
    
    <item>
      <title>使用 Java API</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/java-api/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 使用分布式事务 TransactionTypeHolder.set(TransactionType.XA); // 支持 TransactionType.LOCAL, TransactionType.XA, TransactionType.BASE try (Connection conn = dataSource.getConnection()) { // 使用 ShardingSphereDataSource  conn.setAutoCommit(false); PreparedStatement ps = conn.prepareStatement(&amp;#34;INSERT INTO t_order (user_id, status) VALUES (?, ?)&amp;#34;); ps.setObject(1, 1000); ps.setObject(2, &amp;#34;init&amp;#34;); ps.executeUpdate(); conn.commit(); } </description>
    </item>
    
    <item>
      <title>分片算法</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding/</guid>
      <description>自动分片算法 取模分片算法 类型：MOD
可配置属性：
   属性名称 数据类型 说明     sharding-count int 分片数量    哈希取模分片算法 类型：HASH_MOD
可配置属性：
   属性名称 数据类型 说明     sharding-count int 分片数量    基于分片容量的范围分片算法 类型：VOLUME_RANGE
可配置属性：
   属性名称 数据类型 说明     range-lower long 范围下界，超过边界的数据会报错   range-upper long 范围上界，超过边界的数据会报错   sharding-volume long 分片容量    基于分片边界的范围分片算法 类型：BOUNDARY_RANGE</description>
    </item>
    
    <item>
      <title>应用性能监控集成</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/observability/apm-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/observability/apm-integration/</guid>
      <description>背景 APM 是应用性能监控的缩写。目前 APM 的主要功能着眼于分布式系统的性能诊断，其主要功能包括调用链展示，应用拓扑分析等。
Apache ShardingSphere 并不负责如何采集、存储以及展示应用性能监控的相关数据，而是将 SQL 解析与 SQL 执行这两块数据分片的最核心的相关信息发送至应用性能监控系统，并交由其处理。 换句话说，Apache ShardingSphere 仅负责产生具有价值的数据，并通过标准协议递交至相关系统。Apache ShardingSphere 可以通过两种方式对接应用性能监控系统。
第一种方式是使用 OpenTracing API 发送性能追踪数据。面向 OpenTracing 协议的 APM 产品都可以与 Apache ShardingSphere 自动对接，比如 SkyWalking，Zipkin 和 Jaeger。 使用这种方式只需要在启动时配置 OpenTracing 协议的实现者即可。 它的优点是可以兼容所有的与 OpenTracing 协议兼容的产品作为 APM 的展现系统，如果采用公司愿意实现自己的 APM 系统，也只需要实现 OpenTracing 协议，即可自动展示 Apache ShardingSphere 的链路追踪信息。 缺点是 OpenTracing 协议发展并不稳定，较新的版本实现者较少，且协议本身过于中立，对于个性化的相关产品的实现不如原生支持强大。
第二种方式是使用 SkyWalking 的自动探针。 Apache ShardingSphere 团队与Apache SkyWalking 团队共同合作，在 SkyWalking 中实现了 Apache ShardingSphere 自动探针，可以将相关的应用性能数据自动发送到 SkyWalking 中。
使用方法 使用 OpenTracing 协议  方法1：通过读取系统参数注入APM系统提供的 Tracer 实现类  启动时添加参数</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/sharding/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.sharding.api.config.ShardingRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     tables (+) Collection&amp;lt;ShardingTableRuleConfiguration&amp;gt; 分片表规则列表 -   autoTables (+) Collection&amp;lt;ShardingAutoTableRuleConfiguration&amp;gt; 自动化分片表规则列表 -   bindingTableGroups (*) Collection&amp;lt;String&amp;gt; 绑定表规则列表 无   broadcastTables (*) Collection&amp;lt;String&amp;gt; 广播表规则列表 无   defaultDatabaseShardingStrategy (?) ShardingStrategyConfiguration 默认分库策略 不分片   defaultTableShardingStrategy (?) ShardingStrategyConfiguration 默认分表策略 不分片   defaultKeyGenerateStrategy (?) KeyGeneratorConfiguration 默认自增列生成器配置 雪花算法   shardingAlgorithms (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 分片算法名称和配置 无   keyGenerators (?</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/sharding/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置# 标准分片表配置spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.actual-data-nodes= # 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况# 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一# 用于单分片键的标准分片场景spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-column= # 分片列名称spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称# 用于多分片键的复合分片场景spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-columns= # 分片列名称，多个列以逗号分隔spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称# 用于Hint 的分片策略spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.hint.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称# 分表策略，同分库策略spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.table-strategy.xxx= # 省略# 自动分片表配置spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.actual-data-sources= # 数据源名spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-column= # 分片列名称spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-algorithm= # 自动分片算法名称# 分布式序列策略配置spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.column= # 分布式序列列名称spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.key-generator-name= # 分布式序列算法名称spring.shardingsphere.rules.sharding.binding-tables[0]= # 绑定表规则列表spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表规则列表spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表规则列表spring.shardingsphere.rules.sharding.broadcast-tables[0]= # 广播表规则列表spring.</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/sharding/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding-5.0.0.xsd
&amp;lt;sharding:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   table-rules (?) 标签 分片表规则配置   auto-table-rules (?) 标签 自动化分片表规则配置   binding-table-rules (?) 标签 绑定表规则配置   broadcast-table-rules (?) 标签 广播表规则配置   default-database-strategy-ref (?) 属性 默认分库策略名称   default-table-strategy-ref (?) 属性 默认分表策略名称   default-key-generate-strategy-ref (?) 属性 默认分布式序列策略名称    &amp;lt;sharding:table-rule /&amp;gt;
   名称 类型 说明     logic-table 属性 逻辑表名称   actual-data-nodes 属性 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况   actual-data-sources 属性 自动分片表数据源名   database-strategy-ref 属性 标准分片表分库策略名称   table-strategy-ref 属性 标准分片表分表策略名称   sharding-strategy-ref 属性 自动分片表策略名称   key-generate-strategy-ref 属性 分布式序列策略名称    &amp;lt;sharding:binding-table-rules /&amp;gt;</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/sharding/</guid>
      <description>配置项说明 dataSources: # 省略数据源配置 rules: - !SHARDING tables: # 数据分片规则配置 &amp;lt;logic-table-name&amp;gt; (+): # 逻辑表名称 actualDataNodes (?): #由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持行表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况 databaseStrategy (?): # 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一 standard: # 用于单分片键的标准分片场景 shardingColumn: # 分片列名称 shardingAlgorithmName: # 分片算法名称 complex: # 用于多分片键的复合分片场景 shardingColumns: #分片列名称，多个列以逗号分隔 shardingAlgorithmName: # 分片算法名称 hint: # Hint 分片策略 shardingAlgorithmName: # 分片算法名称 none: # 不分片 tableStrategy: # 分表策略，同分库策略 keyGenerateStrategy: # 分布式序列策略 column: # 自增列名称，缺省表示不使用自增主键生成器 keyGeneratorName: # 分布式序列算法名称 autoTables: # 自动分片表规则配置 t_order_auto: # 逻辑表名称 actualDataSources (?): # 数据源名称 shardingStrategy: # 切分策略 standard: # 用于单分片键的标准分片场景 shardingColumn: # 分片列名称 shardingAlgorithmName: # 自动分片算法名称 bindingTables (+): # 绑定表规则列表 - &amp;lt;logic_table_name_1, logic_table_name_2, .</description>
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/data-source/</guid>
      <description>配置项说明 schemaName: # 逻辑数据源名称 dataSourceCommon: username: # 数据库用户名 password: # 数据库密码 connectionTimeoutMilliseconds: # 连接超时毫秒数 idleTimeoutMilliseconds: # 空闲连接回收超时毫秒数 maxLifetimeMilliseconds: # 连接最大存活时间毫秒数 maxPoolSize: 50 # 最大连接数 minPoolSize: 1 # 最小连接数 dataSources: # 数据源配置，可配置多个 &amp;lt;data-source-name&amp;gt; &amp;lt;data-source-name&amp;gt;: # 与 ShardingSphere-JDBC 配置不同，无需配置数据库连接池 url: #数据库 URL 连接 rules: # 与 ShardingSphere-JDBC 配置一致 # ... 覆盖dataSourceCommon说明 上面配置了每个库的公共数据源配置，如果你想覆盖 dataSourceCommon 属性，请在每个数据源单独配置。
dataSources: # 数据源配置，可配置多个 &amp;lt;data-source-name&amp;gt; &amp;lt;data-source-name&amp;gt;: # 与 ShardingSphere-JDBC 配置不同，无需配置数据库连接池 url: #数据库 URL 连接 username: # 数据库用户名，覆盖 dataSourceCommon 配置 password: # 数据库密码，覆盖 dataSourceCommon 配置 connectionTimeoutMilliseconds: # 连接超时毫秒数，覆盖 dataSourceCommon 配置 idleTimeoutMilliseconds: # 空闲连接回收超时毫秒数，覆盖 dataSourceCommon 配置 maxLifetimeMilliseconds: # 连接最大存活时间毫秒数，覆盖 dataSourceCommon 配置 maxPoolSize: # 最大连接数，覆盖 dataSourceCommon 配置 </description>
    </item>
    
    <item>
      <title>本地事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/local-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/local-transaction/</guid>
      <description>支持项  完全支持非跨库事务，例如：仅分表，或分库但是路由的结果在单库中； 完全支持因逻辑异常导致的跨库事务。例如：同一事务中，跨两个库更新。更新完毕后，抛出空指针，则两个库的内容都能回滚。  不支持项  不支持因网络、硬件异常导致的跨库事务。例如：同一事务中，跨两个库更新，更新完毕后、未提交之前，第一个库宕机，则只有第二个库数据提交。  </description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/concept/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/replica-query/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/replica-query/concept/</guid>
      <description>主库 添加、更新以及删除数据操作所使用的数据库，目前仅支持单主库。
从库 查询数据操作所使用的数据库，可支持多从库。
主从同步 将主库的数据异步的同步到从库的操作。由于主从同步的异步性，从库与主库的数据会短时间内不一致。
负载均衡策略 通过负载均衡策略将查询请求疏导至不同从库。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/concept/</guid>
      <description>弹性伸缩作业 指一次将数据由旧分片规则伸缩至新分片规则的完整流程。
数据节点 同数据分片中的数据节点
存量数据 在弹性伸缩作业开始前，数据分片中已有的数据。
增量数据 在弹性伸缩作业执行过程中，业务系统所产生的新数据。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/shadow/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/shadow/concept/</guid>
      <description>影子字段 判断该条 SQL 是否需要路由到影子数据库，为逻辑字段，数据库中不存在。
生产数据库 生产数据使用的数据库。
影子数据库 进行压测数据隔离的影子数据库，与生产数据库应当使用相同的配置。</description>
    </item>
    
    <item>
      <title>解析引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/parse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/parse/</guid>
      <description>相对于其他编程语言，SQL 是比较简单的。 不过，它依然是一门完善的编程语言，因此对 SQL 的语法进行解析，与解析其他编程语言（如：Java 语言、C 语言、Go 语言等）并无本质区别。
抽象语法树 解析过程分为词法解析和语法解析。 词法解析器用于将 SQL 拆解为不可再分的原子符号，称为 Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将 SQL 转换为抽象语法树。
例如，以下 SQL：
SELECT id, name FROM t_user WHERE status = &amp;#39;ACTIVE&amp;#39; AND age &amp;gt; 18 解析之后的为抽象语法树见下图。
为了便于理解，抽象语法树中的关键字的 Token 用绿色表示，变量的 Token 用红色表示，灰色表示需要进一步拆分。
最后，通过对抽象语法树的遍历去提炼分片所需的上下文，并标记有可能需要改写的位置。 供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）。 SQL 的一次解析过程是不可逆的，一个个 Token 按 SQL 原本的顺序依次进行解析，性能很高。 考虑到各种数据库 SQL 方言的异同，在解析模块提供了各类数据库的 SQL 方言字典。
SQL 解析引擎 SQL 解析作为分库分表类产品的核心，其性能和兼容性是最重要的衡量指标。 ShardingSphere 的 SQL 解析器经历了 3 代产品的更新迭代。
第一代 SQL 解析器为了追求性能与快速实现，在 1.</description>
    </item>
    
    <item>
      <title>运行部署</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-scaling/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-scaling/build/</guid>
      <description>部署启动  执行以下命令，编译生成 ShardingSphere-Scaling 二进制包：  git clone https://github.com/apache/shardingsphere.git；cd shardingsphere;mvn clean install -Prelease;发布包所在目录为：/shardingsphere-distribution/shardingsphere-scaling-distribution/target/apache-shardingsphere-${latest.release.version}-shardingsphere-scaling-bin.tar.gz。
解压缩发布包，修改配置文件 conf/server.yaml，这里主要修改启动端口，保证不与本机其他端口冲突，同时修改断点续传服务（可选）地址即可：  port: 8888blockQueueSize: 10000pushTimeout: 1000workerThread: 30resumeBreakPoint:name: scalingJobregistryCenter:type: ZooKeeperserverLists: localhost:2181props:retryIntervalMilliseconds: 10000启动 ShardingSphere-Scaling：  sh bin/start.sh 查看日志 logs/stdout.log，确保启动成功。
  使用 curl 命令再次确认正常运行。
  curl -X GET http://localhost:8888/scaling/job/list响应应为：
{&amp;quot;success&amp;quot;:true,&amp;quot;errorCode&amp;quot;:0,&amp;quot;errorMsg&amp;quot;:null,&amp;quot;model&amp;quot;:[]}结束 ShardingSphere-Scaling sh bin/stop.sh应用配置项 应用现有配置项如下，相应的配置可在 conf/server.yaml 中修改：
   名称 说明 默认值     port HTTP服务监听端口 8888   blockQueueSize 数据传输通道队列大小 10000   pushTimeout 数据推送超时时间，单位：毫秒 1000   workerThread 工作线程池大小，允许同时运行的迁移任务线程数 30   resumeBreakPoint 断点续传服务     </description>
    </item>
    
    <item>
      <title>部署运行</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/build/</guid>
      <description>二进制运行  git clone https://github.com/apache/shardingsphere-ui.git； 运行 mvn clean install -Prelease； 获取安装包 /shardingsphere-ui/shardingsphere-ui-distribution/target/apache-shardingsphere-${latest.release.version}-shardingsphere-ui-bin.tar.gz； 解压缩后运行bin/start.sh； 访问http://localhost:8088/。  源码调试模式 ShardingSphere-UI 采用前后端分离的方式。
后端  后端程序执行入口为 org.apache.shardingsphere.ui.Bootstrap； 访问 http://localhost:8088/。  前端  进入 shardingsphere-ui-frontend/ 目录； 执行 npm install； 执行 npm run dev； 访问 http://localhost:8080/。  配置 ShardingSphere-UI 的配置文件为 conf/application.properties, 它由两部分组成。
 程序监听端口； 登录身份验证信息。  server.port=8088user.admin.username=adminuser.admin.password=admin注意事项  若使用 maven 构建后，再进行本地运行前端项目时，可能因为 node 版本不一致导致运行失败，可以清空 node_modules/ 目录后重新运行。 错误日志如下：  ERROR Failed to compile with 17 errorserror in .</description>
    </item>
    
    <item>
      <title>配置中心</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/config-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/config-center/</guid>
      <description>实现动机   配置集中化：越来越多的运行时实例，使得散落的配置难于管理，配置不同步导致的问题十分严重。将配置集中于配置中心，可以更加有效进行管理。
  配置动态化：配置修改后的分发，是配置中心可以提供的另一个重要能力。它可支持数据源和规则的动态切换。
  配置中心数据结构 配置中心在定义的命名空间下，以 YAML 格式存储，包括数据源信息，规则信息、权限配置和属性配置，可通过修改节点来实现对于配置的动态管理。
namespace├──authentication # 权限配置├──props # 属性配置├──schemas # Schema 配置├ ├──${schema_1} # Schema 名称1├ ├ ├──datasource # 数据源配置├ ├ ├──rule # 规则配置├ ├ ├──table # 表结构配置├ ├──${schema_2} # Schema 名称2├ ├ ├──datasource # 数据源配置├ ├ ├──rule # 规则配置├ ├ ├──table # 表结构配置/authentication 权限配置，可配置访问 ShardingSphere-Proxy 的用户名和密码。
username: root password: root /props 属性配置，详情请参见配置手册。</description>
    </item>
    
    <item>
      <title>ShardingSphere-Proxy</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-proxy-quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-proxy-quick-start/</guid>
      <description>1. 规则配置 编辑%SHARDINGSPHERE_PROXY_HOME%/conf/config-xxx.yaml。详情请参见配置手册。
编辑%SHARDINGSPHERE_PROXY_HOME%/conf/server.yaml。详情请参见配置手册。
2. 引入依赖 如果后端连接 PostgreSQL 数据库，不需要引入额外依赖。
如果后端连接 MySQL 数据库，请下载 mysql-connector-java-5.1.47.jar，并将其放入 %SHARDINGSPHERE_PROXY_HOME%/lib 目录。
3. 启动服务  使用默认配置项  sh %SHARDINGSPHERE_PROXY_HOME%/bin/start.sh 默认启动端口为 3307，默认配置文件目录为：%SHARDINGSPHERE_PROXY_HOME%/conf/。
 自定义端口和配置文件目录  sh %SHARDINGSPHERE_PROXY_HOME%/bin/start.sh ${proxy_port} ${proxy_conf_directory} 4. 使用ShardingSphere-Proxy 执行 MySQL 或 PostgreSQL的客户端命令直接操作 ShardingSphere-Proxy 即可。以 MySQL 举例：
mysql -u${proxy_username} -p${proxy_password} -h${proxy_host} -P${proxy_port} </description>
    </item>
    
    <item>
      <title>XA两阶段事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/principle/2pc-xa-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/principle/2pc-xa-transaction/</guid>
      <description>XAShardingTransactionManager 为Apache ShardingSphere 的分布式事务的XA实现类。 它主要负责对多数据源进行管理和适配，并且将相应事务的开启、提交和回滚操作委托给具体的 XA 事务管理器。
开启全局事务 收到接入端的 set autoCommit=0 时，XAShardingTransactionManager 将调用具体的 XA 事务管理器开启 XA 全局事务，以 XID 的形式进行标记。
执行真实分片SQL XAShardingTransactionManager将数据库连接所对应的 XAResource 注册到当前 XA 事务中之后，事务管理器会在此阶段发送 XAResource.start 命令至数据库。 数据库在收到 XAResource.end 命令之前的所有 SQL 操作，会被标记为 XA 事务。
例如:
XAResource1.start ## Enlist阶段执行statement.execute(&amp;quot;sql1&amp;quot;); ## 模拟执行一个分片SQL1statement.execute(&amp;quot;sql2&amp;quot;); ## 模拟执行一个分片SQL2XAResource1.end ## 提交阶段执行示例中的 sql1 和 sql2 将会被标记为 XA 事务。
提交或回滚事务 XAShardingTransactionManager 在接收到接入端的提交命令后，会委托实际的 XA 事务管理进行提交动作， 事务管理器将收集到的当前线程中所有注册的 XAResource，并发送 XAResource.end 指令，用以标记此 XA 事务边界。 接着会依次发送 prepare 指令，收集所有参与 XAResource 投票。 若所有 XAResource 的反馈结果均为正确，则调用 commit 指令进行最终提交； 若有任意 XAResource 的反馈结果不正确，则调用 rollback 指令进行回滚。 在事务管理器发出提交指令后，任何 XAResource 产生的异常都会通过恢复日志进行重试，以保证提交阶段的操作原子性，和数据强一致性。</description>
    </item>
    
    <item>
      <title>XA两阶段事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/2pc-xa-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/2pc-xa-transaction/</guid>
      <description>支持项  支持数据分片后的跨库事务； 两阶段提交保证操作的原子性和数据的强一致性； 服务宕机重启后，提交/回滚中的事务可自动恢复； 支持同时使用 XA 和非 XA 的连接池。  不支持项  服务宕机后，在其它机器上恢复提交/回滚中的数据。  </description>
    </item>
    
    <item>
      <title>使用 Spring Boot Starter</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/spring-boot-starter/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置事务管理器 @Configuration @EnableTransactionManagement public class TransactionConfiguration { @Bean public PlatformTransactionManager txManager(final DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean public JdbcTemplate jdbcTemplate(final DataSource dataSource) { return new JdbcTemplate(dataSource); } } 使用分布式事务 @Transactional @ShardingTransactionType(TransactionType.XA) // 支持TransactionType.LOCAL, TransactionType.XA, TransactionType.BASE public void insert() { jdbcTemplate.execute(&amp;#34;INSERT INTO t_order (user_id, status) VALUES (?</description>
    </item>
    
    <item>
      <title>使用 YAML 配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/yaml/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-governance&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 ZooKeeper 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-zookeeper-curator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 Etcd 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 以下示例将 ZooKeeper 作为配置中心和注册中心。
governance: name: governance_ds registryCenter: type: Zookeeper serverLists: localhost:2181 overwrite: true // 创建 GovernanceShardingSphereDataSource DataSource dataSource = YamlGovernanceShardingSphereDataSourceFactory.createDataSource(yamlFile); 使用 GovernanceShardingSphereDataSource 通过 YamlGovernanceShardingSphereDataSourceFactory 工厂创建的 GovernanceShardingSphereDataSource 实现自 JDBC 的标准接口 DataSource。 可通过 DataSource 选择使用原生 JDBC，或JPA， MyBatis 等 ORM 框架。
以原生 JDBC 使用方式为例：</description>
    </item>
    
    <item>
      <title>使用 YAML 配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/yaml/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 ShardingSphere-JDBC 的 YAML 配置文件 通过数据源集合、规则集合以及属性配置组成。 以下示例是根据 user_id 取模分库, 且根据 order_id 取模分表的 2 库 2 表的配置。
# 配置真实数据源 dataSources: # 配置第 1 个数据源 ds0: !!org.apache.commons.dbcp2.BasicDataSource driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ds0 username: root password: # 配置第 2 个数据源 ds1: !!org.apache.commons.dbcp2.BasicDataSource driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ds1 username: root password: rules: # 配置分片规则 - !SHARDING tables: # 配置 t_order 表规则 t_order: actualDataNodes: ds${0..1}.t_order${0..1} # 配置分库策略 databaseStrategy: standard: shardingColumn: user_id shardingAlgorithmName: database_inline # 配置分表策略 tableStrategy: standard: shardingColumn: order_id shardingAlgorithmName: table_inline t_order_item: # 省略配置 t_order_item 表规则.</description>
    </item>
    
    <item>
      <title>使用手册</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-scaling/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-scaling/usage/</guid>
      <description>使用手册 环境要求 纯 JAVA 开发，JDK 建议 1.8 以上版本。
支持迁移场景如下：
   源端 目标端 是否支持     MySQL(5.1.15 ~ 5.7.x) ShardingSphere-Proxy 是   PostgreSQL(9.4 ~ ) ShardingSphere-Proxy 是    注意：
如果后端连接 MySQL 数据库，请下载 mysql-connector-java-5.1.47.jar，并将其放入 ${shardingsphere-scaling}\lib 目录。
权限要求 MySQL 需要开启 binlog，binlog format 为Row模式，且迁移时所使用用户需要赋予 Replication 相关权限。
+-----------------------------------------+---------------------------------------+| Variable_name | Value |+-----------------------------------------+---------------------------------------+| log_bin | ON || binlog_format | ROW |+-----------------------------------------+---------------------------------------++------------------------------------------------------------------------------+|Grants for ${username}@${host} |+------------------------------------------------------------------------------+|GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.</description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/replica-query/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/replica-query/use-norms/</guid>
      <description>支持项  提供一主多从的读写分离配置，可独立使用，也可配合分库分表使用； 独立使用读写分离支持SQL透传； 同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性； 基于Hint的强制主库路由。  不支持项  主库和从库的数据同步； 主库和从库的数据同步延迟导致的数据不一致； 主库双写或多写； 跨主库和从库之间的事务的数据不一致。主从模型中，事务中读写均用主库。  </description>
    </item>
    
    <item>
      <title>分布式序列算法</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/keygen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/keygen/</guid>
      <description>雪花算法 类型：SNOWFLAKE
可配置属性：
   属性名称 数据类型 说明 默认值     worker-id (?) long 工作机器唯一标识 0   max-vibration-offset (?) int 最大抖动上限值，范围[0, 4096)。注：若使用此算法生成值作分片值，建议配置此属性。此算法在不同毫秒内所生成的 key 取模 2^n (2^n一般为分库或分表数) 之后结果总为 0 或 1。为防止上述分片问题，建议将此属性值配置为 (2^n)-1 1   max-tolerate-time-difference-milliseconds (?) long 最大容忍时钟回退时间，单位：毫秒 10 毫秒    UUID 类型：UUID
可配置属性：无</description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/governance/</guid>
      <description>ShardingSphere-Proxy 支持使用 SPI 方式接入分布式治理，实现配置和元数据统一管理以及实例熔断和从库禁用等功能。
Zookeeper ShardingSphere-Proxy 默认提供了 Zookeeper 解决方案，实现了配置中心和注册中心功能。 配置规则同 ShardingSphere-JDBC YAML 保持一致。
其他第三方组件 详情请参考支持的第三方组件。
 使用 SPI 方式实现相关逻辑编码，并将生成的 jar 包复制至 ShardingSphere-Proxy 的 lib 目录。 按照配置规则进行配置，即可使用。  </description>
    </item>
    
    <item>
      <title>分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/sharding/</guid>
      <description>分片键 用于分片的数据库字段，是将数据库（表）水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。
分片算法 通过分片算法将数据分片，支持通过 =、&amp;gt;=、&amp;lt;=、&amp;gt;、&amp;lt;、BETWEEN 和 IN 分片。 分片算法需要应用方开发者自行实现，可实现的灵活度非常高。
目前提供4种分片算法。 由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。
 标准分片算法  对应 StandardShardingAlgorithm，用于处理使用单一键作为分片键的 =、IN、BETWEEN AND、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=进行分片的场景。需要配合 StandardShardingStrategy 使用。
 复合分片算法  对应 ComplexKeysShardingAlgorithm，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合 ComplexShardingStrategy 使用。
 Hint分片算法  对应 HintShardingAlgorithm，用于处理使用 Hint 行分片的场景。需要配合 HintShardingStrategy 使用。
分片策略 包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供 5 种分片策略。
 标准分片策略  对应 StandardShardingStrategy。提供对 SQ L语句中的 =, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, IN 和 BETWEEN AND 的分片操作支持。 StandardShardingStrategy 只支持单分片键，提供 PreciseShardingAlgorithm 和 RangeShardingAlgorithm 两个分片算法。 PreciseShardingAlgorithm 是必选的，用于处理 = 和 IN 的分片。 RangeShardingAlgorithm 是可选的，用于处理 BETWEEN AND, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=分片，如果不配置 RangeShardingAlgorithm，SQL 中的 BETWEEN AND 将按照全库路由处理。</description>
    </item>
    
    <item>
      <title>分页</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/pagination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/pagination/</guid>
      <description>完全支持MySQL、PostgreSQL和Oracle的分页查询，SQLServer由于分页查询较为复杂，仅部分支持。
分页性能 性能瓶颈 查询偏移量过大的分页会导致数据库获取数据性能低下，以MySQL为例：
SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 这句SQL会使得MySQL在无法利用索引的情况下跳过1000000条记录后，再获取10条记录，其性能可想而知。 而在分库分表的情况下（假设分为2个库），为了保证数据的正确性，SQL会改写为：
SELECT * FROM t_order ORDER BY id LIMIT 0, 1000010 即将偏移量前的记录全部取出，并仅获取排序后的最后10条记录。这会在数据库本身就执行很慢的情况下，进一步加剧性能瓶颈。 因为原SQL仅需要传输10条记录至客户端，而改写之后的SQL则会传输1,000,010 * 2的记录至客户端。
ShardingSphere的优化 ShardingSphere进行了2个方面的优化。
首先，采用流式处理 + 归并排序的方式来避免内存的过量占用。由于SQL改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。 与直觉不同，大多数人认为ShardingSphere会将1,000,010 * 2记录全部加载至内存，进而占用大量内存而导致内存溢出。 但由于每个结果集的记录是有序的，因此ShardingSphere每次比较仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。 对于本身即有序的待排序对象，归并排序的时间复杂度仅为O(n)，性能损耗很小。
其次，ShardingSphere对仅落至单分片的查询进行进一步优化。 落至单分片查询的请求并不需要改写SQL也可以保证记录的正确性，因此在此种情况下，ShardingSphere并未进行SQL改写，从而达到节省带宽的目的。
分页方案优化 由于LIMIT并不能通过索引查询数据，因此如果可以保证ID的连续性，通过ID进行分页是比较好的解决方案：
SELECT * FROM t_order WHERE id &amp;gt; 100000 AND id &amp;lt;= 100010 ORDER BY id 或通过记录上次查询结果的最后一条记录的ID进行下一页的查询：
SELECT * FROM t_order WHERE id &amp;gt; 100000 LIMIT 10 分页子查询 Oracle和SQLServer的分页都需要通过子查询来处理，ShardingSphere支持分页相关的子查询。</description>
    </item>
    
    <item>
      <title>实现原理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/principle/</guid>
      <description>处理流程详解 Apache ShardingSphere 通过对用户输入的 SQL 进行解析，并依据用户提供的加密规则对 SQL 进行改写，从而实现对原文数据进行加密，并将原文数据（可选）及密文数据同时存储到底层数据库。 在用户查询数据时，它仅从数据库中取出密文数据，并对其解密，最终将解密后的原始数据返回给用户。 Apache ShardingSphere 自动化 &amp;amp; 透明化了数据加密过程，让用户无需关注数据加密的实现细节，像使用普通数据那样使用加密数据。 此外，无论是已在线业务进行加密改造，还是新上线业务使用加密功能，Apache ShardingSphere 都可以提供一套相对完善的解决方案。
整体架构 加密模块将用户发起的 SQL 进行拦截，并通过 SQL 语法解析器进行解析、理解 SQL 行为，再依据用户传入的加密规则，找出需要加密的字段和所使用的加解密算法对目标字段进行加解密处理后，再与底层数据库进行交互。 Apache ShardingSphere 会将用户请求的明文进行加密后存储到底层数据库；并在用户查询时，将密文从数据库中取出进行解密后返回给终端用户。 通过屏蔽对数据的加密处理，使用户无需感知解析 SQL、数据加密、数据解密的处理过程，就像在使用普通数据一样使用加密数据。
加密规则 在详解整套流程之前，我们需要先了解下加密规则与配置，这是认识整套流程的基础。加密配置主要分为四部分：数据源配置，加密算法配置，加密表配置以及查询属性配置，其详情如下图所示：
数据源配置：指数据源配置。
加密算法配置：指使用什么加密算法进行加解密。目前ShardingSphere内置了两种加解密算法：AES/MD5。用户还可以通过实现ShardingSphere提供的接口，自行实现一套加解密算法。
加密表配置：用于告诉ShardingSphere数据表里哪个列用于存储密文数据（cipherColumn）以及用户想使用哪个列进行SQL编写（logicColumn）。
 如何理解用户想使用哪个列进行SQL编写（logicColumn）？
我们可以从加密模块存在的意义来理解。加密模块最终目的是希望屏蔽底层对数据的加密处理，也就是说我们不希望用户知道数据是如何被加解密的、如何将密文数据存储到 cipherColumn。 换句话说，我们不希望用户知道 cipherColumn 的存在和使用。 所以，我们需要给用户提供一个概念意义上的列，这个列可以脱离底层数据库的真实列，它可以是数据库表里的一个真实列，也可以不是，从而使得用户可以随意改变底层数据库的 cipherColumn 的列名。 只要用户的 SQL 面向这个逻辑列进行编写，并在加密规则里给出 logicColumn 和 cipherColumn 之间正确的映射关系即可。
为什么要这么做呢？答案在文章后面，即为了让已上线的业务能无缝、透明、安全地进行数据加密迁移。
 查询属性的配置：当底层数据库表里同时存储了明文数据、密文数据后，该属性开关用于决定是直接查询数据库表里的明文数据进行返回，还是查询密文数据通过 Apache ShardingSphere 解密后返回。
加密处理过程 举例说明，假如数据库里有一张表叫做 t_user，这张表里实际有两个字段 pwd_plain，用于存放明文数据、pwd_cipher，用于存放密文数据，同时定义 logicColumn 为 pwd。 那么，用户在编写 SQL 时应该面向 logicColumn 进行编写，即 INSERT INTO t_user SET pwd = &#39;123&#39;。 Apache ShardingSphere 接收到该 SQL，通过用户提供的加密配置，发现 pwd 是 logicColumn，于是便对逻辑列及其对应的明文数据进行加密处理。 Apache ShardingSphere 将面向用户的逻辑列与面向底层数据库的密文列进行了列名以及数据的加密映射转换。 如下图所示：</description>
    </item>
    
    <item>
      <title>实现原理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/principle/</guid>
      <description>原理说明 考虑到 Apache ShardingSphere 的弹性伸缩模块的几个挑战，目前的弹性伸缩解决方案为：临时地使用两个数据库集群，伸缩完成后切换的方式实现。
这种实现方式有以下优点：
 伸缩过程中，原始数据没有任何影响 伸缩失败无风险 不受分片策略限制  同时也存在一定的缺点：
 在一定时间内存在冗余服务器 所有数据都需要移动  弹性伸缩模块会通过解析旧分片规则，提取配置中的数据源、数据节点等信息，之后创建伸缩作业工作流，将一次弹性伸缩拆解为4个主要阶段
 准备阶段 存量数据迁移阶段 增量数据同步阶段 规则切换阶段  执行阶段说明 准备阶段 在准备阶段，弹性伸缩模块会进行数据源连通性及权限的校验，同时进行存量数据的统计、日志位点的记录，最后根据数据量和用户设置的并行度，对任务进行分片。
存量数据迁移阶段 执行在准备阶段拆分好的存量数据迁移作业，存量迁移阶段采用 JDBC 查询的方式，直接从数据节点中读取数据，并使用新规则写入到新集群中。
增量数据同步阶段 由于存量数据迁移耗费的时间受到数据量和并行度等因素影响，此时需要对这段时间内业务新增的数据进行同步。 不同的数据库使用的技术细节不同，但总体上均为基于复制协议或 WAL 日志实现的变更数据捕获功能。
 MySQL：订阅并解析 binlog PostgreSQL：采用官方逻辑复制 test_decoding  这些捕获的增量数据，同样会由弹性伸缩模块根据新规则写入到新数据节点中。当增量数据基本同步完成时（由于业务系统未停止，增量数据是不断的），则进入规则切换阶段。
规则切换阶段 在此阶段，可能存在一定时间的业务只读窗口期，通过设置数据库只读或ShardingSphere的熔断机制，让旧数据节点中的数据短暂静态，确保增量同步已完全完成。
这个窗口期时间短则数秒，长则数分钟，取决于数据量和用户是否需要对数据进行强校验。 确认完成后，Apache ShardingSphere 可通过配置中心修改配置，将业务导向新规则的集群，弹性伸缩完成。</description>
    </item>
    
    <item>
      <title>实现原理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/shadow/principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/shadow/principle/</guid>
      <description>整体架构 Apache ShardingSphere 通过解析 SQL，根据配置文件中用户设置的影子规则，对传入的 SQL 进行路由并改写，删除影子字段与字段值。用户无需关注具体过程， 使用时仅对 SQL 进行相应改造，添加影子字段与相应的配置即可。
影子规则 影子规则包含影子字段及映射关系。
处理过程 以 INSERT 语句为例，在写入数据时，Apache ShardingSphere 会对 SQL 进行解析，再根据配置文件中的规则，构造一条路由链。在当前版本的功能中， 影子功能处于路由链中的最后一个执行单元，即，如果有其他需要路由的规则存在，如分片，Apache ShardingSphere 会首先根据分片规则，路由到某一个数据库，再 执行影子路由，将影子数据路由到与之对应的影子库，生产数据则维持不变。
接着对 SQL 进行改写，由于影子字段为逻辑字段，在数据库中实际不存在，所以在改写过程中会删除这个字段及其对应的参数。
DML 语句的处理过程同理，对于非 DML 语句，如创建数据表等，会在生产数据库与影子数据库分别执行。</description>
    </item>
    
    <item>
      <title>整合测试引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/integration-test-engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/integration-test-engine/</guid>
      <description>流程 Junit 中的 Parameterized 会聚合起所有的测试数据，并将测试数据一一传递给测试方法进行断言。数据处理就像是沙漏中的流沙：
配置  环境类文件  /shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties /shardingsphere-test-suite/src/test/resources/integrate/env/SQL-TYPE/dataset.xml /shardingsphere-test-suite/src/test/resources/integrate/env/SQL-TYPE/schema.xml   测试用例类文件  /shardingsphere-test-suite/src/test/resources/integrate/cases/SQL-TYPE/SQL-TYPE-integrate-test-cases.xml /shardingsphere-test-suite/src/test/resources/integrate/cases/SQL-TYPE/dataset/FEATURE-TYPE/*.xml   sql-case 文件  /sharding-sql-test/src/main/resources/sql/sharding/SQL-TYPE/*.xml    环境配置 集成测试需要真实的数据库环境，根据相应的配置文件创建测试环境：
首先，修改配置文件 /shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties ，例子如下：
# 测试主键，并发，column index等的开关run.additional.cases=false# 分片策略，可指定多种策略sharding.rule.type=db,tbl,dbtbl_with_replica_query,replica_query# 要测试的数据库，可以指定多种数据库(H2,MySQL,Oracle,SQLServer,PostgreSQL)databases=MySQL,PostgreSQL# MySQL配置mysql.host=127.0.0.1mysql.port=13306mysql.username=rootmysql.password=root## PostgreSQL配置postgresql.host=db.psqlpostgresql.port=5432postgresql.username=postgrespostgresql.password=postgres## SQLServer配置sqlserver.host=db.mssqlsqlserver.port=1433sqlserver.username=sasqlserver.password=Jdbc1234## Oracle配置oracle.host=db.oracleoracle.port=1521oracle.username=jdbcoracle.password=jdbc其次，修改文件 /shardingsphere-test-suite/src/test/resources/integrate/env/SQL-TYPE/dataset.xml 在dataset.xml文件中定义元数据和测试数据。例如：
&amp;lt;dataset&amp;gt; &amp;lt;metadata data-nodes=&amp;#34;tbl.</description>
    </item>
    
    <item>
      <title>权限配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/authentication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/authentication/</guid>
      <description>用于执行登录 Sharding Proxy 的权限验证。 配置用户名、密码、可访问的数据库后，必须使用正确的用户名、密码才可登录。
authentication: users: root: # 自定义用户名 password: root # 自定义用户名 sharding: # 自定义用户名 password: sharding # 自定义用户名 authorizedSchemas: sharding_db, replica_query_db # 该用户授权可访问的数据库，多个用逗号分隔。缺省将拥有 root 权限，可访问全部数据库。 </description>
    </item>
    
    <item>
      <title>注册中心</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/registry-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/registry-center/</guid>
      <description>实现动机   相对于配置中心管理配置数据，注册中心存放运行时的动态/临时状态数据，比如可用的 ShardingSphere 的实例，需要禁用或熔断的数据源等。
  通过注册中心，可以提供熔断数据库访问程序对数据库的访问和禁用从库的访问的编排治理能力。治理模块仍然有大量未完成的功能（比如流控等）。
  注册中心数据结构 注册中心在定义的命名空间的 states 节点下，创建数据库访问对象运行节点，用于区分不同数据库访问实例。包括 proxynodes 和 datanodes 节点。
namespace├──states├ ├──proxynodes├ ├ ├──${your_instance_ip_a}@${your_instance_pid_x}@${UUID}├ ├ ├──${your_instance_ip_b}@${your_instance_pid_y}@${UUID}├ ├ ├──....├ ├──datanodes├ ├ ├──${schema_1}├ ├ ├ ├──${ds_0}├ ├ ├ ├──${ds_1}├ ├ ├──${schema_2}├ ├ ├ ├──${ds_0}├ ├ ├ ├──${ds_1}├ ├ ├──..../states/proxynodes 数据库访问对象运行实例信息，子节点是当前运行实例的标识。 运行实例标识由运行服务器的 IP 地址和 PID 构成。运行实例标识均为临时节点，当实例上线时注册，下线时自动清理。 注册中心监控这些节点的变化来治理运行中实例对数据库的访问等。
/states/datanodes 可以治理读写分离从库，可动态添加删除以及禁用。
操作指南 熔断实例 可在 IP地址@PID@UUID 节点写入 DISABLED（忽略大小写）表示禁用该实例，删除 DISABLED 表示启用。</description>
    </item>
    
    <item>
      <title>注册中心</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/registry-center/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/registry-center/</guid>
      <description>注册中心配置 首先需要添加并激活注册中心。可以添加多个注册中心，但只能有一个处于激活状态，后面的运行状态功能都是针对当前已激活的注册中心进行操作。 目前提供 Zookeeper 和 etcd 的支持，后续会添加第三方注册中心的支持。
  点击 + 按钮可以添加新注册中心。
  通过配置扩展配置中心来使用其它配置中心管理配置。
  支持编辑、激活和删除注册中心操作。
  </description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/replica-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/replica-query/</guid>
      <description>配置入口 类名称：ReplicaQueryRuleConfiguration
可配置属性：
   名称 数据类型 说明     dataSources (+) Collection&amp;lt;ReplicaQueryDataSourceRuleConfiguration&amp;gt; 主从数据源配置   loadBalancers (*) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 从库负载均衡算法配置    主从数据源配置 类名称：ReplicaQueryDataSourceRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     name String 读写分离数据源名称 -   primaryDataSourceName String 主库数据源名称 -   replicaDataSourceNames (+) Collection&amp;lt;String&amp;gt; 从库数据源名称列表 -   loadBalancerName (?) String 从库负载均衡算法名称 轮询负载均衡算法    算法类型的详情，请参见内置负载均衡算法列表。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/replica-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/replica-query/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置spring.shardingsphere.rules.replica-query.data-sources.&amp;lt;replica-query-data-source-name&amp;gt;.primary-data-source-name= # 主数据源名称spring.shardingsphere.rules.replica-query.data-sources.&amp;lt;replica-query-data-source-name&amp;gt;.replica-data-source-names= # 从数据源名称，多个从数据源用逗号分隔spring.shardingsphere.rules.replica-query.data-sources.&amp;lt;replica-query-data-source-name&amp;gt;.load-balancer-name= # 负载均衡算法名称# 负载均衡算法配置spring.shardingsphere.rules.replica-query.load-balancers.&amp;lt;load-balance-algorithm-name&amp;gt;.type= # 负载均衡算法类型spring.shardingsphere.rules.replica-query.load-balancers.&amp;lt;load-balance-algorithm-name&amp;gt;.props.xxx= # 负载均衡算法属性配置算法类型的详情，请参见内置负载均衡算法列表。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/replica-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/replica-query/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/replica-query/replica-query-5.0.0.xsd
&amp;lt;replica-query:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   data-source-rule (+) 标签 读写分离数据源规则配置    &amp;lt;replica-query:data-source-rule /&amp;gt;
   名称 类型 说明     id 属性 读写分离数据源规则名称   primary-data-source-name 属性 主数据源名称   replica-data-source-names 属性 从数据源名称，多个从数据源用逗号分隔   load-balance-algorithm-ref 属性 负载均衡算法名称    &amp;lt;replica-query:load-balance-algorithm /&amp;gt;
   名称 类型 说明     id 属性 负载均衡算法名称   type 属性 负载均衡算法类型   props (?</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/replica-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/replica-query/</guid>
      <description>配置项说明 dataSources: # 省略数据源配置 rules: - !REPLICA_QUERY dataSources: &amp;lt;data-source-name&amp;gt; (+): # 读写分离逻辑数据源名称 primaryDataSourceName: # 主库数据源名称 replicaDataSourceNames: - &amp;lt;replica-data_source-name&amp;gt; (+) # 从库数据源名称 loadBalancerName: # 负载均衡算法名称 # 负载均衡算法配置 loadBalancers: &amp;lt;load-balancer-name&amp;gt; (+): # 负载均衡算法名称 type: # 负载均衡算法类型 props: # 负载均衡算法属性配置 # ... props: # ... 算法类型的详情，请参见内置负载均衡算法列表。</description>
    </item>
    
    <item>
      <title>路由引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/route/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/route/</guid>
      <description>根据解析上下文匹配数据库和表的分片策略，并生成路由路径。 对于携带分片键的 SQL，根据分片键的不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是 IN)和范围路由(分片键的操作符是 BETWEEN)。 不携带分片键的 SQL 则采用广播路由。
分片策略通常可以采用由数据库内置或由用户方配置。 数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等。 由用户方配置的分片策略则更加灵活，可以根据使用方需求定制复合分片策略。 如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可，进而做到使分布式数据库具有的弹性伸缩的能力。 在 ShardingSphere 的线路规划中，弹性伸缩将于 4.x 开启。
分片路由 用于根据分片键进行路由的场景，又细分为直接路由、标准路由和笛卡尔积路由这 3 种类型。
直接路由 满足直接路由的条件相对苛刻，它需要通过 Hint（使用 HintAPI 直接指定路由至库表）方式分片，并且是只分库不分表的前提下，则可以避免 SQL 解析和之后的结果归并。 因此它的兼容性最好，可以执行包括子查询、自定义函数等复杂情况的任意 SQL。直接路由还可以用于分片键不在 SQL 中的场景。例如，设置用于数据库分片的键为 3，
hintManager.setDatabaseShardingValue(3); 假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：
String sql = &amp;#34;SELECT * FROM t_order&amp;#34;; try ( HintManager hintManager = HintManager.getInstance(); Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.</description>
    </item>
    
    <item>
      <title>配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/configuration/</guid>
      <description>ShardingSphereRuleBuilder    SPI 名称 详细说明     ShardingSphereRuleBuilder 用于将用户配置转化为规则对象       已知实现类 详细说明     ShardingRuleBuilder 用于将分片用户配置转化为分片规则对象   ReplicaQueryRuleBuilder 用于将读写分离用户配置转化为读写分离规则对象   EncryptRuleBuilder 用于将加密用户配置转化为加密规则对象   ShadowRuleBuilder 用于将影子库用户配置转化为影子库规则对象    YamlRuleConfigurationSwapper    SPI 名称 详细说明     YamlRuleConfigurationSwapper 用于将 YAML 配置转化为标准用户配置       已知实现类 详细说明     ShardingRuleConfigurationYamlSwapper 用于将分片的 YAML 配置转化为分片标准配置   ReplicaQueryRuleConfigurationYamlSwapper 用于将读写分离的 YAML 配置转化为读写分离标准配置   EncryptRuleConfigurationYamlSwapper 用于将加密的 YAML 分片配置转化为加密标准配置   ShadowRuleConfigurationYamlSwapper 用于将影子库的 YAML 分片配置转化为影子库标准配置    ShardingSphereYamlConstruct    SPI 名称 详细说明     ShardingSphereYamlConstruct 用于将定制化对象和 YAML 相互转化       已知实现类 详细说明     NoneShardingStrategyConfigurationYamlConstruct 用于将不分片策略对象和 YAML 相互转化    </description>
    </item>
    
    <item>
      <title>Docker 镜像</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/docker/</guid>
      <description>拉取官方 Docker 镜像 docker pull apache/shardingsphere-proxy 手动构建 Docker 镜像（可选） git clone https://github.com/apache/shardingsphere mvn clean install cd shardingsphere-distribution/shardingsphere-proxy-distribution mvn clean package -Prelease,docker 配置 ShardingSphere-Proxy 在 /${your_work_dir}/conf/ 创建 server.yaml 和 config-xxx.yaml 文件，进行服务器和分片规则配置。 配置规则，请参考配置手册。 配置模板，请参考配置模板
运行 Docker docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -e PORT=3308 -p13308:3308 apache/shardingsphere-proxy:latest 说明
 可以自定义端口 3308 和 13308。3308 表示 docker 容器端口, 13308 表示宿主机端口。 必须挂载配置路径到 /opt/shardingsphere-proxy/conf。  docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -e JVM_OPTS=&amp;#34;-Djava.awt.headless=true&amp;#34; -e PORT=3308 -p13308:3308 apache/shardingsphere-proxy:latest 说明
 可以自定义JVM相关参数到环境变量 JVM_OPTS 中。  docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -v /${your_work_dir}/ext-lib:/opt/shardingsphere-proxy/ext-lib -p13308:3308 apache/shardingsphere-proxy:latest 说明</description>
    </item>
    
    <item>
      <title>Seata 柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/concept/base-transaction-seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/concept/base-transaction-seata/</guid>
      <description>Seata是阿里集团和蚂蚁金服联合打造的分布式事务框架。 其 AT 事务的目标是在微服务架构下，提供增量的事务 ACID 语意，让开发者像使用本地事务一样，使用分布式事务，核心理念同 Apache ShardingSphere 一脉相承。
Seata AT 事务模型包含TM (事务管理器)，RM (资源管理器) 和 TC (事务协调器)。 TC 是一个独立部署的服务，TM 和 RM 以 jar 包的方式同业务应用一同部署，它们同 TC 建立长连接，在整个事务生命周期内，保持远程通信。 TM 是全局事务的发起方，负责全局事务的开启，提交和回滚。 RM 是全局事务的参与者，负责分支事务的执行结果上报，并且通过 TC 的协调进行分支事务的提交和回滚。
Seata 管理的分布式事务的典型生命周期：
 TM 要求 TC 开始一个全新的全局事务。TC 生成一个代表该全局事务的 XID。 XID 贯穿于微服务的整个调用链。 作为该 XID 对应到的 TC 下的全局事务的一部分，RM 注册本地事务。 TM 要求 TC 提交或回滚 XID 对应的全局事务。 TC 驱动 XID 对应的全局事务下的所有分支事务完成提交或回滚。  </description>
    </item>
    
    <item>
      <title>Seata 柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/principle/base-transaction-seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/principle/base-transaction-seata/</guid>
      <description>整合 Seata AT 事务时，需要将 TM，RM 和 TC 的模型融入 Apache ShardingSphere 的分布式事务生态中。 在数据库资源上，Seata 通过对接 DataSource 接口，让 JDBC 操作可以同 TC 进行远程通信。 同样，Apache ShardingSphere 也是面向 DataSource 接口，对用户配置的数据源进行聚合。 因此，将 DataSource 封装为 基于Seata 的 DataSource 后，就可以将 Seata AT 事务融入到 Apache ShardingSphere的分片生态中。
引擎初始化 包含 Seata 柔性事务的应用启动时，用户配置的数据源会根据 seata.conf 的配置，适配为 Seata 事务所需的 DataSourceProxy，并且注册至 RM 中。
开启全局事务 TM 控制全局事务的边界，TM 通过向 TC 发送 Begin 指令，获取全局事务 ID，所有分支事务通过此全局事务 ID，参与到全局事务中；全局事务 ID 的上下文存放在当前线程变量中。
执行真实分片SQL 处于 Seata 全局事务中的分片 SQL 通过 RM 生成 undo 快照，并且发送 participate 指令至 TC，加入到全局事务中。 由于 Apache ShardingSphere 的分片物理 SQL 采取多线程方式执行，因此整合 Seata AT 事务时，需要在主线程和子线程间进行全局事务 ID 的上下文传递。</description>
    </item>
    
    <item>
      <title>Seata 柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/base-transaction-seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/transaction/use-norms/base-transaction-seata/</guid>
      <description>支持项  支持数据分片后的跨库事务； 支持RC隔离级别； 通过undo快照进行事务回滚； 支持服务宕机后的，自动恢复提交中的事务。  不支持项  不支持除RC之外的隔离级别。  待优化项  Apache ShardingSphere 和 Seata 重复 SQL 解析。  </description>
    </item>
    
    <item>
      <title>ShardingSphere-Scaling(Alpha)</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-scaling-quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/quick-start/shardingsphere-scaling-quick-start/</guid>
      <description>1. 规则配置 编辑%SHARDINGSPHERE_SCALING_HOME%/conf/server.yaml。详情请参见使用手册。
2. 引入依赖 如果后端连接 PostgreSQL 数据库，不需要引入额外依赖。
如果后端连接 MySQL 数据库，请下载 mysql-connector-java-5.1.47.jar，并将其放入 %SHARDINGSPHERE_SCALING_HOME%/lib 目录。
3. 启动服务 sh %SHARDINGSPHERE_SCALING_HOME%/bin/start.sh 4. 任务管理 通过相应的 HTTP 接口管理迁移任务。
详情参见使用手册。</description>
    </item>
    
    <item>
      <title>SQL解析测试引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/parse-test-engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/parse-test-engine/</guid>
      <description>数据准备 SQL解析不需要真实的测试环境，开发者只需定义好待测试的SQL，以及解析后的断言数据即可：
SQL数据 在集成测试的部分提到过sql-case-id，其对应的SQL，可以在不同模块共享。开发者只需要在/sharding-sql-test/src/main/resources/sql/sharding/SQL-TYPE/*.xml 添加待测试的SQL即可。
断言解析数据 断言的解析数据保存在 /sharding-core/sharding-core-parse/sharding-core-parse-test/src/test/resources/sharding/SQL-TYPE/*.xml 在xml文件中，可以针对表名，token，SQL条件等进行断言，例如如下的配置：
&amp;lt;parser-result-sets&amp;gt; &amp;lt;parser-result sql-case-id=&amp;#34;insert_with_multiple_values&amp;#34;&amp;gt; &amp;lt;tables&amp;gt; &amp;lt;table name=&amp;#34;t_order&amp;#34; /&amp;gt; &amp;lt;/tables&amp;gt; &amp;lt;tokens&amp;gt; &amp;lt;table-token start-index=&amp;#34;12&amp;#34; table-name=&amp;#34;t_order&amp;#34; length=&amp;#34;7&amp;#34; /&amp;gt; &amp;lt;/tokens&amp;gt; &amp;lt;sharding-conditions&amp;gt; &amp;lt;and-condition&amp;gt; &amp;lt;condition column-name=&amp;#34;order_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;1&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;condition column-name=&amp;#34;user_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;1&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;/and-condition&amp;gt; &amp;lt;and-condition&amp;gt; &amp;lt;condition column-name=&amp;#34;order_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;2&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;condition column-name=&amp;#34;user_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;2&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;/and-condition&amp;gt; &amp;lt;/sharding-conditions&amp;gt; &amp;lt;/parser-result&amp;gt; &amp;lt;/parser-result-sets&amp;gt; 设置好上面两类数据，开发者就可以通过 sharding-core-parse-test 下对应的engine启动SQL解析的测试了。</description>
    </item>
    
    <item>
      <title>不支持项</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/unsupported-items/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/unsupported-items/</guid>
      <description>DataSource 接口  不支持 timeout 相关操作  Connection 接口  不支持存储过程，函数，游标的操作 不支持执行 native SQL 不支持 savepoint 相关操作 不支持 Schema/Catalog 的操作 不支持自定义类型映射  Statement 和 PreparedStatement 接口  不支持返回多结果集的语句（即存储过程，非 SELECT 多条数据） 不支持国际化字符的操作  ResultSet 接口  不支持对于结果集指针位置判断 不支持通过非 next 方法改变结果指针位置 不支持修改结果集内容 不支持获取国际化字符 不支持获取 Array  JDBC 4.1  不支持 JDBC 4.1 接口新功能  查询所有未支持方法，请阅读 org.apache.shardingsphere.driver.jdbc.unsupported 包。</description>
    </item>
    
    <item>
      <title>使用 Spring Boot Starter</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-boot-starter/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-governance-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 ZooKeeper 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-zookeeper-curator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 Etcd 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 spring.shardingsphere.governance.name=governance-spring-boot-shardingsphere-testspring.shardingsphere.governance.registry-center.type=Zookeeperspring.shardingsphere.governance.registry-center.server-lists=localhost:2181spring.shardingsphere.governance.additional-config-center.type=Zookeeperspring.shardingsphere.governance.additional-config-center.server-lists=localhost:2182spring.shardingsphere.governance.overwrite=true在 Spring 中使用 GovernanceShardingSphereDataSource 直接通过注入的方式即可使用 GovernanceShardingSphereDataSource；或者将 GovernanceShardingSphereDataSource 配置在JPA， MyBatis 等 ORM 框架中配合使用。
@Resource private DataSource dataSource; </description>
    </item>
    
    <item>
      <title>使用 Spring Boot Starter</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 # 配置真实数据源spring.shardingsphere.datasource.names=ds0,ds1# 配置第 1 个数据源spring.shardingsphere.datasource.ds0.type=org.apache.commons.dbcp2.BasicDataSourcespring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driverspring.shardingsphere.datasource.ds0.url=jdbc:mysql://localhost:3306/ds0spring.shardingsphere.datasource.ds0.username=rootspring.shardingsphere.datasource.ds0.password=# 配置第 2 个数据源spring.shardingsphere.datasource.ds1.type=org.apache.commons.dbcp2.BasicDataSourcespring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driverspring.shardingsphere.datasource.ds1.url=jdbc:mysql://localhost:3306/ds1spring.shardingsphere.datasource.ds1.username=rootspring.shardingsphere.datasource.ds1.password=# 配置 t_order 表规则spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes=ds$-&amp;gt;{0..1}.t_order$-&amp;gt;{0..1}# 配置分库策略spring.shardingsphere.rules.sharding.tables.t_order.database-strategy.standard.sharding-column=user_idspring.shardingsphere.rules.sharding.tables.t_order.database-strategy.standard.sharding-algorithm-name=database_inline# 配置分表策略spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.standard.sharding-column=order_idspring.shardingsphere.rules.sharding.tables.t_order.table-strategy.standard.sharding-algorithm-name=table_inline# 省略配置 t_order_item 表规则...# ...# 配置 分片算法spring.shardingsphere.rules.sharding.sharding-algorithms.database_inline.type=INLINEspring.shardingsphere.rules.sharding.sharding-algorithms.database_inline.props.algorithm-expression=ds_${user_id % 2}spring.shardingsphere.rules.sharding.sharding-algorithms.table_inline.type=INLINEspring.shardingsphere.rules.sharding.sharding-algorithms.table_inline.props.algorithm-expression=t_order_${order_id % 2}使用 JNDI 数据源 如果计划使用 JNDI 配置数据库，在应用容器（如 Tomcat）中使用 ShardingSphere-JDBC 时， 可使用 spring.</description>
    </item>
    
    <item>
      <title>使用 Spring 命名空间</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/spring-namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/spring-namespace/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-spring-namespace&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置事务管理器 &amp;lt;!-- ShardingDataSource 的相关配置 --&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;bean id=&amp;#34;transactionManager&amp;#34; class=&amp;#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;shardingDataSource&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;jdbcTemplate&amp;#34; class=&amp;#34;org.springframework.jdbc.core.JdbcTemplate&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;shardingDataSource&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;tx:annotation-driven /&amp;gt; &amp;lt;!-- 开启自动扫描 @ShardingTransactionType 注解，使用 Spring 原生的 AOP 在类和方法上进行增强 --&amp;gt; &amp;lt;sharding:tx-type-annotation-driven /&amp;gt; 使用分布式事务 @Transactional @ShardingTransactionType(TransactionType.XA) // 支持TransactionType.LOCAL, TransactionType.</description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/encrypt/use-norms/</guid>
      <description>支持项  后端数据库为 MySQL、Oracle、PostgreSQL、SQLServer； 用户需要对数据库表中某个或多个列进行加密（数据加密 &amp;amp; 解密）； 兼容所有常用SQL。  不支持项  用户需要自行处理数据库中原始的存量数据、洗数； 使用加密功能+分库分表功能，部分特殊SQL不支持，请参考SQL使用规范； 加密字段无法支持比较操作，如：大于小于、ORDER BY、BETWEEN、LIKE等； 加密字段无法支持计算操作，如：AVG、SUM以及计算表达式。  </description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/scaling/use-norms/</guid>
      <description>支持项  将外围数据迁移至 Apache ShardingSphere 所管理的数据库； 将 Apache ShardingSphere 的数据节点进行扩容或缩容。  不支持项  不支持无主键表的扩容和缩容。  </description>
    </item>
    
    <item>
      <title>内核</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/kernel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/kernel/</guid>
      <description>DatabaseType    SPI 名称 详细说明     DatabaseType 支持的数据库类型       已知实现类 详细说明     SQL92DatabaseType 遵循 SQL92 标准的数据库类型   MySQLDatabaseType MySQL 数据库   MariaDBDatabaseType MariaDB 数据库   PostgreSQLDatabaseType PostgreSQL 数据库   OracleDatabaseType Oracle 数据库   SQLServerDatabaseType SQLServer 数据库   H2DatabaseType H2 数据库    LogicMetaDataLoader    SPI 名称 详细说明     LogicMetaDataLoader 用于元数据初始化       已知实现类 详细说明     ShardingMetaDataLoader 用于分片元数据初始化   EncryptMetaDataLoader 用于加密元数据初始化    LogicMetaDataDecorator    SPI 名称 详细说明     LogicMetaDataDecorator 用于元数据更新       已知实现类 详细说明     ShardingMetaDataDecorator 用于分片元数据更新   EncryptMetaDataDecorator 用于加密元数据更新    SQLRouter    SPI 名称 详细说明     SQLRouter 用于处理路由结果       已知实现类 详细说明     ShardingSQLRouter 用于处理分片路由结果   ReplicaQuerySQLRouter 用于处理读写分离路由结果   ShadowSQLRouter 用于处理影子库路由结果    SQLRewriteContextDecorator    SPI 名称 详细说明     SQLRewriteContextDecorator 用于处理 SQL 改写结果       已知实现类 详细说明     ShardingSQLRewriteContextDecorator 用于处理分片 SQL 改写结果   EncryptSQLRewriteContextDecorator 用于处理加密 SQL 改写结果   ShadowSQLRewriteContextDecorator 用于处理影子库 SQL 改写结果    SQLExecutionHook    SPI 名称 详细说明     SQLExecutionHook SQL执行过程监听器       已知实现类 详细说明     TransactionalSQLExecutionHook 基于事务的SQL执行过程监听器   OpenTracingSQLExecutionHook 基于 OpenTracing 的SQL执行过程监听器    ResultProcessEngine    SPI 名称 详细说明     ResultProcessEngine 用于处理结果集       已知实现类 详细说明     ShardingResultMergerEngine 用于处理分片结果集归并   EncryptResultDecoratorEngine 用于处理加密结果集改写    </description>
    </item>
    
    <item>
      <title>分布式事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/transaction/</guid>
      <description>ShardingSphere-Proxy 接入的分布式事务 API 同 ShardingSphere-JDBC 保持一致，支持 LOCAL，XA，BASE 类型的事务。
XA 事务 ShardingSphere-Proxy 原生支持 XA 事务，默认的事务管理器为 Atomikos。 可以通过在 ShardingSphere-Proxy 的 conf 目录中添加 jta.properties 来定制化 Atomikos 配置项。 具体的配置规则请参考 Atomikos 的官方文档。
BASE事务 BASE 目前没有集成至 ShardingSphere-Proxy 的二进制发布包中，使用时需要将实现了 ShardingTransactionManager SPI 的 jar 拷贝至 conf/lib 目录，然后切换事务类型为 BASE。</description>
    </item>
    
    <item>
      <title>属性配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/props/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/props/</guid>
      <description>简介 Apache ShardingSphere 提供属性配置的方式配置系统级配置。
配置项说明    名称 数据类型 说明 默认值     sql-show (?) boolean 是否在日志中打印 SQL。 打印 SQL 可以帮助开发者快速定位系统问题。日志内容包含：逻辑 SQL，真实 SQL 和 SQL 解析结果。
如果开启配置，日志将使用 Topic ShardingSphere-SQL，日志级别是 INFO。 false   sql-simple (?) boolean 是否在日志中打印简单风格的 SQL。 false   acceptor-size (?) int 用于设置接收 TCP 请求线程池的大小。 CPU * 2   executor-size (?) int 用于设置任务处理线程池的大小。每个 ShardingSphereDataSource 使用一个独立的线程池，同一个 JVM 的不同数据源不共享线程池。 infinite   max-connections-size-per-query (?) int 一次查询请求在每个数据库实例中所能使用的最大连接数。 1   check-table-metadata-enabled (?</description>
    </item>
    
    <item>
      <title>改写引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/rewrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/rewrite/</guid>
      <description>工程师面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。 它包括正确性改写和优化改写两部分。
正确性改写 在包含分表的场景中，需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。除此之外，还包括补列和分页信息修正等内容。
标识符改写 需要改写的标识符包括表名称、索引名称以及 Schema 名称。
表名称改写是指将找到逻辑表在原始 SQL 中的位置，并将其改写为真实表的过程。表名称改写是一个典型的需要对 SQL 进行解析的场景。 从一个最简单的例子开始，若逻辑 SQL 为：
SELECT order_id FROM t_order WHERE order_id=1; 假设该 SQL 配置分片键 order_id，并且 order_id=1 的情况，将路由至分片表 1。那么改写之后的 SQL 应该为：
SELECT order_id FROM t_order_1 WHERE order_id=1; 在这种最简单的 SQL 场景中，是否将 SQL 解析为抽象语法树似乎无关紧要，只要通过字符串查找和替换就可以达到 SQL 改写的效果。 但是下面的场景，就无法仅仅通过字符串的查找替换来正确的改写 SQL 了：
SELECT order_id FROM t_order WHERE order_id=1 AND remarks=&amp;#39; t_order xxx&amp;#39;; 正确改写的 SQL 应该是：
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=&amp;#39; t_order xxx&amp;#39;; 而非：</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/encrypt/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.encrypt.api.config.EncryptRuleConfiguration
可配置属性：
   名称 数据类型 说明     tables (+) Collection&amp;lt;EncryptTableRuleConfiguration&amp;gt; 加密表规则配置   encryptors (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 加解密算法名称和配置    加密表规则配置 类名称：org.apache.shardingsphere.encrypt.api.config.rule.EncryptTableRuleConfiguration
可配置属性：
   名称 数据类型 说明     name String 表名称   columns (+) Collection&amp;lt;EncryptColumnRuleConfiguration&amp;gt; 加密列规则配置列表    加密列规则配置 类名称：org.apache.shardingsphere.encrypt.api.config.rule.EncryptColumnRuleConfiguration
可配置属性：
   名称 数据类型 说明     logicColumn String 逻辑列名称   cipherColumn String 密文列名称   encryptorName String 加密算法名称    加解密算法配置 类名称：org.</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/encrypt/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.cipher-column= # 加密列名称spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.assisted-query-column= # 查询列名称spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.plain-column= # 原文列名称spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.encryptor-name= # 加密算法名称# 加密算法配置spring.shardingsphere.rules.encrypt.encryptors.&amp;lt;encrypt-algorithm-name&amp;gt;.type= # 加密算法类型spring.shardingsphere.rules.encrypt.encryptors.&amp;lt;encrypt-algorithm-name&amp;gt;.props.xxx= # 加密算法属性配置算法类型的详情，请参见内置加密算法列表。</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/encrypt/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt-5.0.0.xsd
&amp;lt;encrypt:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   table (+) 标签 加密表配置    &amp;lt;encrypt:table /&amp;gt;
   名称 类型 说明     name 属性 加密表名称   column (+) 标签 加密列配置    &amp;lt;encrypt:column /&amp;gt;
   名称 类型 说明     logic-column 属性 加密列逻辑名称   cipher-column 属性 加密列名称   plain-column (?</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/encrypt/</guid>
      <description>配置项说明 dataSource: # 省略数据源配置 rules: - !ENCRYPT tables: &amp;lt;table-name&amp;gt; (+): # 加密表名称 columns: &amp;lt;column-name&amp;gt; (+): # 加密列名称 cipherColumn: # 密文列名称 encryptorName: # 加密算法名称 # 加密算法配置 encryptors: &amp;lt;encrypt-algorithm-name&amp;gt; (+): # 加解密算法名称 type: # 加解密算法类型 props: # 加解密算法属性配置 # ... props: # ... 算法类型的详情，请参见内置加密算法列表。</description>
    </item>
    
    <item>
      <title>规则配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/rule-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/rule-config/</guid>
      <description>规则配置   添加激活注册中心后，可以获取当前注册中心中所有数据源的相关配置，包括数据分片，读写分离、Properties 配置等。
  可以通过 YAML 格式对相关配置信息进行修改。
  点击 + 按钮可以添加新的数据源和分片规则。
  </description>
    </item>
    
    <item>
      <title>解析器</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/parser/</guid>
      <description>ShardingSphere使用不同解析器支持SQL多种方言。对于未实现解析器的特定SQL方言，默认采用SQL92标准进行解析。
特定SQL方言解析器  PostgreSQL解析器 MySQL解析器 Oracle解析器 SQLServer解析器  注：MySQL解析器支持的方言包括MySQL、H2和MariaDB。
默认SQL方言解析器 其他SQL方言，如SQLite、Sybase、DB2和Informix等，默认采用SQL92标准进行解析。
RDL(Rule definition Language)方言解析器 ShardingSphere独有的RDL方言解析器。该解析器主要解析ShardingSphere内部的RDL方言，即自定义的SQL。请查阅RDL了解详情。</description>
    </item>
    
    <item>
      <title>负载均衡算法</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/load-balance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/load-balance/</guid>
      <description>轮询算法 类型：ROUND_ROBIN
可配置属性：无
随机访问算法 类型：RANDOM
可配置属性：无</description>
    </item>
    
    <item>
      <title>配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/configuration/</guid>
      <description>分片规则 分片规则配置的总入口。包含数据源配置、表配置、绑定表配置以及读写分离配置等。
数据源配置 真实数据源列表。
表配置 逻辑表名称、数据节点与分表规则的配置。
数据节点配置 用于配置逻辑表与真实表的映射关系。可分为均匀分布和自定义分布两种形式。
 均匀分布  指数据表在每个数据源内呈现均匀分布的态势，例如：
db0├── t_order0 └── t_order1 db1├── t_order0 └── t_order1那么数据节点的配置如下：
db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1 自定义分布  指数据表呈现有特定规则的分布，例如：
db0├── t_order0 └── t_order1 db1├── t_order2├── t_order3└── t_order4那么数据节点的配置如下：
db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4分片策略配置 对于分片策略存有数据源分片策略和表分片策略两种维度。
 数据源分片策略  对应于 DatabaseShardingStrategy。用于配置数据被分配的目标数据源。
 表分片策略  对应于 TableShardingStrategy。用于配置数据被分配的目标表，该目标表存在与该数据的目标数据源内。故表分片策略是依赖与数据源分片策略的结果的。
两种策略的 API 完全相同。
自增主键生成策略 通过在客户端生成自增主键替换以数据库原生自增主键的方式，做到分布式主键无重复。</description>
    </item>
    
    <item>
      <title>Atomikos 事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/atomikos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/atomikos/</guid>
      <description>Apache ShardingSphere 默认的 XA 事务管理器为 Atomikos。
数据恢复 在项目的 logs 目录中会生成xa_tx.log, 这是 XA 崩溃恢复时所需的日志，请勿删除。
修改配置 可以通过在项目的 classpath 中添加 jta.properties 来定制化 Atomikos 配置项。
详情请参见Atomikos官方文档。</description>
    </item>
    
    <item>
      <title>RDL</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/rdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/use-norms/rdl/</guid>
      <description>什么是 RDL? RDL（Rule Definition Language）是ShardingSphere特有的内置SQL语言。用户可以使用RDL语言向SharidngSphere注入数据源资源、创建分片规则等，即向ShardingSphere注入数据库资源信息和分片规则信息。 RDL使得用户抛弃对传统Yaml或其他配置文件的依赖，像使用数据库一样，通过SQL进行资源信息的注入和规则的配置。
当前，RDL主要包括以下SQL内容：
 Create DATASOURCES，用于注入数据源信息。  // SQL CREATE DATASOURCES ( ds_key=host_name:host_port:db_name:user_name:pwd [, ds_key=host_name:host_port:db_name:user_name:pwd, ...] ) // Example CREATE datasources ( ds0=127.0.0.1:3306:demo_ds_2:root:pwd, ds1=127.0.0.1:3306:demo_ds_3:root:pwd)  CREATE SHARDINGRULE，用于配置分片规则。  // SQL CREATE SHARDINGRULE ( sharding_table_name=sharding_algorithm(algorithm_property[, algothrim_property]) [, sharding_table_name=sharding_algorithm_type(algorithm_property[, algothrim_property]), ...] ) sharding_algorithm_type: {MOD | HASH_MODE} mod_algorithm_properties: sharding_column,shards_amount mod_hash_algorithm_properties: sharding_column,shards_amount // Example CREATE shardingrules ( t_order=hash_mod(order_id, 4), t_item=mod(item_id, 2) ) RDL使用实战 前置工作  Start the service of MySQL instances Create MySQL databases (Viewed as the resources for ShardingProxy) Create a role or user with creating privileges for ShardingProxy Start the service of Zookeeper (For persisting configuration)  启动ShardingProxy  Add governance and authentication setting item to the server.</description>
    </item>
    
    <item>
      <title>SCTL</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/sctl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/usage/sctl/</guid>
      <description>SCTL (ShardingSphere Control Language) 为 ShardingSphere 特有的控制语句， 可以在运行时修改和查询 ShardingSphere-Proxy 的状态，目前支持的语法为：
   语句 说明     sctl:set transaction_type=XX 修改当前连接的事务类型, 支持LOCAL，XA，BASE。例：sctl:set transaction_type=XA   sctl:show transaction_type 查询当前连接的事务类型   sctl:show cached_connections 查询当前连接中缓存的物理数据库连接个数   sctl:explain SQL 查看逻辑 SQL 的执行计划，例：sctl:explain select * from t_order;   sctl:hint set PRIMARY_ONLY=true 针对当前连接，是否将数据库操作强制路由到主库   sctl:hint set DatabaseShardingValue=yy 针对当前连接，设置 hint 仅对数据库分片有效，并添加分片值，yy：数据库分片值   sctl:hint addDatabaseShardingValue xx=yy 针对当前连接，为表 xx 添加分片值 yy，xx：逻辑表名称，yy：数据库分片值   sctl:hint addTableShardingValue xx=yy 针对当前连接，为表 xx 添加分片值 yy，xx：逻辑表名称，yy：表分片值   sctl:hint clear 针对当前连接，清除 hint 所有设置   sctl:hint show status 针对当前连接，查询 hint 状态，primary_only:true/false，sharding_type:databases_only/databases_tables   sctl:hint show table status 针对当前连接，查询逻辑表的 hint 分片值    ShardingSphere-Proxy 默认不支持 hint，如需支持，请在 conf/server.</description>
    </item>
    
    <item>
      <title>SQL改写测试引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/rewrite-test-engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/rewrite-test-engine/</guid>
      <description>目标 面向逻辑库与逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL。 它包括正确性改写和优化改写两部分，所以 SQL 改写的测试都是基于这些改写方向进行校验的。
测试 SQL 改写测试用例位于 sharding-core/sharding-core-rewrite 下的 test 中。SQL 改写的测试主要依赖如下几个部分：
 测试引擎 环境配置 验证数据  测试引擎是 SQL 改写测试的入口，跟其他引擎一样，通过 Junit 的 Parameterized 逐条读取 test\resources 目录中测试类型下对应的 xml 文件，然后按读取顺序一一进行验证。
环境配置存放在 test\resources\yaml 路径中测试类型下对应的 yaml 中。配置了dataSources，shardingRule，encryptRule 等信息，例子如下：
dataSources: db: !!com.zaxxer.hikari.HikariDataSource driverClassName: org.h2.Driver jdbcUrl: jdbc:h2:mem:db;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false;MODE=MYSQL username: sa password: ## sharding 规则 shardingRule: tables: t_account: actualDataNodes: db.t_account_${0..1} tableStrategy: inline: shardingColumn: account_id algorithmExpression: t_account_${account_id % 2} keyGenerateStrategy: type: TEST column: account_id t_account_detail: actualDataNodes: db.t_account_detail_${0..1} tableStrategy: inline: shardingColumn: order_id algorithmExpression: t_account_detail_${account_id % 2} bindingTables: - t_account, t_account_detail 验证数据存放在 test\resources 路径中测试类型下对应的 xml 文件中。验证数据中， yaml-rule 指定了环境以及 rule 的配置文件，input 指定了待测试的 SQL 以及参数，output 指定了期待的 SQL 以及参数。 其中 db-type 决定了 SQL 解析的类型，默认为 SQL92, 例如：</description>
    </item>
    
    <item>
      <title>YAML 语法说明</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/yaml-syntax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-proxy/configuration/yaml-syntax/</guid>
      <description>!! 表示实例化该类
! 表示自定义别名
- 表示可以包含一个或多个
[] 表示数组，可以与减号相互替换使用</description>
    </item>
    
    <item>
      <title>使用 Spring 命名空间</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/governance/spring-namespace/</guid>
      <description>引入Maven依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-governance-spring-namespace&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 ZooKeeper 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-zookeeper-curator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 Etcd 时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-governance-repository-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:governance=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/governance&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/governance http://shardingsphere.apache.org/schema/shardingsphere/governance/governance.xsd&amp;#34;&amp;gt; &amp;lt;util:properties id=&amp;#34;instance-properties&amp;#34;&amp;gt; &amp;lt;prop key=&amp;#34;max-retries&amp;#34;&amp;gt;3&amp;lt;/prop&amp;gt; &amp;lt;prop key=&amp;#34;operation-timeout-milliseconds&amp;#34;&amp;gt;3000&amp;lt;/prop&amp;gt; &amp;lt;/util:properties&amp;gt; &amp;lt;governance:reg-center id=&amp;#34;regCenter&amp;#34; type=&amp;#34;Zookeeper&amp;#34; server-lists=&amp;#34;localhost:2181&amp;#34; /&amp;gt; &amp;lt;governance:config-center id=&amp;#34;configCenter&amp;#34; type=&amp;#34;ZooKeeper&amp;#34; server-lists=&amp;#34;localhost:2182&amp;#34; /&amp;gt; &amp;lt;governance:data-source id=&amp;#34;shardingDatabasesTablesDataSource&amp;#34; data-source-names=&amp;#34;demo_ds_0, demo_ds_1&amp;#34; reg-center-ref=&amp;#34;regCenter&amp;#34; config-center-ref=&amp;#34;configCenter&amp;#34; rule-refs=&amp;#34;shardingRule&amp;#34; overwrite=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;governance:data-source id=&amp;#34;replicaQueryDataSource&amp;#34; data-source-names=&amp;#34;demo_primary_ds, demo_replica_ds_0, demo_replica_ds_1&amp;#34; reg-center-ref=&amp;#34;regCenter&amp;#34; config-center-ref=&amp;#34;configCenter&amp;#34; rule-refs=&amp;#34;replicaQueryRule&amp;#34; overwrite=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;governance:data-source id=&amp;#34;encryptDataSource&amp;#34; data-source-names=&amp;#34;demo_ds&amp;#34; reg-center-ref=&amp;#34;regCenter&amp;#34; config-center-ref=&amp;#34;configCenter&amp;#34; rule-refs=&amp;#34;encryptRule&amp;#34; overwrite=&amp;#34;true&amp;#34; &amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;#34;query-with-cipher-column&amp;#34;&amp;gt;true&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/governance:data-source&amp;gt; &amp;lt;/beans&amp;gt; 在 Spring 中使用 GovernanceShardingSphereDataSource 直接通过注入的方式即可使用 GovernanceShardingSphereDataSource；或者将 GovernanceShardingSphereDataSource 配置在JPA， MyBatis 等 ORM 框架中配合使用。</description>
    </item>
    
    <item>
      <title>使用 Spring 命名空间</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-namespace/</guid>
      <description>引入Maven依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-spring-namespace&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 规则配置 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:sharding=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/sharding&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/sharding http://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding.xsd &amp;#34;&amp;gt; &amp;lt;!-- 配置真实数据源 --&amp;gt; &amp;lt;!-- 配置第 1 个数据源 --&amp;gt; &amp;lt;bean id=&amp;#34;ds0&amp;#34; class=&amp;#34;org.apache.commons.dbcp2.BasicDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/ds0&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!-- 配置第 2 个数据源 --&amp;gt; &amp;lt;bean id=&amp;#34;ds1&amp;#34; class=&amp;#34;org.apache.commons.dbcp2.BasicDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/ds1&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>加密算法</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/encrypt/</guid>
      <description>MD5 加密算法 类型：MD5
可配置属性：无
AES 加密算法 类型：AES
可配置属性：
   名称 数据类型 说明     aes-key-value String AES 使用的 KEY    RC4 加密算法 类型：RC4
可配置属性：
   名称 数据类型 说明     rc4-key-value String RC4 使用的 KEY    </description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/shadow/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.shadow.api.config.ShadowRuleConfiguration
可配置属性：
   名称 数据类型 说明     column String SQL 中的影子字段名，该值为 true 的 SQL 会路由到影子库执行   sourceDataSourceNames List&amp;lt;String&amp;gt; 生产数据库名称   shadowDataSourceNames List&amp;lt;String&amp;gt; 影子数据库名称，与上面一一对应    </description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置spring.shardingsphere.rules.shadow.column= # 影子字段名称名称spring.shardingsphere.rules.shadow.shadow-mappings.&amp;lt;product-data-source-name&amp;gt;= # 影子数据库名称</description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/shadow/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/shadow/shadow-5.0.0.xsd
&amp;lt;shadow:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   column 属性 影子字段名称   mappings(?) 标签 生产数据库与影子数据库的映射关系配置    &amp;lt;shadow:mapping /&amp;gt;
   名称 类型 说明     product-data-source-name 属性 生产数据库名称   shadow-data-source-name 属性 影子数据库名称    </description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/shadow/</guid>
      <description>配置项说明 dataSources: #省略数据源配置 rules: - !SHADOW column: # 影子字段名 sourceDataSourceNames: # 影子前数据库名 # ... shadowDataSourceNames: # 对应的影子库名 # ...  props: # ... </description>
    </item>
    
    <item>
      <title>执行引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/execute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/execute/</guid>
      <description>ShardingSphere 采用一套自动化的执行引擎，负责将路由和改写完成之后的真实 SQL 安全且高效发送到底层数据源执行。 它不是简单地将 SQL 通过 JDBC 直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题。 执行引擎的目标是自动化的平衡资源控制与执行效率。
连接模式 从资源控制的角度看，业务方访问数据库的连接数量应当有所限制。 它能够有效地防止某一业务操作过多的占用资源，从而将数据库连接的资源耗尽，以致于影响其他业务的正常访问。 特别是在一个数据库实例中存在较多分表的情况下，一条不包含分片键的逻辑 SQL 将产生落在同库不同表的大量真实 SQL ，如果每条真实SQL都占用一个独立的连接，那么一次查询无疑将会占用过多的资源。
从执行效率的角度看，为每个分片查询维持一个独立的数据库连接，可以更加有效的利用多线程来提升执行效率。 为每个数据库连接开启独立的线程，可以将 I/O 所产生的消耗并行处理。为每个分片维持一个独立的数据库连接，还能够避免过早的将查询结果数据加载至内存。 独立的数据库连接，能够持有查询结果集游标位置的引用，在需要获取相应数据时移动游标即可。
以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有一个独立数据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。
一方面是对数据库连接资源的控制保护，一方面是采用更优的归并模式达到对中间件内存资源的节省，如何处理好两者之间的关系，是 ShardingSphere 执行引擎需要解决的问题。 具体来说，如果一条 SQL 在经过 ShardingSphere 的分片后，需要操作某数据库实例下的 200 张表。 那么，是选择创建 200 个连接并行执行，还是选择创建一个连接串行执行呢？效率与资源控制又应该如何抉择呢？
针对上述场景，ShardingSphere 提供了一种解决思路。 它提出了连接模式（Connection Mode）的概念，将其划分为内存限制模式（MEMORY_STRICTLY）和连接限制模式（CONNECTION_STRICTLY）这两种类型。
内存限制模式 使用此模式的前提是，ShardingSphere 对一次操作所耗费的数据库连接数量不做限制。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，则对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化。 并且在 SQL 满足条件情况下，优先选择流式归并，以防止出现内存溢出或避免频繁垃圾回收情况。
连接限制模式 使用此模式的前提是，ShardingSphere 严格控制对一次操作所耗费的数据库连接数量。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，那么只会创建唯一的数据库连接，并对其 200 张表串行处理。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。 这样即可以防止对一次请求对数据库连接占用过多所带来的问题。该模式始终选择内存归并。
内存限制模式适用于 OLAP 操作，可以通过放宽对数据库连接的限制提升系统吞吐量； 连接限制模式适用于 OLTP 操作，OLTP 通常带有分片键，会路由到单一的分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/sharding/</guid>
      <description>ShardingAlgorithm    SPI 名称 详细说明     ShardingAlgorithm 分片算法       已知实现类 详细说明     InlineShardingAlgorithm 基于行表达式的分片算法   ModShardingAlgorithm 基于取模的分片算法   HashModShardingAlgorithm 基于哈希取模的分片算法   FixedIntervalShardingAlgorithm 基于固定时间范围的分片算法   MutableIntervalShardingAlgorithm 基于可变时间范围的分片算法   VolumeBasedRangeShardingAlgorithm 基于分片容量的范围分片算法   BoundaryBasedRangeShardingAlgorithm 基于分片边界的范围分片算法    KeyGenerateAlgorithm    SPI 名称 详细说明     KeyGenerateAlgorithm 分布式主键生成算法       已知实现类 详细说明     SnowflakeKeyGenerateAlgorithm 基于雪花算法的分布式主键生成算法   UUIDKeyGenerateAlgorithm 基于UUID的分布式主键生成算法    TimeService    SPI 名称 详细说明     TimeService 获取当前时间进行路由       已知实现类 详细说明     DefaultTimeService 从应用系统时间中获取当前时间进行路由   DatabaseTimeServiceDelegate 从数据库中获取当前时间进行路由    DatabaseSQLEntry    SPI 名称 详细说明     DatabaseSQLEntry 获取当前时间的数据库方言       已知实现类 详细说明     MySQLDatabaseSQLEntry 从 MySQL 获取当前时间的数据库方言   PostgreSQLDatabaseSQLEntry 从 PostgreSQL 获取当前时间的数据库方言   OracleDatabaseSQLEntry 从 Oracle 获取当前时间的数据库方言   SQLServerDatabaseSQLEntry 从 SQLServer 获取当前时间的数据库方言    </description>
    </item>
    
    <item>
      <title>第三方组件依赖</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/dependency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/governance/management/dependency/</guid>
      <description>Apache ShardingSphere 在数据库治理模块使用 SPI 方式载入数据到配置中心和注册中心，进行实例熔断和数据库禁用。 目前，Apache ShardingSphere 内部支持 ZooKeeper，Etcd，Apollo 和 Nacos 等常用的配置中心/注册中心。 此外，开发者可以使用其他第三方组件，并通过 SPI 的方式注入到 Apache ShardingSphere，从而使用该配置中心和注册中心，实现数据库治理功能。
    实现驱动 版本 配置中心 注册中心     Zookeeper Apache Curator 3.6.x 支持 支持   Etcd jetcd v3 支持 支持   Apollo Apollo Client 1.5.0 支持 不支持   Nacos Nacos Client 1.0.0 支持 不支持    </description>
    </item>
    
    <item>
      <title>行表达式</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/inline-expression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/inline-expression/</guid>
      <description>实现动机 配置的简化与一体化是行表达式所希望解决的两个主要问题。
在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。通过行表达式可以有效地简化数据节点配置工作量。
对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
语法说明 行表达式的使用非常直观，只需要在配置中使用 ${ expression } 或 $-&amp;gt;{ expression } 标识行表达式即可。 目前支持数据节点和分片算法这两个部分的配置。行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。例如：
${begin..end} 表示范围区间
${[unit1, unit2, unit_x]} 表示枚举值
行表达式中如果出现连续多个 ${ expression } 或 $-&amp;gt;{ expression } 表达式，整个表达式最终的结果将会根据每个子表达式的结果进行笛卡尔组合。
例如，以下行表达式：
${[&amp;#39;online&amp;#39;, &amp;#39;offline&amp;#39;]}_table${1..3} 最终会解析为：
online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3配置数据节点 对于均匀分布的数据节点，如果数据结构如下：
db0├── t_order0 └── t_order1 db1├── t_order0 └── t_order1用行表达式可以简化为：
db${0..1}.t_order${0..1}或者
db$-&amp;gt;{0..1}.t_order$-&amp;gt;{0..1}对于自定义的数据节点，如果数据结构如下：
db0├── t_order0 └── t_order1 db1├── t_order2├── t_order3└── t_order4用行表达式可以简化为：</description>
    </item>
    
    <item>
      <title>运行状态</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/runtime-status/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-ui/usage/runtime-status/</guid>
      <description>运行状态   添加激活注册中心后，可以查看当前注册中心所有运行实例信息。
  可以通过操作按钮对运行实例进行熔断与恢复操作。
  可以查看所有从库信息，并进行从库禁用与恢复操作。
  </description>
    </item>
    
    <item>
      <title>Seata 事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/transaction/seata/</guid>
      <description>启动 Seata 服务 按照 seata-work-shop中的步骤，下载并启动 Seata 服务器。
创建日志表 在每一个分片数据库实例中执创建 undo_log表（以 MySQL 为例）。
CREATE TABLE IF NOT EXISTS `undo_log` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &amp;#39;increment id&amp;#39;, `branch_id` BIGINT(20) NOT NULL COMMENT &amp;#39;branch transaction id&amp;#39;, `xid` VARCHAR(100) NOT NULL COMMENT &amp;#39;global transaction id&amp;#39;, `context` VARCHAR(128) NOT NULL COMMENT &amp;#39;undo_log context,such as serialization&amp;#39;, `rollback_info` LONGBLOB NOT NULL COMMENT &amp;#39;rollback info&amp;#39;, `log_status` INT(11) NOT NULL COMMENT &amp;#39;0:normal status,1:defense status&amp;#39;, `log_created` DATETIME NOT NULL COMMENT &amp;#39;create datetime&amp;#39;, `log_modified` DATETIME NOT NULL COMMENT &amp;#39;modify datetime&amp;#39;, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8 COMMENT =&amp;#39;AT transaction mode undo table&amp;#39;; 修改配置 在 classpath 中增加 seata.</description>
    </item>
    
    <item>
      <title>分布式主键</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/key-generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/key-generator/</guid>
      <description>实现动机 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。
目前有许多第三方解决方案可以完美解决这个问题，如 UUID 等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求， Apache ShardingSphere 不仅提供了内置的分布式主键生成器，例如 UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。
内置的主键生成器 UUID 采用 UUID.randomUUID() 的方式产生分布式主键。
SNOWFLAKE 在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法（snowflake）生成 64bit 的长整型数据。
雪花算法是由 Twitter 公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。
实现原理 在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如 MySQL 的 Innodb 存储引擎的主键。
使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。
 符号位（1bit）  预留的符号位，恒为零。
 时间戳位（41bit）  41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：
Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L); 结果约等于 69.</description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/java-api/governance/</guid>
      <description>配置项说明 治理 配置入口
类名称：org.apache.shardingsphere.governance.repository.api.config.GovernanceConfiguration
可配置属性：
   名称 数据类型 说明     name String 注册中心实例名称   registryCenterConfiguration GovernanceCenterConfiguration 注册中心实例的配置   additionalConfigCenterConfiguration GovernanceCenterConfiguration 可选的配置中心实例配置   overwrite boolean 本地配置是否覆盖配置中心配置，如果可覆盖，每次启动都以本地配置为准    注册中心的类型可以为Zookeeper或etcd。 配置中心的类型可以为Zookeeper或etcd、Apollo、Nacos。
治理实例配置
类名称：org.apache.shardingsphere.governance.repository.api.config.GovernanceCenterConfiguration
可配置属性：
   名称 数据类型 说明     type String 治理实例类型，如：Zookeeper, etcd, Apollo, Nacos   serverLists String 治理服务列表，包括 IP 地址和端口号，多个地址用逗号分隔，如: host1:2181,host2:2181   props Properties 配置本实例需要的其他参数，例如 ZooKeeper 的连接参数等    ZooKeeper 属性配置</description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/governance/</guid>
      <description>配置项说明 治理 spring.shardingsphere.governance.name= # 治理名称spring.shardingsphere.governance.registry-center.type= # 治理持久化类型。如：Zookeeper, etcd, Apollo, Nacosspring.shardingsphere.governance.registry-center.server-lists= # 治理服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181spring.shardingsphere.governance.registry-center.props= # 其它配置spring.shardingsphere.governance.additional-config-center.type= # 可选的配置中心类型。如：Zookeeper, etcd, Apollo, Nacosspring.shardingsphere.governance.additional-config-center.server-lists= # 可选的配置中心服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181spring.shardingsphere.governance.additional-config-center.props= # 可选的配置中心其它配置spring.shardingsphere.governance.overwrite= # 本地配置是否覆盖配置中心配置。如果可覆盖，每次启动都以本地配置为准.</description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/spring-namespace/governance/</guid>
      <description>配置项说明 治理 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:governance=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/governance&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/governance http://shardingsphere.apache.org/schema/shardingsphere/governance/governance.xsd &amp;#34;&amp;gt; &amp;lt;governance:reg-center id=&amp;#34;regCenter&amp;#34; type=&amp;#34;ZooKeeper&amp;#34; server-lists=&amp;#34;localhost:2181&amp;#34; /&amp;gt; &amp;lt;governance:config-center id=&amp;#34;configCenter&amp;#34; type=&amp;#34;ZooKeeper&amp;#34; server-lists=&amp;#34;localhost:2182&amp;#34; /&amp;gt; &amp;lt;governance:data-source id=&amp;#34;shardingDatabasesTablesDataSource&amp;#34; data-source-names=&amp;#34;demo_ds_0, demo_ds_1&amp;#34; reg-center-ref=&amp;#34;regCenter&amp;#34; config-center-ref=&amp;#34;configCenter&amp;#34; rule-refs=&amp;#34;shardingRule&amp;#34; overwrite=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 命名空间: http://shardingsphere.apache.org/schema/shardingsphere/governance/governance-5.0.0.xsd
&amp;lt;governance:reg-center /&amp;gt;
   名称 类型 说明     id 属性 注册中心实例名称   type 属性 注册中心类型。如：ZooKeeper, etcd   server-lists 属性 注册中心服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181   props (?) 属性 配置本实例需要的其他参数，例如 ZooKeeper 的连接参数等    &amp;lt;governance:config-center /&amp;gt;</description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/yaml/governance/</guid>
      <description>配置项说明 治理 governance: name: # 治理名称 registryCenter: # 配置中心 type: # 治理持久化类型。如：Zookeeper, etcd serverLists: # 治理服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181 additionalConfigCenter: type: # 治理持久化类型。如：Zookeeper, etcd, Nacos, Apollo serverLists: # 治理服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181 overwrite: # 本地配置是否覆盖配置中心配置。如果可覆盖，每次启动都以本地配置为准 </description>
    </item>
    
    <item>
      <title>强制路由</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/hint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/usage/sharding/hint/</guid>
      <description>简介 Apache ShardingSphere 使用 ThreadLocal 管理分片键值进行强制路由。 可以通过编程的方式向 HintManager 中添加分片值，该分片值仅在当前线程内生效。
Hint 的主要使用场景：
 分片字段不存在 SQL 和数据库表结构中，而存在于外部业务逻辑。 强制在主库进行某些数据操作。  使用方法 使用 Hint 分片 规则配置 Hint 分片算法需要用户实现 org.apache.shardingsphere.sharding.api.sharding.hint.HintShardingAlgorithm 接口。 Apache ShardingSphere 在进行路由时，将会从 HintManager 中获取分片值进行路由操作。
参考配置如下：
rules: - !SHARDING tables: t_order: actualDataNodes: demo_ds_${0..1}.t_order_${0..1} databaseStrategy: hint: algorithmClassName: xxx.xxx.xxx.HintXXXAlgorithm tableStrategy: hint: algorithmClassName: xxx.xxx.xxx.HintXXXAlgorithm defaultTableStrategy: none: defaultKeyGenerateStrategy: type: SNOWFLAKE column: order_id props: sql-show: true 获取 HintManager HintManager hintManager = HintManager.getInstance(); 添加分片键值  使用 hintManager.addDatabaseShardingValue 来添加数据源分片键值。 使用 hintManager.addTableShardingValue 来添加表分片键值。   分库不分表情况下，强制路由至某一个分库时，可使用 hintManager.</description>
    </item>
    
    <item>
      <title>归并引擎</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/merge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/principle/merge/</guid>
      <description>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。
ShardingSphere 支持的结果归并从功能上分为遍历、排序、分组、分页和聚合 5 种类型，它们是组合而非互斥的关系。 从结构划分，可分为流式归并、内存归并和装饰者归并。流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。
由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此，在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。
流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。
内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。
装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这 2 种类型。
遍历归并 它是最为简单的归并方式。 只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。
排序归并 由于在 SQL 中存在 ORDER BY 语句，因此每个数据结果集自身是有序的，因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，归并排序是最适合此场景的排序算法。
ShardingSphere 在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现 Java 的 Comparable 接口完成），并将其放入优先级队列。 每次获取下一条数据时，只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。
通过一个例子来说明 ShardingSphere 的排序归并，下图是一个通过分数进行排序的示例图。 图中展示了 3 张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，但是 3 个数据结果集之间是无序的。 将 3 个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0 的第一个数据值最大，t_score_2 的第一个数据值次之，t_score_1 的第一个数据值最小，因此优先级队列根据 t_score_0，t_score_2 和 t_score_1 的方式排序队列。
下图则展现了进行 next 调用的时候，排序归并是如何进行的。 通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_0 将会被弹出队列，并且将当前游标指向的数据值（也就是 100）返回至查询客户端，并且将游标下移一位之后，重新放入优先级队列。 而优先级队列也会根据 t_score_0 的当前数据结果集指向游标的数据值（这里是 90）进行排序，根据当前数值，t_score_0 排列在队列的最后一位。 之前队列中排名第二的 t_score_2 的数据结果集则自动排在了队列首位。
在进行第二次 next 时，只需要将目前排列在队列首位的 t_score_2 弹出队列，并且将其数据结果集游标指向的值返回至客户端，并下移游标，继续加入队列排队，以此类推。 当一个结果集中已经没有数据了，则无需再次加入队列。</description>
    </item>
    
    <item>
      <title>性能测试</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/performance-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/test-engine/performance-test/</guid>
      <description>目标 对ShardingSphere-JDBC，ShardingSphere-Proxy及MySQL进行性能对比。从业务角度考虑，在基本应用场景（单路由，主从+加密+分库分表，全路由）下，INSERT+UPDATE+DELETE通常用作一个完整的关联操作，用于性能评估，而SELECT关注分片优化可用作性能评估的另一个操作；而主从模式下，可将INSERT+SELECT+DELETE作为一组评估性能的关联操作。 为了更好的观察效果，设计在一定数据量的基础上，使用jmeter 20并发线程持续压测半小时，进行增删改查性能测试，且每台机器部署一个MySQL实例，而对比MySQL场景为单机单实例部署。
测试场景 单路由 在1000数据量的基础上分库分表，根据id分为4个库，部署在同一台机器上，根据k分为1024个表，查询操作路由到单库单表； 作为对比，MySQL运行在1000数据量的基础上，使用INSERT+UPDATE+DELETE和单路由查询语句。
主从 基本主从场景，设置一主库一从库，部署在两台不同的机器上，在10000数据量的基础上，观察读写性能； 作为对比，MySQL运行在10000数据量的基础上，使用INSERT+SELECT+DELETE语句。
主从+加密+分库分表 在1000数据量的基础上，根据id分为4个库，部署在四台不同的机器上，根据k分为1024个表，c使用aes加密，pad使用md5加密，查询操作路由到单库单表； 作为对比，MySQL运行在1000数据量的基础上，使用INSERT+UPDATE+DELETE和单路由查询语句。
全路由 在1000数据量的基础上，分库分表，根据id分为4个库，部署在四台不同的机器上，根据k分为1个表，查询操作使用全路由。 作为对比，MySQL运行在1000数据量的基础上，使用INSERT+UPDATE+DELETE和全路由查询语句。
测试环境搭建 数据库表结构 此处表结构参考sysbench的sbtest表
CREATE TABLE `tbl` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `k` int(11) NOT NULL DEFAULT 0, `c` char(120) NOT NULL DEFAULT &amp;#39;&amp;#39;, `pad` char(60) NOT NULL DEFAULT &amp;#39;&amp;#39;, PRIMARY KEY (`id`) ); 测试场景配置 ShardingSphere-JDBC使用与ShardingSphere-Proxy一致的配置，MySQL直连一个库用作性能对比，下面为四个场景的具体配置：
单路由配置 schemaName: sharding_db dataSources: ds_0: url: jdbc:mysql://***.***.***.***:****/ds?serverTimezone=UTC&amp;amp;useSSL=false username: test password: connectionTimeoutMilliseconds: 30000 idleTimeoutMilliseconds: 60000 maxLifetimeMilliseconds: 1800000 maxPoolSize: 200 ds_1: url: jdbc:mysql://***.</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/replica-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/replica-query/</guid>
      <description>ReplicaLoadBalanceAlgorithm    SPI 名称 详细说明     ReplicaLoadBalanceAlgorithm 读库负载均衡算法       已知实现类 详细说明     RoundRobinReplicaLoadBalanceAlgorithm 基于轮询的读库负载均衡算法   RandomReplicaLoadBalanceAlgorithm 基于随机的读库负载均衡算法    </description>
    </item>
    
    <item>
      <title>属性配置</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/props/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/user-manual/shardingsphere-jdbc/configuration/props/</guid>
      <description>简介 Apache ShardingSphere 提供属性配置的方式配置系统级配置。
配置项说明    名称 数据类型 说明 默认值     sql-show (?) boolean 是否在日志中打印 SQL。 打印 SQL 可以帮助开发者快速定位系统问题。日志内容包含：逻辑 SQL，真实 SQL 和 SQL 解析结果。
如果开启配置，日志将使用 Topic ShardingSphere-SQL，日志级别是 INFO。 false   sql.simple (?) boolean 是否在日志中打印简单风格的 SQL。 false   executor-size (?) int 用于设置任务处理线程池的大小。每个 ShardingSphereDataSource 使用一个独立的线程池，同一个 JVM 的不同数据源不共享线程池。 infinite   max-connections-size-per-query (?) int 一次查询请求在每个数据库实例中所能使用的最大连接数。 1   check-table-metadata-enabled (?) boolean 是否在程序启动和更新时检查分片元数据的结构一致性。 false   query-with-cipher-column (?</description>
    </item>
    
    <item>
      <title>强制分片路由</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/hint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/features/sharding/concept/hint/</guid>
      <description>实现动机 通过解析 SQL 语句提取分片键列与值并进行分片是 Apache ShardingSphere 对 SQL 零侵入的实现方式。若 SQL 语句中没有分片条件，则无法进行分片，需要全路由。
在一些应用场景中，分片条件并不存在于 SQL，而存在于外部业务逻辑。因此需要提供一种通过外部指定分片结果的方式，在 Apache ShardingSphere 中叫做 Hint。
实现机制 Apache ShardingSphere 使用 ThreadLocal 管理分片键值。可以通过编程的方式向 HintManager 中添加分片条件，该分片条件仅在当前线程内生效。
除了通过编程的方式使用强制分片路由，Apache ShardingSphere 还计划通过 SQL 中的特殊注释的方式引用 Hint，使开发者可以采用更加透明的方式使用该功能。
指定了强制分片路由的 SQL 将会无视原有的分片逻辑，直接路由至指定的真实数据节点。</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/data-encryption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/data-encryption/</guid>
      <description>EncryptAlgorithm    SPI 名称 详细说明     EncryptAlgorithm 数据加密算法       已知实现类 详细说明     MD5EncryptAlgorithm 基于 MD5 的数据加密算法   AESEncryptAlgorithm 基于 AES 的数据加密算法   RC4EncryptAlgorithm 基于 RC4 的数据加密算法    </description>
    </item>
    
    <item>
      <title>分布式事务</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/transaction/</guid>
      <description>ShardingTransactionManager    SPI 名称 详细说明     ShardingTransactionManager 分布式事务管理器       已知实现类 详细说明     XAShardingTransactionManager 基于 XA 的分布式事务管理器   SeataATShardingTransactionManager 基于 Seata 的分布式事务管理器    XATransactionManager    SPI 名称 详细说明     XATransactionManager XA分布式事务管理器       已知实现类 详细说明     AtomikosTransactionManager 基于 Atomikos 的 XA 分布式事务管理器   NarayanaXATransactionManager 基于 Narayana 的 XA 分布式事务管理器   BitronixXATransactionManager 基于 Bitronix 的 XA 分布式事务管理器    XADataSourceDefinition    SPI 名称 详细说明     XADataSourceDefinition 非 XA 数据源自动转化为 XA 数据源       已知实现类 详细说明     MySQLXADataSourceDefinition 非 XA 的 MySQL 数据源自动转化为 XA 的 MySQL 数据源   MariaDBXADataSourceDefinition 非 XA 的 MariaDB 数据源自动转化为 XA 的 MariaDB 数据源   PostgreSQLXADataSourceDefinition 非 XA 的 PostgreSQL 数据源自动转化为 XA 的 PostgreSQL 数据源   OracleXADataSourceDefinition 非 XA 的 Oracle 数据源自动转化为 XA 的 Oracle 数据源   SQLServerXADataSourceDefinition 非 XA 的 SQLServer 数据源自动转化为 XA 的 SQLServer 数据源   H2XADataSourceDefinition 非 XA 的 H2 数据源自动转化为 XA 的 H2 数据源    DataSourcePropertyProvider    SPI 名称 详细说明     DataSourcePropertyProvider 用于获取数据源连接池的标准属性       已知实现类 详细说明     HikariCPPropertyProvider 用于获取 HikariCP 连接池的标准属性    </description>
    </item>
    
    <item>
      <title>分布式治理</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/governance/</guid>
      <description>ConfigurationRepository    SPI 名称 详细说明     ConfigurationRepository 配置中心       已知实现类 详细说明     CuratorZookeeperRepository 基于 ZooKeeper 的配置中心   EtcdRepository 基于 etcd 的配置中心   NacosRepository 基于 Nacos 的配置中心   ApolloRepository 基于 Apollo 的配置中心    RegistryRepository    SPI 名称 详细说明     RegistryRepository 注册中心       已知实现类 详细说明     CuratorZookeeperRepository 基于 ZooKeeper 的注册中心   EtcdRepository 基于 etcd 的注册中心    RootInvokeHook    SPI 名称 详细说明     RootInvokeHook 请求调用入口追踪       已知实现类 详细说明     OpenTracingRootInvokeHook 基于 OpenTracing 协议的请求调用入口追踪    </description>
    </item>
    
    <item>
      <title>弹性伸缩</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/scaling/</guid>
      <description>ScalingEntry    SPI 名称 详细说明     ScalingEntry 弹性伸缩入口       已知实现类 详细说明     MySQLScalingEntry 基于 MySQL 的弹性伸缩入口   PostgreSQLScalingEntry 基于 PostgreSQL 的弹性伸缩入口    </description>
    </item>
    
    <item>
      <title>Proxy</title>
      <link>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.0.0-alpha/cn/dev-manual/proxy/</guid>
      <description>DatabaseProtocolFrontendEngine    SPI 名称 详细说明     DatabaseProtocolFrontendEngine 用于ShardingSphere-Proxy解析与适配访问数据库的协议       已知实现类 详细说明     MySQLFrontendEngine 基于 MySQL 的数据库协议实现   PostgreSQLFrontendEngine 基于 PostgreSQL 的SQL 解析器实现    JDBCDriverURLRecognizer    SPI 名称 详细说明     JDBCDriverURLRecognizer 使用 JDBC 驱动执行 SQL       已知实现类 详细说明     MySQLRecognizer 使用 MySQL 的 JDBC 驱动执行 SQL   PostgreSQLRecognizer 使用 PostgreSQL 的 JDBC 驱动执行 SQL   OracleRecognizer 使用 Oracle 的 JDBC 驱动执行 SQL   SQLServerRecognizer 使用 SQLServer 的 JDBC 驱动执行 SQL   H2Recognizer 使用 H2 的 JDBC 驱动执行 SQL    </description>
    </item>
    
  </channel>
</rss>