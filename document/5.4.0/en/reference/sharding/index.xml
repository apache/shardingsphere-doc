<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sharding on ShardingSphere</title>
    <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/</link>
    <description>Recent content in Sharding on ShardingSphere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/document/current/en/reference/sharding/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Parse Engine</title>
      <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/parse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/current/en/reference/sharding/parse/</guid>
      <description>SQL is relatively simple compared with other programming languages, but it&amp;rsquo;s still a complete programming language. Therefore, there&amp;rsquo;s no essential difference between parsing SQL syntax and parsing other languages (such as Java, C and Go, etc.).
Abstract Syntax Tree The parsing process is divided into lexical parsing and syntactic parsing. The lexical parser is used to split SQL into indivisible atomic symbols called Tokens.
Tokens are classified into keywords, expressions, literals, and operators based on the dictionaries provided by different database dialects.</description>
    </item>
    
    <item>
      <title>Route Engine</title>
      <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/route/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/current/en/reference/sharding/route/</guid>
      <description>Sharding strategies for databases and tables are matched based on the parsing context, and routing paths are generated. SQL with shard keys can be divided into the single-shard router (the shard key operator is equal), multi-shard router (the shard key operator is IN), and range router (the shard key operator is BETWEEN). SQL that does not carry shard keys adopts broadcast routing.
Sharding strategies can usually be configured either by the built-in database or by the user.</description>
    </item>
    
    <item>
      <title>Rewrite Engine</title>
      <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/rewrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/current/en/reference/sharding/rewrite/</guid>
      <description>SQL written by engineers for logical databases and tables cannot be directly executed in real databases.
SQL rewriting is used to rewrite logical SQL into SQL that can be executed correctly in real databases. It includes rewriting for correctness and rewriting for optimization.
Rewriting for Correctness In a scenario with table shards, you need to rewrite the logical table name in the table shards configuration to the real table name obtained after routing.</description>
    </item>
    
    <item>
      <title>Execute Engine</title>
      <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/execute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/current/en/reference/sharding/execute/</guid>
      <description>ShardingSphere uses an automated execution engine to safely and efficiently send the real SQL, which has been routed and rewritten, to the underlying data source for execution.
It does not simply send SQL directly to the data source for execution via JDBC, nor are execution requests placed directly into a thread pool for concurrent execution.
It focuses more on the creation of a balanced data source connection, the consumption generated by the memory usage, and the maximum utilization of the concurrency.</description>
    </item>
    
    <item>
      <title>Merger Engine</title>
      <link>https://shardingsphere.apache.org/document/current/en/reference/sharding/merge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/current/en/reference/sharding/merge/</guid>
      <description>Result merger refers to merging multi-data result sets acquired from all the data nodes as one result set and returning it to the requesting client correctly.
The result merger supported by ShardingSphere can be divided into five functional types: traversal, order-by, group-by, pagination and aggregation, which are combined rather than mutually exclusive. From the perspective of structure, it can be divided into stream merger, memory merger and decorator merger, among which stream merger and memory merger are mutually exclusive, and decorator merger can be further processed based on stream merger and memory merger.</description>
    </item>
    
  </channel>
</rss>