<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Use Norms on ShardingSphere</title>
    <link>https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/</link>
    <description>Recent content in Use Norms on ShardingSphere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SQL</title>
      <link>https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/sql/</guid>
      <description>SQL Supporting Status Compatible with all regular SQL when routing to single data node; The SQL routing to multiple data nodes is pretty complex, it divides the scenarios as totally supported, experimental supported and unsupported.
Totally Supported Fully support DML, DDL, DCL, TCL and most regular DAL. Support complex query with pagination, DISTINCT, ORDER BY, GROUP BY, aggregation and table JOIN.
Regular Query  SELECT Clause  SELECT select_expr [, select_expr .</description>
    </item>
    
    <item>
      <title>Pagination</title>
      <link>https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/pagination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/2.0.0.M1/en/features/sharding/use-norms/pagination/</guid>
      <description>Totally support pagination queries of MySQL, PostgreSQL and Oracle; partly support SQLServer pagination query due to its complexity.
Pagination Performance Performance Bottleneck Pagination with query offset too high can lead to a low data accessibility, take MySQL as an example:
SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 This SQL will make MySQL acquire another 10 records after skipping 1,000,000 records when it is not able to use indexes.</description>
    </item>
    
  </channel>
</rss>