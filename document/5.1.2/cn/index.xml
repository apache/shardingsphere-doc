<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShardingSphere</title>
    <link>https://shardingsphere.apache.org/document/5.1.2/cn/</link>
    <description>Recent content on ShardingSphere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/document/5.1.2/cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/mysql/</guid>
      <description>MySQL 不支持的 SQL 清单如下：
用户和角色    SQL     CREATE USER &amp;lsquo;finley&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo; IDENTIFIED BY &amp;lsquo;password&amp;rsquo;   ALTER USER &amp;lsquo;finley&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo; IDENTIFIED BY &amp;lsquo;new_password&amp;rsquo;   DROP USER &amp;lsquo;finley&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo;;   CREATE ROLE &amp;lsquo;app_read&amp;rsquo;   DROP ROLE &amp;lsquo;app_read&amp;rsquo;   SHOW CREATE USER finley   SET PASSWORD = &amp;lsquo;auth_string&amp;rsquo;   SET ROLE DEFAULT;    授权    SQL     GRANT ALL ON db1.</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/mysql/</guid>
      <description>MySQL 不支持的 SQL 清单如下：
   SQL     CLONE LOCAL DATA DIRECTORY = &amp;lsquo;clone_dir&amp;rsquo;   INSTALL COMPONENT &amp;lsquo;file://component1&amp;rsquo;, &amp;lsquo;file://component2&amp;rsquo;   UNINSTALL COMPONENT &amp;lsquo;file://component1&amp;rsquo;, &amp;lsquo;file://component2&amp;rsquo;   REPAIR TABLE t_order   OPTIMIZE TABLE t_order   CHECKSUM TABLE t_order   CHECK TABLE t_order   SET RESOURCE GROUP group_name   DROP RESOURCE GROUP group_name   CREATE RESOURCE GROUP group_name TYPE = SYSTEM   ALTER RESOURCE GROUP rg1 VCPU = 0-63    源码：https://github.</description>
    </item>
    
    <item>
      <title>ShardingSphere-JDBC</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-jdbc-quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-jdbc-quick-start/</guid>
      <description>应用场景 Apache ShardingSphere-JDBC 可以通过 Java，YAML，Spring 命名空间 和 Spring Boot Starter 这 4 种方式进行配置，开发者可根据场景选择适合的配置方式。
使用限制 目前仅支持 JAVA 语言
前提条件 开发环境需要具备 Java JRE 8 或更高版本。
操作步骤  规则配置。  详情请参见用户手册。
引入 maven 依赖。  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${latest.release.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  注意：请将 ${latest.release.version} 更改为实际的版本号。
 编辑 application.yml。  spring: shardingsphere: datasource: names: ds_0, ds_1 ds_0: type: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/demo_ds_0?serverTimezone=UTC&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8  username: root password: ds_1: type: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/demo_ds_1?serverTimezone=UTC&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8  username: root password: rules: sharding: tables: .</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/use-norms/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/use-norms/sql/</guid>
      <description>SQL 支持程度 兼容全部常用的路由至单数据节点的 SQL； 路由至多数据节点的 SQL 由于场景复杂，分为稳定支持、实验性支持和不支持这三种情况。
稳定支持 全面支持 DML、DDL、DCL、TCL 和常用 DAL。 支持分页、去重、排序、分组、聚合、表关联等复杂查询。 支持 PostgreSQL 和 openGauss 数据库 SCHEMA DDL 和 DML 语句。
常规查询  SELECT 主语句  SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...] [WHERE predicates] [GROUP BY {col_name | position} [ASC | DESC], ...] [ORDER BY {col_name | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}]  select_expr  * | [DISTINCT] COLUMN_NAME [AS] [alias] | (MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | COUNT(* | COLUMN_NAME | alias) [AS] [alias]  table_reference  tbl_name [AS] alias] [index_hint_list] | table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)] 子查询 子查询和外层查询同时指定分片键，且分片键的值保持一致时，由内核提供稳定支持。</description>
    </item>
    
    <item>
      <title>SQL 解析测试</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/module-test/parser-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/module-test/parser-test/</guid>
      <description>数据准备 SQL 解析无需真实的测试环境，开发者只需定义好待测试的 SQL，以及解析后的断言数据即可：
SQL数据 在集成测试的部分提到过 sql-case-id，其对应的 SQL，可以在不同模块共享。开发者只需要在 shardingsphere-sql-parser/shardingsphere-sql-parser-test/src/main/resources/sql/supported/${SQL-TYPE}/*.xml 添加待测试的 SQL 即可。
断言数据 断言的解析数据保存在 shardingsphere-sql-parser/shardingsphere-sql-parser-test/src/main/resources/case/${SQL-TYPE}/*.xml 在 xml 文件中，可以针对表名，token，SQL 条件等进行断言，例如如下的配置：
&amp;lt;parser-result-sets&amp;gt; &amp;lt;parser-result sql-case-id=&amp;#34;insert_with_multiple_values&amp;#34;&amp;gt; &amp;lt;tables&amp;gt; &amp;lt;table name=&amp;#34;t_order&amp;#34; /&amp;gt; &amp;lt;/tables&amp;gt; &amp;lt;tokens&amp;gt; &amp;lt;table-token start-index=&amp;#34;12&amp;#34; table-name=&amp;#34;t_order&amp;#34; length=&amp;#34;7&amp;#34; /&amp;gt; &amp;lt;/tokens&amp;gt; &amp;lt;sharding-conditions&amp;gt; &amp;lt;and-condition&amp;gt; &amp;lt;condition column-name=&amp;#34;order_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;1&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;condition column-name=&amp;#34;user_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;1&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;/and-condition&amp;gt; &amp;lt;and-condition&amp;gt; &amp;lt;condition column-name=&amp;#34;order_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;2&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;condition column-name=&amp;#34;user_id&amp;#34; table-name=&amp;#34;t_order&amp;#34; operator=&amp;#34;EQUAL&amp;#34;&amp;gt; &amp;lt;value literal=&amp;#34;2&amp;#34; type=&amp;#34;int&amp;#34; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;/and-condition&amp;gt; &amp;lt;/sharding-conditions&amp;gt; &amp;lt;/parser-result&amp;gt; &amp;lt;/parser-result-sets&amp;gt; 设置好上面两类数据，开发者就可以通过 shardingsphere-sql-parser/shardingsphere-sql-parser-test 下对应的测试引擎启动 SQL 解析的测试了。</description>
    </item>
    
    <item>
      <title>Sysbench 性能测试</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/performance-test/performance-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/performance-test/performance-test/</guid>
      <description>目标 对 ShardingSphere-JDBC，ShardingSphere-Proxy 及 MySQL 进行性能对比。从业务角度考虑，在基本应用场景（单路由，主从+加密+分库分表，全路由）下，INSERT+UPDATE+DELETE 通常用作一个完整的关联操作，用于性能评估，而 SELECT 关注分片优化可用作性能评估的另一个操作；而主从模式下，可将 INSERT+SELECT+DELETE 作为一组评估性能的关联操作。 为了更好的观察效果，设计在一定数据量的基础上，使用 jmeter 20 并发线程持续压测半小时，进行增删改查性能测试，且每台机器部署一个 MySQL 实例，而对比 MySQL 场景为单机单实例部署。
测试场景 单路由 在 1000 数据量的基础上分库分表，根据 id 分为 4 个库，部署在同一台机器上，根据 k 分为 1024 个表，查询操作路由到单库单表； 作为对比，MySQL 运行在 1000 数据量的基础上，使用 INSERT+UPDATE+DELETE 和单路由查询语句。
主从 基本主从场景，设置一主库一从库，部署在两台不同的机器上，在 10000 数据量的基础上，观察读写性能； 作为对比，MySQL 运行在10000数据量的基础上，使用 INSERT+SELECT+DELETE 语句。
主从+加密+分库分表 在 1000 数据量的基础上，根据 id 分为 4 个库，部署在四台不同的机器上，根据 k 分为 1024 个表，c 使用 aes 加密，pad 使用 md5 加密，查询操作路由到单库单表； 作为对比，MySQL 运行在 1000 数据量的基础上，使用 INSERT+UPDATE+DELETE 和单路由查询语句。</description>
    </item>
    
    <item>
      <title>XA 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/concept/xa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/concept/xa/</guid>
      <description>两阶段事务提交采用的是 X/OPEN 组织所定义的 DTP 模型所抽象的 AP（应用程序）, TM（事务管理器）和 RM（资源管理器） 概念来保证分布式事务的强一致性。 其中 TM 与 RM 间采用 XA 的协议进行双向通信。 与传统的本地事务相比，XA 事务增加了准备阶段，数据库除了被动接受提交指令外，还可以反向通知调用方事务是否可以被提交。 TM 可以收集所有分支事务的准备结果，并于最后进行原子提交，以保证事务的强一致性。
Java 通过定义 JTA 接口实现了 XA 模型，JTA 接口中的 ResourceManager 需要数据库厂商提供 XA 驱动实现， TransactionManager 则需要事务管理器的厂商实现，传统的事务管理器需要同应用服务器绑定，因此使用的成本很高。 而嵌入式的事务管理器可以通过 jar 形式提供服务，同 Apache ShardingSphere 集成后，可保证分片后跨库事务强一致性。
通常，只有使用了事务管理器厂商所提供的 XA 事务连接池，才能支持 XA 的事务。 Apache ShardingSphere 在整合 XA 事务时，采用分离 XA 事务管理和连接池管理的方式，做到对应用程序的零侵入。</description>
    </item>
    
    <item>
      <title>XA 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/transaction/2pc-xa-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/transaction/2pc-xa-transaction/</guid>
      <description>XAShardingSphereTransactionManager 为 Apache ShardingSphere 的分布式事务的 XA 实现类。 它主要负责对多数据源进行管理和适配，并且将相应事务的开启、提交和回滚操作委托给具体的 XA 事务管理器。
开启全局事务 收到接入端的 set autoCommit=0 时，XAShardingSphereTransactionManager 将调用具体的 XA 事务管理器开启 XA 全局事务，以 XID 的形式进行标记。
执行真实分片SQL XAShardingSphereTransactionManager 将数据库连接所对应的 XAResource 注册到当前 XA 事务中之后，事务管理器会在此阶段发送 XAResource.start 命令至数据库。 数据库在收到 XAResource.end 命令之前的所有 SQL 操作，会被标记为 XA 事务。
例如:
XAResource1.start ## Enlist阶段执行 statement.execute(&amp;quot;sql1&amp;quot;); ## 模拟执行一个分片SQL1 statement.execute(&amp;quot;sql2&amp;quot;); ## 模拟执行一个分片SQL2 XAResource1.end ## 提交阶段执行 示例中的 sql1 和 sql2 将会被标记为 XA 事务。
提交或回滚事务 XAShardingSphereTransactionManager 在接收到接入端的提交命令后，会委托实际的 XA 事务管理进行提交动作， 事务管理器将收集到的当前线程中所有注册的 XAResource，并发送 XAResource.end 指令，用以标记此 XA 事务边界。 接着会依次发送 prepare 指令，收集所有参与 XAResource 投票。 若所有 XAResource 的反馈结果均为正确，则调用 commit 指令进行最终提交； 若有任意 XAResource 的反馈结果不正确，则调用 rollback 指令进行回滚。 在事务管理器发出提交指令后，任何 XAResource 产生的异常都会通过恢复日志进行重试，以保证提交阶段的操作原子性，和数据强一致性。</description>
    </item>
    
    <item>
      <title>YAML 配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/yaml-configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/yaml-configuration/</guid>
      <description>5.0.0-alpha 数据分片 配置项说明 dataSources: # 省略数据源配置，请参考使用手册 rules: - !SHARDING tables: # 数据分片规则配置 &amp;lt;logic-table-name&amp;gt; (+): # 逻辑表名称 actualDataNodes (?): # 由数据源名 + 表名组成（参考 Inline 语法规则） databaseStrategy (?): # 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一 standard: # 用于单分片键的标准分片场景 shardingColumn: # 分片列名称 shardingAlgorithmName: # 分片算法名称 complex: # 用于多分片键的复合分片场景 shardingColumns: # 分片列名称，多个列以逗号分隔 shardingAlgorithmName: # 分片算法名称 hint: # Hint 分片策略 shardingAlgorithmName: # 分片算法名称 none: # 不分片 tableStrategy: # 分表策略，同分库策略 keyGenerateStrategy: # 分布式序列策略 column: # 自增列名称，缺省表示不使用自增主键生成器 keyGeneratorName: # 分布式序列算法名称 autoTables: # 自动分片表规则配置 t_order_auto: # 逻辑表名称 actualDataSources (?</description>
    </item>
    
    <item>
      <title>使用 Java API</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/java-api/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 使用分布式事务 TransactionTypeHolder.set(TransactionType.XA); // 支持 TransactionType.LOCAL, TransactionType.XA, TransactionType.BASE try (Connection conn = dataSource.getConnection()) { // 使用 ShardingSphereDataSource  conn.setAutoCommit(false); PreparedStatement ps = conn.prepareStatement(&amp;#34;INSERT INTO t_order (user_id, status) VALUES (?, ?)&amp;#34;); ps.setObject(1, 1000); ps.setObject(2, &amp;#34;init&amp;#34;); ps.executeUpdate(); conn.commit(); } </description>
    </item>
    
    <item>
      <title>使用二进制发布包</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/bin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/bin/</guid>
      <description>启动步骤  通过下载页面获取 ShardingSphere-Proxy 安装包。 解压缩后修改 conf/server.yaml 和以 config- 前缀开头的文件，如：conf/config-xxx.yaml 文件，进行分片规则、读写分离规则配置。配置方式请参考配置手册。 Linux 操作系统请运行 bin/start.sh，Windows 操作系统请运行 bin/start.bat 启动 ShardingSphere-Proxy。如需配置启动端口、配置文件位置，可参考快速入门。  选择数据库协议 使用 PostgreSQL  使用任何 PostgreSQL 的客户端连接。如: psql -U root -h 127.0.0.1 -p 3307。  使用 MySQL  将 MySQL 的 JDBC 驱动程序复制至目录 ext-lib/。 使用任何 MySQL 的客户端连接。如: mysql -u root -h 127.0.0.1 -P 3307。  使用 openGauss  将以 org.opengauss 包名为前缀的 openGauss 的 JDBC 驱动程序复制至目录 ext-lib/。 使用任何 openGauss 的客户端连接。如: gsql -U root -h 127.</description>
    </item>
    
    <item>
      <title>使用探针</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/observability/agent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/observability/agent/</guid>
      <description>如何获取 本地构建  &amp;gt; cd shardingsphere/shardingsphere-agent &amp;gt; mvn clean install 远程下载（暂未发布）  &amp;gt; weget http://xxxxx/shardingsphere-agent.tar.gz &amp;gt; tar -zxvcf shardingsphere-agent.tar.gz 配置 找到 agent.yaml 文件：
applicationName: shardingsphere-agent ignoredPluginNames: # 忽略的插件集合 - Opentracing - Jaeger - Zipkin - Prometheus - OpenTelemetry - Logging plugins: Prometheus: host: &amp;#34;localhost&amp;#34; port: 9090 props: JVM_INFORMATION_COLLECTOR_ENABLED : &amp;#34;true&amp;#34; Jaeger: host: &amp;#34;localhost&amp;#34; port: 5775 props: SERVICE_NAME: &amp;#34;shardingsphere-agent&amp;#34; JAEGER_SAMPLER_TYPE: &amp;#34;const&amp;#34; JAEGER_SAMPLER_PARAM: &amp;#34;1&amp;#34; JAEGER_REPORTER_LOG_SPANS: &amp;#34;true&amp;#34; JAEGER_REPORTER_FLUSH_INTERVAL: &amp;#34;1&amp;#34; Zipkin: host: &amp;#34;localhost&amp;#34; port: 9411 props: SERVICE_NAME: &amp;#34;shardingsphere-agent&amp;#34; URL_VERSION: &amp;#34;/api/v2/spans&amp;#34; Opentracing: props: OPENTRACING_TRACER_CLASS_NAME: &amp;#34;org.</description>
    </item>
    
    <item>
      <title>元数据持久化仓库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/metadata-repository/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/metadata-repository/</guid>
      <description>文件持久化 类型：File
适用模式：Standalone
可配置属性：
   名称 数据类型 说明 默认值     path String 元数据存储路径 .shardingsphere    ZooKeeper 持久化 类型：ZooKeeper
适用模式：Cluster
可配置属性：
   名称 数据类型 说明 默认值     retryIntervalMilliseconds int 重试间隔毫秒数 500   maxRetries int 客户端连接最大重试次数 3   timeToLiveSeconds int 临时数据失效的秒数 60   operationTimeoutMilliseconds int 客户端操作超时的毫秒数 500   digest String 登录认证密码     Etcd 持久化 类型：Etcd</description>
    </item>
    
    <item>
      <title>强制路由</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/sharding/hint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/sharding/hint/</guid>
      <description>简介 Apache ShardingSphere 使用 ThreadLocal 管理分片键值进行强制路由。 可以通过编程的方式向 HintManager 中添加分片值，该分片值仅在当前线程内生效。
Apache ShardingSphere 还可以通过 SQL 中增加注释的方式进行强制路由。
Hint 的主要使用场景：
 分片字段不存在 SQL 和数据库表结构中，而存在于外部业务逻辑。 强制在主库进行某些数据操作。 强制在指定数据库进行某些数据操作。  使用方法 使用 Hint 分片 规则配置 Hint 分片算法需要用户实现 org.apache.shardingsphere.sharding.api.sharding.hint.HintShardingAlgorithm 接口。 Apache ShardingSphere 在进行路由时，将会从 HintManager 中获取分片值进行路由操作。
参考配置如下：
rules: - !SHARDING tables: t_order: actualDataNodes: demo_ds_${0..1}.t_order_${0..1} databaseStrategy: hint: algorithmClassName: xxx.xxx.xxx.HintXXXAlgorithm tableStrategy: hint: algorithmClassName: xxx.xxx.xxx.HintXXXAlgorithm defaultTableStrategy: none: defaultKeyGenerateStrategy: type: SNOWFLAKE column: order_id props: sql-show: true 获取 HintManager HintManager hintManager = HintManager.getInstance(); 添加分片键值  使用 hintManager.</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/sharding/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.sharding.api.config.ShardingRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     tables (+) Collection&amp;lt;ShardingTableRuleConfiguration&amp;gt; 分片表规则列表 -   autoTables (+) Collection&amp;lt;ShardingAutoTableRuleConfiguration&amp;gt; 自动化分片表规则列表 -   bindingTableGroups (*) Collection&amp;lt;String&amp;gt; 绑定表规则列表 无   broadcastTables (*) Collection&amp;lt;String&amp;gt; 广播表规则列表 无   defaultDatabaseShardingStrategy (?) ShardingStrategyConfiguration 默认分库策略 不分片   defaultTableShardingStrategy (?) ShardingStrategyConfiguration 默认分表策略 不分片   defaultKeyGenerateStrategy (?) KeyGeneratorConfiguration 默认自增列生成器配置 雪花算法   defaultShardingColumn (?) String 默认分片列名称 无   shardingAlgorithms (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 分片算法名称和配置 无   keyGenerators (?</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册 # 标准分片表配置 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.actual-data-nodes= # 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况 # 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一 # 用于单分片键的标准分片场景 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.sharding-column= # 分片列名称 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.sharding-algorithm-name= # 分片算法名称 # 用于多分片键的复合分片场景 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.sharding-columns= # 分片列名称，多个列以逗号分隔 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.sharding-algorithm-name= # 分片算法名称 # 用于 Hint 的分片策略 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.hint.sharding-algorithm-name= # 分片算法名称 # 分表策略，同分库策略 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.table-strategy.xxx= # 省略 # 自动分片表配置 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.actual-data-sources= # 数据源名 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-column= # 分片列名称 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-algorithm-name= # 自动分片算法名称 # 分布式序列策略配置 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.column= # 分布式序列列名称 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.key-generator-name= # 分布式序列算法名称 spring.shardingsphere.rules.sharding.binding-tables[0]= # 绑定表规则列表 spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表规则列表 spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表规则列表 spring.</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/sharding/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding-5.1.2.xsd
&amp;lt;sharding:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   table-rules (?) 标签 分片表规则配置   auto-table-rules (?) 标签 自动化分片表规则配置   binding-table-rules (?) 标签 绑定表规则配置   broadcast-table-rules (?) 标签 广播表规则配置   default-database-strategy-ref (?) 属性 默认分库策略名称   default-table-strategy-ref (?) 属性 默认分表策略名称   default-key-generate-strategy-ref (?) 属性 默认分布式序列策略名称   default-sharding-column (?) 属性 默认分片列名称    &amp;lt;sharding:table-rule /&amp;gt;</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/</guid>
      <description>配置项说明 rules: - !SHARDING tables: # 数据分片规则配置 &amp;lt;logic-table-name&amp;gt; (+): # 逻辑表名称 actualDataNodes (?): # 由数据源名 + 表名组成（参考 Inline 语法规则） databaseStrategy (?): # 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一 standard: # 用于单分片键的标准分片场景 shardingColumn: # 分片列名称 shardingAlgorithmName: # 分片算法名称 complex: # 用于多分片键的复合分片场景 shardingColumns: # 分片列名称，多个列以逗号分隔 shardingAlgorithmName: # 分片算法名称 hint: # Hint 分片策略 shardingAlgorithmName: # 分片算法名称 none: # 不分片 tableStrategy: # 分表策略，同分库策略 keyGenerateStrategy: # 分布式序列策略 column: # 自增列名称，缺省表示不使用自增主键生成器 keyGeneratorName: # 分布式序列算法名称 autoTables: # 自动分片表规则配置 t_order_auto: # 逻辑表名称 actualDataSources (?</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/sharding/</guid>
      <description>语法说明 Sharding Table Rule CREATE SHARDING TABLE RULE shardingTableRuleDefinition [, shardingTableRuleDefinition] ... ALTER SHARDING TABLE RULE shardingTableRuleDefinition [, shardingTableRuleDefinition] ... DROP SHARDING TABLE RULE tableName [, tableName] ... CREATE DEFAULT SHARDING shardingScope STRATEGY (shardingStrategy) ALTER DEFAULT SHARDING shardingScope STRATEGY (shardingStrategy) DROP DEFAULT SHARDING shardingScope STRATEGY; CREATE SHARDING ALGORITHM shardingAlgorithmDefinition [, shardingAlgorithmDefinition] ... ALTER SHARDING ALGORITHM shardingAlgorithmDefinition [, shardingAlgorithmDefinition] ... DROP SHARDING ALGORITHM algorithmName [, algorithmName] ... CREATE SHARDING KEY GENERATOR keyGeneratorDefinition [, keyGeneratorDefinition] .</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/sharding/</guid>
      <description>语法说明 Sharding Table Rule SHOW SHARDING TABLE tableRule | RULES [FROM databaseName] SHOW SHARDING ALGORITHMS [FROM databaseName] SHOW UNUSED SHARDING ALGORITHMS [FROM databaseName] SHOW SHARDING TABLE RULES USED ALGORITHM algorithmName [FROM databaseName] SHOW SHARDING KEY GENERATORS [FROM databaseName] SHOW UNUSED SHARDING KEY GENERATORS [FROM databaseName] SHOW SHARDING TABLE RULES USED KEY GENERATOR keyGeneratorName [FROM databaseName] SHOW DEFAULT SHARDING STRATEGY SHOW SHARDING TABLE NODES; tableRule: RULE tableName  支持查询所有数据分片规则和指定表查询； 支持查询所有分片算法。  Sharding Binding Table Rule SHOW SHARDING BINDING TABLE RULES [FROM databaseName] Sharding Broadcast Table Rule SHOW SHARDING BROADCAST TABLE RULES [FROM databaseName] Sharding Scaling Rule SHOW SHARDING SCALING RULES [FROM databaseName] 返回值说明 Sharding Table Rule    列 说明     table 逻辑表名   actual_data_nodes 实际的数据节点   actual_data_sources 实际的数据源（通过 RDL 创建的规则时显示）   database_strategy_type 数据库分片策略类型   database_sharding_column 数据库分片键   database_sharding_algorithm_type 数据库分片算法类型   database_sharding_algorithm_props 数据库分片算法参数   table_strategy_type 表分片策略类型   table_sharding_column 表分片键   table_sharding_algorithm_type 表分片算法类型   table_sharding_algorithm_props 表分片算法参数   key_generate_column 分布式主键生成列   key_generator_type 分布式主键生成器类型   key_generator_props 分布式主键生成器参数    Sharding Algorithms    列 说明     name 分片算法名称   type 分片算法类型   props 分片算法参数    Unused Sharding Algorithms    列 说明     name 分片算法名称   type 分片算法类型   props 分片算法参数    Sharding Key Generators    列 说明     name 主键生成器名称   type 主键生成器类型   props 主键生成器参数    Unused Sharding Key Generators    列 说明     name 主键生成器名称   type 主键生成器类型   props 主键生成器参数    Default Sharding Strategy    列 说明     name 策略名称   type 分片策略类型   sharding_column 分片键   sharding_algorithm_name 分片算法名称   sharding_algorithm_type 分片算法类型   sharding_algorithm_props 分片算法参数    Sharding Table Nodes    列 说明     name 分片规则名称   nodes 分片节点    Sharding Binding Table Rule    列 说明     sharding_binding_tables 绑定表名称    Sharding Broadcast Table Rule    列 说明     sharding_broadcast_tables 广播表名称    Sharding Scaling Rule    列 说明     name 弹性伸缩配置名称   input 数据读取配置   output 数据写入配置   stream_channel 数据通道配置   completion_detector 作业完成检测算法配置   data_consistency_checker 数据一致性校验算法配置    示例 Sharding Table Rule SHOW SHARDING TABLE RULES</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/sharding-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/sharding-rule/</guid>
      <description>资源操作 ADD RESOURCE ds_0 ( HOST=127.0.0.1, PORT=3306, DB=ds_1, USER=root, PASSWORD=root ); ADD RESOURCE ds_1 ( HOST=127.0.0.1, PORT=3306, DB=ds_2, USER=root, PASSWORD=root ); 规则操作  创建分片规则  CREATE SHARDING TABLE RULE t_order( RESOURCES(ds_0,ds_1), SHARDING_COLUMN=order_id, TYPE(NAME=hash_mod,PROPERTIES(&amp;#34;sharding-count&amp;#34;=4)), KEY_GENERATE_STRATEGY(COLUMN=order_id,TYPE(NAME=snowflake)) );  创建切分表  CREATE TABLE `t_order` ( `order_id` int NOT NULL, `user_id` int NOT NULL, `status` varchar(45) DEFAULT NULL, PRIMARY KEY (`order_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4  删除切分表  DROP TABLE t_order;  删除分片规则  DROP SHARDING TABLE RULE t_order;  删除数据源  DROP RESOURCE ds_0, ds_1;  删除分布式数据库  DROP DATABASE foo_db; </description>
    </item>
    
    <item>
      <title>本地事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/local-transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/local-transaction/</guid>
      <description>支持项  完全支持非跨库事务，例如：仅分表，或分库但是路由的结果在单库中； 完全支持因逻辑异常导致的跨库事务。例如：同一事务中，跨两个库更新。更新完毕后，抛出空指针，则两个库的内容都能够回滚。  不支持项  不支持因网络、硬件异常导致的跨库事务。例如：同一事务中，跨两个库更新，更新完毕后、未提交之前，第一个库宕机，则只有第二个库数据提交，且无法回滚。  </description>
    </item>
    
    <item>
      <title>权限</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/authentication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/authentication/</guid>
      <description>用于配置登录计算节点的初始用户，和存储节点数据授权。
配置项说明 rules: - !AUTHORITY users: - # 用于登录计算节点的用户名，授权主机和密码的组合。格式：&amp;lt;username&amp;gt;@&amp;lt;hostname&amp;gt;:&amp;lt;password&amp;gt;，hostname 为 % 或空字符串表示不限制授权主机 provider: type: # 存储节点数据授权的权限提供者类型，缺省值为 ALL_PERMITTED 配置示例 ALL_PERMITTED rules: - !AUTHORITY users: - root@localhost:root - my_user@:pwd provider: type: ALL_PERMITTED DATABASE_PERMITTED rules: - !AUTHORITY users: - root@:root - my_user@:pwd provider: type: DATABASE_PERMITTED props: user-database-mappings: root@=sharding_db, root@=test_db, my_user@127.0.0.1=sharding_db 以上配置表示：
 root 用户从任意主机连接时，可访问 sharding_db。 root 用户从任意主机连接时，可访问 test_db 。 my_user 用户仅当从 127.0.0.1 连接时，可访问 sharding_db。  权限提供者具体实现可以参考 权限提供者。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/encrypt/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/encrypt/concept/</guid>
      <description>逻辑列 用于计算加解密列的逻辑名称，是 SQL 中列的逻辑标识。 逻辑列包含密文列（必须）、查询辅助列（可选）和明文列（可选）。
密文列 加密后的数据列。
查询辅助列 用于查询的辅助列。 对于一些安全级别更高的非幂等加密算法，提供不可逆的幂等列用于查询。
明文列 存储明文的列，用于在加密数据迁移过程中仍旧提供服务。 在洗数结束后可以删除。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/ha/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/ha/concept/</guid>
      <description>高可用类型 Apache ShardingSphere 不提供数据库高可用的能力，它通过第三方提供的高可用方案感知数据库主从关系的切换。 确切来说，Apache ShardingSphere 提供数据库发现的能力，自动感知数据库主从关系，并修正计算节点对数据库的连接。
动态读写分离 高可用和读写分离一起使用时，读写分离无需配置具体的主库和从库。 高可用的数据源会动态的修正读写分离的主从关系，并正确的疏导读写流量。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/management/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/management/concept/</guid>
      <description>熔断 阻断 Apache ShardingSphere 和数据库的连接。 当某个 Apache ShardingSphere 节点超过负载后，停止该节点对数据库的访问，使数据库能够保证足够的资源为其他节点提供服务。
限流 面对超负荷的请求开启限流，以保护部分请求可以得以高质量的响应。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/observability/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/observability/concept/</guid>
      <description>代理 基于字节码增强和插件化设计，以提供 Tracing 和 Metrics 埋点，以及日志输出功能。 需要开启代理的插件功能后，才能将监控指标数据输出至第三方 APM 中展示。
APM APM 是应用性能监控的缩写。 着眼于分布式系统的性能诊断，其主要功能包括调用链展示，应用拓扑分析等。
Tracing 链路跟踪，通过探针收集调用链数据，并发送到第三方 APM 系统。
Metrics 系统统计指标，通过探针收集，并且写入到时序数据库，供第三方应用展示。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/readwrite-splitting/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/readwrite-splitting/concept/</guid>
      <description>主库 添加、更新以及删除数据操作所使用的数据库，目前仅支持单主库。
从库 查询数据操作所使用的数据库，可支持多从库。
主从同步 将主库的数据异步的同步到从库的操作。 由于主从同步的异步性，从库与主库的数据会短时间内不一致。
负载均衡策略 通过负载均衡策略将查询请求疏导至不同从库。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/scaling/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/scaling/concept/</guid>
      <description>弹性伸缩作业 指一次将数据由旧规则迁移至新规则的完整流程。
存量数据 在弹性伸缩作业开始前，数据节点中已有的数据。
增量数据 在弹性伸缩作业执行过程中，业务系统所产生的新数据。</description>
    </item>
    
    <item>
      <title>核心概念</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/shadow/concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/shadow/concept/</guid>
      <description>生产库 生产环境使用的数据库。
影子库 压测数据隔离的影子数据库，与生产数据库应当使用相同的配置。
影子算法 影子算法和业务实现紧密相关，目前提供 2 种类型影子算法。
 基于列的影子算法  通过识别 SQL 中的数据，匹配路由至影子库的场景。 适用于由压测数据名单驱动的压测场景。
 基于 Hint 的影子算法  通过识别 SQL 中的注释，匹配路由至影子库的场景。 适用于由上游系统透传标识驱动的压测场景。</description>
    </item>
    
    <item>
      <title>模式配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/mode/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.infra.config.mode.ModeConfiguration
可配置属性：
   名称 数据类型 说明 默认值     type String 运行模式类型
可选配置：Memory、Standalone、Cluster Memory   repository PersistRepositoryConfiguration 持久化仓库配置
Memory 类型无需持久化，可以为 null
Standalone 类型使用 StandalonePersistRepositoryConfiguration
Cluster 类型使用 ClusterPersistRepositoryConfiguration    overwrite boolean 是否使用本地配置覆盖持久化配置 false    Standalone 持久化配置 类名称：org.apache.shardingsphere.mode.repository.standalone.StandalonePersistRepositoryConfiguration
可配置属性：
   名称 数据类型 说明     type String 持久化仓库类型   props Properties 持久化仓库所需属性    Cluster 持久化配置 类名称：org.</description>
    </item>
    
    <item>
      <title>模式配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/mode/</guid>
      <description>缺省配置为使用内存模式。
配置项说明 spring.shardingsphere.mode.type= # 运行模式类型。可选配置：Memory、Standalone、Cluster spring.shardingsphere.mode.repository= # 持久化仓库配置。Memory 类型无需持久化 spring.shardingsphere.mode.overwrite= # 是否使用本地配置覆盖持久化配置 内存模式 spring.shardingsphere.mode.type=Memory 单机模式 spring.shardingsphere.mode.type=Standalone spring.shardingsphere.mode.repository.type= # 持久化仓库类型 spring.shardingsphere.mode.repository.props.&amp;lt;key&amp;gt;= # 持久化仓库所需属性 spring.shardingsphere.mode.overwrite= # 是否使用本地配置覆盖持久化配置 集群模式 spring.shardingsphere.mode.type=Cluster spring.shardingsphere.mode.repository.type= # 持久化仓库类型 spring.shardingsphere.mode.repository.props.namespace= # 注册中心命名空间 spring.shardingsphere.mode.repository.props.server-lists= # 注册中心连接地址 spring.shardingsphere.mode.repository.props.&amp;lt;key&amp;gt;= # 持久化仓库所需属性 spring.shardingsphere.mode.overwrite= # 是否使用本地配置覆盖持久化配置 持久化仓库类型的详情，请参见内置持久化仓库类型列表。</description>
    </item>
    
    <item>
      <title>模式配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/mode/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/datasource/datasource-5.1.2.xsd
&amp;lt;shardingsphere:mode /&amp;gt;
   名称 类型 说明 默认值     type 属性 运行模式类型。可选配置：Memory、Standalone、Cluster    repository-ref (?) 属性 持久化仓库 Bean 引用。Memory 类型无需持久化    overwrite (?) 属性 是否使用本地配置覆盖持久化配置 false    内存模式 缺省配置。
配置示例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:shardingsphere=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/datasource&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/datasource http://shardingsphere.apache.org/schema/shardingsphere/datasource/datasource.xsd&amp;#34;&amp;gt; &amp;lt;shardingsphere:data-source id=&amp;#34;ds&amp;#34; database-name=&amp;#34;foo_schema&amp;#34; data-source-names=&amp;#34;...&amp;#34; rule-refs=&amp;#34;...&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 单机模式 配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/mode-repository/standalone/repository-5.1.2.xsd
&amp;lt;standalone:repository /&amp;gt;
   名称 类型 说明     id 属性 持久化仓库 Bean 名称   type 属性 持久化仓库类型   props (?</description>
    </item>
    
    <item>
      <title>模式配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/mode/</guid>
      <description>配置项说明 mode (?): # 不配置则默认内存模式 type: # 运行模式类型。可选配置：Memory、Standalone、Cluster repository (?): # 久化仓库配置。Memory 类型无需持久化 overwrite: # 是否使用本地配置覆盖持久化配置 内存模式 mode: type: Memory 单机模式 mode: type: Standalone repository: type: # 持久化仓库类型 props: # 持久化仓库所需属性 foo_key: foo_value bar_key: bar_value overwrite: # 是否使用本地配置覆盖持久化配置 集群模式 mode: type: Cluster repository: type: # 持久化仓库类型 props: # 持久化仓库所需属性 namespace: # 注册中心命名空间 server-lists: # 注册中心连接地址 foo_key: foo_value bar_key: bar_value overwrite: # 是否使用本地配置覆盖持久化配置 持久化仓库类型的详情，请参见内置持久化仓库类型列表。</description>
    </item>
    
    <item>
      <title>表</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/table/</guid>
      <description>表是透明化数据分片的关键概念。 Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下的数据分片需求。
逻辑表 相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。 例：订单数据根据主键尾数拆分为 10 张表，分别是 t_order_0 到 t_order_9，他们的逻辑表名为 t_order。
真实表 在水平拆分的数据库中真实存在的物理表。 即上个示例中的 t_order_0 到 t_order_9。
绑定表 指分片规则一致的一组分片表。 使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。 例如：t_order 表和 t_order_item 表，均按照 order_id 分片，并且使用 order_id 进行关联，则此两张表互为绑定表关系。 绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。 举例说明，如果 SQL 为：
SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11); 在不配置绑定表关系时，假设分片键 order_id 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：
SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.</description>
    </item>
    
    <item>
      <title>解析引擎</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/parse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/parse/</guid>
      <description>相对于其他编程语言，SQL 是比较简单的。 不过，它依然是一门完善的编程语言，因此对 SQL 的语法进行解析，与解析其他编程语言（如：Java 语言、C 语言、Go 语言等）并无本质区别。
抽象语法树 解析过程分为词法解析和语法解析。 词法解析器用于将 SQL 拆解为不可再分的原子符号，称为 Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将词法解析器的输出转换为抽象语法树。
例如，以下 SQL：
SELECT id, name FROM t_user WHERE status = &amp;#39;ACTIVE&amp;#39; AND age &amp;gt; 18 解析之后的为抽象语法树见下图。
为了便于理解，抽象语法树中的关键字的 Token 用绿色表示，变量的 Token 用红色表示，灰色表示需要进一步拆分。
最后，通过 visitor 对抽象语法树遍历构造域模型，通过域模型（SQLStatement）去提炼分片所需的上下文，并标记有可能需要改写的位置。 供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）。 SQL 的一次解析过程是不可逆的，一个个 Token 按 SQL 原本的顺序依次进行解析，性能很高。 考虑到各种数据库 SQL 方言的异同，在解析模块提供了各类数据库的 SQL 方言字典。
SQL 解析引擎 历史 SQL 解析作为分库分表类产品的核心，其性能和兼容性是最重要的衡量指标。 ShardingSphere 的 SQL 解析器经历了 3 代产品的更新迭代。
第一代 SQL 解析器为了追求性能与快速实现，在 1.</description>
    </item>
    
    <item>
      <title>资源定义</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/resource-definition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/resource-definition/</guid>
      <description>语法说明 ADD RESOURCE dataSource [, dataSource] ... ALTER RESOURCE dataSource [, dataSource] ... DROP RESOURCE dataSourceName [, dataSourceName] ... [ignore single tables] dataSource: simpleSource | urlSource simpleSource: dataSourceName(HOST=hostname,PORT=port,DB=dbName,USER=user [,PASSWORD=password] [,PROPERTIES(poolProperty [,poolProperty]) ...]) urlSource: dataSourceName(URL=url,USER=user [,PASSWORD=password] [,PROPERTIES(poolProperty [,poolProperty]) ...]) poolProperty: &amp;#34;key&amp;#34;= (&amp;#34;value&amp;#34; | value)  添加资源前请确认已经创建分布式数据库，并执行 use 命令成功选择一个数据库； 确认增加的资源是可以正常连接的， 否则将不能添加成功； 重复的 dataSourceName 不允许被添加； 在同一 dataSource 的定义中，simpleSource 和 urlSource 语法不可混用； poolProperty 用于自定义连接池参数，key 必须和连接池参数名一致，value 支持 int 和 String 类型； ALTER RESOURCE 修改资源时不允许改变该资源关联的真实数据源； ALTER RESOURCE 修改资源时会发生连接池的切换，这个操作可能对进行中的业务造成影响，请谨慎使用； DROP RESOURCE 只会删除逻辑资源，不会删除真实的数据源； 被规则引用的资源将无法被删除； 若资源只被 single table rule 引用，且用户确认可以忽略该限制，则可以添加可选参数 ignore single tables 进行强制删除。  示例 ADD RESOURCE resource_0 ( HOST=127.</description>
    </item>
    
    <item>
      <title>资源查询</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/resource-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/resource-query/</guid>
      <description>语法说明 SHOW DATABASE RESOURCES [FROM databaseName] 返回值说明    列 说明     name 数据源名称   type 数据源类型   host 数据源地址   port 数据源端口   db 数据库名称   attribute 数据源参数    示例 mysql&amp;gt; show database resources; +------+-------+-----------+------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+ | name | type | host | port | db | attribute | +------+-------+-----------+------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+ | ds_0 | MySQL | 127.0.0.1 | 3306 | ds_0 | {&amp;#34;minPoolSize&amp;#34;:1,&amp;#34;connectionTimeoutMilliseconds&amp;#34;:30000,&amp;#34;maxLifetimeMilliseconds&amp;#34;:1800000,&amp;#34;readOnly&amp;#34;:false,&amp;#34;idleTimeoutMilliseconds&amp;#34;:60000,&amp;#34;maxPoolSize&amp;#34;:50} | | ds_1 | MySQL | 127.</description>
    </item>
    
    <item>
      <title>运行模式</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/mode/</guid>
      <description>StandalonePersistRepository    SPI 名称 详细说明     StandalonePersistRepository Standalone 模式配置信息持久化       已知实现类 详细说明     FileRepository 基于 File 的持久化   H2Repository 基于 H2 的持久化    ClusterPersistRepository    SPI 名称 详细说明     ClusterPersistRepository Cluster 模式配置信息持久化       已知实现类 详细说明     CuratorZookeeperRepository 基于 ZooKeeper 的持久化   EtcdRepository 基于 Etcd 的持久化    GovernanceWatcher    SPI 名称 详细说明     GovernanceWatcher 治理监听器       已知实现类 详细说明     ComputeNodeStateChangedWatcher 计算节点状态变化监听器   GlobalAckChangedWatcher 全局锁状态变化监听器   GlobalLocksChangedWatcher 全局锁变化监听器   GlobalRuleChangedWatcher 全局规则配置变化监听器   MetaDataChangedWatcher 元数据变化监听器   PropertiesChangedWatcher 属性变化监听器   StorageNodeStateChangedWatcher 存储节点状态变化监听器    </description>
    </item>
    
    <item>
      <title>运行部署</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/scaling/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/scaling/build/</guid>
      <description>部署启动  执行以下命令，编译生成 ShardingSphere-Proxy 二进制包：  git clone --depth 1 https://github.com/apache/shardingsphere.git cd shardingsphere mvn clean install -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests -Prelease 发布包：
 /shardingsphere-distribution/shardingsphere-proxy-distribution/target/apache-shardingsphere-${latest.release.version}-shardingsphere-proxy-bin.tar.gz  或者通过下载页面获取安装包。
 Scaling还是实验性质的功能，建议使用master分支最新版本，点击此处下载每日构建版本
  解压缩 proxy 发布包，修改配置文件 conf/config-sharding.yaml。详情请参见 proxy 启动手册。
  修改配置文件 conf/server.yaml，详情请参见模式配置。
  目前 mode 必须是 Cluster，需要提前启动对应的注册中心。
配置示例：
mode: type: Cluster repository: type: ZooKeeper props: namespace: governance_ds server-lists: localhost:2181 retryIntervalMilliseconds: 500 timeToLiveSeconds: 60 maxRetries: 3 operationTimeoutMilliseconds: 500 overwrite: false 开启 scaling。  方法1：修改配置文件 conf/config-sharding.</description>
    </item>
    
    <item>
      <title>ADD RESOURCE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/resource-definition/add-resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/resource-definition/add-resource/</guid>
      <description>描述 ADD RESOURCE 语法用于为当前所选逻辑库（SCHEMA）添加资源。
语法 AddResource ::= &amp;#39;ADD&amp;#39; &amp;#39;RESOURCE&amp;#39; dataSource (&amp;#39;,&amp;#39; dataSource)* dataSource ::= dataSourceName &amp;#39;(&amp;#39; ( &amp;#39;HOST&amp;#39; &amp;#39;=&amp;#39; hostName &amp;#39;,&amp;#39; &amp;#39;PORT&amp;#39; &amp;#39;=&amp;#39; port &amp;#39;,&amp;#39; &amp;#39;DB&amp;#39; &amp;#39;=&amp;#39; dbName | &amp;#39;URL&amp;#39; &amp;#39;=&amp;#39; url ) &amp;#39;,&amp;#39; &amp;#39;USER&amp;#39; &amp;#39;=&amp;#39; user (&amp;#39;,&amp;#39; &amp;#39;PASSWORD&amp;#39; &amp;#39;=&amp;#39; password )? (&amp;#39;,&amp;#39; &amp;#39;PROPERTIES&amp;#39; &amp;#39;(&amp;#39; ( key &amp;#39;=&amp;#39; value ) ( &amp;#39;,&amp;#39; key &amp;#39;=&amp;#39; value )* &amp;#39;)&amp;#39; )?&amp;#39;)&amp;#39; dataSourceName ::= identifier hostname ::= identifier | ip dbName ::= identifier port ::= int password ::= identifier | int | string user ::= identifier url ::= identifier | string 特别说明  添加资源前请确认已经在 Proxy 中创建逻辑数据库，并执行 use 命令成功选择一个逻辑数据库 确认添加的资源是可以正常连接的， 否则将不能添加成功 dataSourceName 区分大小写 dataSourceName 在当前逻辑库中需要唯一 dataSourceName 命名只允许使用字母、数字以及 _ ，且必须以字母开头 poolProperty 用于自定义连接池参数，key 必须和连接池参数名一致，value 支持 int 和 String 类型 当 password 包含特殊字符时，建议使用 string 形式；例如 password@123的 string 形式为 &amp;quot;password@123&amp;quot;  示例  使用标准模式添加资源  ADD RESOURCE ds_0 ( HOST=127.</description>
    </item>
    
    <item>
      <title>BenchmarkSQL 性能测试</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/performance-test/benchmarksql-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/performance-test/benchmarksql-test/</guid>
      <description>测试方法 ShardingSphere Proxy 支持通过 BenchmarkSQL 5.0 进行 TPC-C 测试。 除本文说明的内容外，BenchmarkSQL 操作步骤按照原文档 HOW-TO-RUN.txt 即可。
测试工具微调 与单机数据库压测不同，分布式数据库解决方案难免在功能支持上有所取舍。使用 BenchmarkSQL 压测 ShardingSphere Proxy 建议进行如下调整。
移除外键与 extraHistID 修改 BenchmarkSQL 目录下 run/runDatabaseBuild.sh，文件第 17 行。
修改前：
AFTER_LOAD=&amp;#34;indexCreates foreignKeys extraHistID buildFinish&amp;#34; 修改后：
AFTER_LOAD=&amp;#34;indexCreates buildFinish&amp;#34; 压测环境或参数建议 注意：本节中提到的任何参数都不是绝对值，都需要根据实际测试结果进行调整或取舍。
建议使用 Java 17 运行 ShardingSphere 编译 ShardingSphere 可以使用 Java 8。
使用 Java 17 可以在默认情况下尽量提升 ShardingSphere 的性能。
ShardingSphere 数据分片建议 对 BenchmarkSQL 的数据分片，可以考虑以各个表中的 warehouse id 作为分片键。
其中一个表 bmsql_item 没有 warehouse id，数据量固定 10 万行：
 可以取 i_id 作为分片键。但可能会导致同一个 Proxy 连接同时持有多个不同数据源的连接。 或考虑不做分片，存在单个数据源内。可能会导致某一数据源压力较大。 或对 i_id 进行范围分片，例如 1-50000 分布在数据源 0、50001-100000 分布在数据源 1。  BenchmarkSQL 中有如下 SQL 涉及多表：</description>
    </item>
    
    <item>
      <title>CREATE SHARDING ALGORITHM</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-algorithm/</guid>
      <description>描述 CREATE SHARDING ALGORITHM 语法用于为当前所选的逻辑库添加分片算法
语法定义 CreateShardingAlgorithm ::= &amp;#39;CREATE&amp;#39; &amp;#39;SHARDING&amp;#39; &amp;#39;ALGORITHM&amp;#39; shardingAlgorithmName &amp;#39;(&amp;#39; algorithmDefinition &amp;#39;)&amp;#39; algorithmDefinition ::= &amp;#39;TYPE&amp;#39; &amp;#39;(&amp;#39; &amp;#39;NAME&amp;#39; &amp;#39;=&amp;#39; algorithmType ( &amp;#39;,&amp;#39; &amp;#39;PROPERTIES&amp;#39; &amp;#39;(&amp;#39; propertyDefinition &amp;#39;)&amp;#39; )?&amp;#39;)&amp;#39; propertyDefinition ::= ( key &amp;#39;=&amp;#39; value ) ( &amp;#39;,&amp;#39; key &amp;#39;=&amp;#39; value )* shardingAlgorithmName ::= identifier algorithmType ::= identifier 补充说明  algorithmType 为分片算法类型，详细的分片算法类型信息请参考分片算法  示例 1.创建分片算法 -- 创建类型为 INLINE 的分片算法 CREATE SHARDING ALGORITHM inline_algorithm ( TYPE(NAME=inline, PROPERTIES(&amp;#34;algorithm-expression&amp;#34;=&amp;#34;t_order_${user_id % 2}&amp;#34;)) ); -- 创建类型为 AUTO_INTERVAL 的分片算法 CREATE SHARDING ALGORITHM interval_algorithm ( TYPE(NAME=auto_interval, PROPERTIES(&amp;#34;datetime-lower&amp;#34;=&amp;#34;2022-01-01 00:00:00&amp;#34;, &amp;#34;datetime-upper&amp;#34;=&amp;#34;2022-01-03 00:00:00&amp;#34;, &amp;#34;sharding-seconds&amp;#34;=&amp;#34;86400&amp;#34;)) ); 保留字 CREATE、SHARDING、ALGORITHM、TYPE、NAME、PROPERTIES  相关链接  保留字  </description>
    </item>
    
    <item>
      <title>CREATE SHARDING TABLE RULE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-table-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-table-rule/</guid>
      <description>描述 CREATE SHARDING TABLE RULE 语法用于为当前所选逻辑库添加分片规则
语法定义 CreateShardingTableRule ::= &amp;#39;CREATE&amp;#39; &amp;#39;SHARDING&amp;#39; &amp;#39;TABLE&amp;#39; &amp;#39;RULE&amp;#39; ( tableDefinition | autoTableDefinition ) ( &amp;#39;,&amp;#39; ( tableDefinition | autoTableDefinition ) )* tableDefinition ::= tableName &amp;#39;(&amp;#39; &amp;#39;DATANODES&amp;#39; &amp;#39;(&amp;#39; dataNode ( &amp;#39;,&amp;#39; dataNode )* &amp;#39;)&amp;#39; ( &amp;#39;,&amp;#39; &amp;#39;DATABASE_STRATEGY&amp;#39; &amp;#39;(&amp;#39; strategyDefinition &amp;#39;)&amp;#39; )? ( &amp;#39;,&amp;#39; &amp;#39;TABLE_STRATEGY&amp;#39; &amp;#39;(&amp;#39; strategyDefinition &amp;#39;)&amp;#39; )? ( &amp;#39;,&amp;#39; &amp;#39;KEY_GENERATE_STRATEGY&amp;#39; &amp;#39;(&amp;#39; keyGenerateStrategyDefinition &amp;#39;)&amp;#39; )? &amp;#39;)&amp;#39; autoTableDefinition ::= tableName &amp;#39;(&amp;#39; &amp;#39;RESOURCES&amp;#39; &amp;#39;(&amp;#39; resourceName ( &amp;#39;,&amp;#39; resourceName )* &amp;#39;)&amp;#39; &amp;#39;,&amp;#39; &amp;#39;SHARDING_COLUMN&amp;#39; &amp;#39;=&amp;#39; columnName &amp;#39;,&amp;#39; algorithmDefinition ( &amp;#39;,&amp;#39; &amp;#39;KEY_GENERATE_STRATEGY&amp;#39; &amp;#39;(&amp;#39; keyGenerateStrategyDefinition &amp;#39;)&amp;#39; )?</description>
    </item>
    
    <item>
      <title>Java API</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/java-api/</guid>
      <description>5.0.0-beta 数据分片 配置入口 类名称：org.apache.shardingsphere.sharding.api.config.ShardingRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     tables (+) Collection&amp;lt;ShardingTableRuleConfiguration&amp;gt; 分片表规则列表 -   autoTables (+) Collection&amp;lt;ShardingAutoTableRuleConfiguration&amp;gt; 自动化分片表规则列表 -   bindingTableGroups (*) Collection&amp;lt;String&amp;gt; 绑定表规则列表 无   broadcastTables (*) Collection&amp;lt;String&amp;gt; 广播表规则列表 无   defaultDatabaseShardingStrategy (?) ShardingStrategyConfiguration 默认分库策略 不分片   defaultTableShardingStrategy (?) ShardingStrategyConfiguration 默认分表策略 不分片   defaultKeyGenerateStrategy (?) KeyGeneratorConfiguration 默认自增列生成器配置 雪花算法   shardingAlgorithms (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 分片算法名称和配置 无   keyGenerators (?</description>
    </item>
    
    <item>
      <title>openGauss</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/opengauss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/opengauss/</guid>
      <description>openGauss 不支持的 SQL 清单如下：
   SQL     CREATE type avg_state AS (total bigint, count bigint);   CREATE AGGREGATE my_avg(int4) (stype = avg_state, sfunc = avg_transfn, finalfunc = avg_finalfn)   CREATE TABLE agg_data_2k AS SELECT g FROM generate_series(0, 1999) g;   CREATE SCHEMA alt_nsp1;   ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;   CREATE CONVERSION alt_conv1 FOR &amp;lsquo;LATIN1&amp;rsquo; TO &amp;lsquo;UTF8&amp;rsquo; FROM iso8859_1_to_utf8;   CREATE FOREIGN DATA WRAPPER alt_fdw1   CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1   CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler   CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1   CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple)   CREATE RULE def_view_test_ins AS ON INSERT TO def_view_test DO INSTEAD INSERT INTO def_test SELECT new.</description>
    </item>
    
    <item>
      <title>PostgreSQL</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/postgresql/</guid>
      <description>PostgreSQL 不支持的 SQL 清单如下：
TODO</description>
    </item>
    
    <item>
      <title>PostgreSQL</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/postgresql/</guid>
      <description>PostgreSQL 不支持的 SQL 清单如下：
   SQL     CREATE type avg_state AS (total bigint, count bigint);   CREATE AGGREGATE my_avg(int4) (stype = avg_state, sfunc = avg_transfn, finalfunc = avg_finalfn)   CREATE TABLE agg_data_2k AS SELECT g FROM generate_series(0, 1999) g;   CREATE SCHEMA alt_nsp1;   ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;   CREATE CONVERSION alt_conv1 FOR &amp;lsquo;LATIN1&amp;rsquo; TO &amp;lsquo;UTF8&amp;rsquo; FROM iso8859_1_to_utf8;   CREATE FOREIGN DATA WRAPPER alt_fdw1   CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1   CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler   CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1   CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple)   CREATE RULE def_view_test_ins AS ON INSERT TO def_view_test DO INSTEAD INSERT INTO def_test SELECT new.</description>
    </item>
    
    <item>
      <title>Seata 柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/transaction/base-transaction-seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/transaction/base-transaction-seata/</guid>
      <description>整合 Seata AT 事务时，需要将 TM，RM 和 TC 的模型融入 Apache ShardingSphere 的分布式事务生态中。 在数据库资源上，Seata 通过对接 DataSource 接口，让 JDBC 操作可以同 TC 进行远程通信。 同样，Apache ShardingSphere 也是面向 DataSource 接口，对用户配置的数据源进行聚合。 因此，将 DataSource 封装为 基于Seata 的 DataSource 后，就可以将 Seata AT 事务融入到 Apache ShardingSphere的分片生态中。
引擎初始化 包含 Seata 柔性事务的应用启动时，用户配置的数据源会根据 seata.conf 的配置，适配为 Seata 事务所需的 DataSourceProxy，并且注册至 RM 中。
开启全局事务 TM 控制全局事务的边界，TM 通过向 TC 发送 Begin 指令，获取全局事务 ID，所有分支事务通过此全局事务 ID，参与到全局事务中；全局事务 ID 的上下文存放在当前线程变量中。
执行真实分片SQL 处于 Seata 全局事务中的分片 SQL 通过 RM 生成 undo 快照，并且发送 participate 指令至 TC，加入到全局事务中。 由于 Apache ShardingSphere 的分片物理 SQL 采取多线程方式执行，因此整合 Seata AT 事务时，需要在主线程和子线程间进行全局事务 ID 的上下文传递。</description>
    </item>
    
    <item>
      <title>ShardingSphere-Proxy</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-proxy-quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-proxy-quick-start/</guid>
      <description>获取 ShardingSphere-Proxy 目前 ShardingSphere-Proxy 可以通过以下方式：
 二进制发布包 Docker Helm  规则配置 编辑 %SHARDINGSPHERE_PROXY_HOME%/conf/config-xxx.yaml。
编辑 %SHARDINGSPHERE_PROXY_HOME%/conf/server.yaml。
 %SHARDINGSPHERE_PROXY_HOME% 为 Proxy 解压后的路径，例：/opt/shardingsphere-proxy-bin/
 详情请参见 配置手册。
引入依赖 如果后端连接 PostgreSQL 数据库，不需要引入额外依赖。
如果后端连接 MySQL 数据库，请下载 mysql-connector-java-5.1.47.jar 或者 mysql-connector-java-8.0.11.jar，并将其放入 %SHARDINGSPHERE_PROXY_HOME%/ext-lib 目录。
启动服务  使用默认配置项  sh %SHARDINGSPHERE_PROXY_HOME%/bin/start.sh 默认启动端口为 3307，默认配置文件目录为：%SHARDINGSPHERE_PROXY_HOME%/conf/。
 自定义端口和配置文件目录  sh %SHARDINGSPHERE_PROXY_HOME%/bin/start.sh ${proxy_port} ${proxy_conf_directory} 使用 ShardingSphere-Proxy 执行 MySQL 或 PostgreSQL 的客户端命令直接操作 ShardingSphere-Proxy 即可。以 MySQL 举例：
mysql -u${proxy_username} -p${proxy_password} -h${proxy_host} -P${proxy_port} </description>
    </item>
    
    <item>
      <title>SHOW RESOURCE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/resource-query/show-resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/resource-query/show-resource/</guid>
      <description>描述 SHOW RESOURCE 语法用于查询指定逻辑库已经添加的资源。
语法 ShowResource ::= &amp;#39;SHOW&amp;#39; &amp;#39;SCHEMA&amp;#39; &amp;#39;RESOURCES&amp;#39; (&amp;#39;FROM&amp;#39; schemaName)? schemaName ::= identifier 特别说明  未指定 schemaName 时，默认是当前使用的 SCHEMA； 如未使用 SCHEMA 则会提示 No database selected。  返回值说明    列 说明     name 数据源名称   type 数据源类型   host 数据源地址   port 数据源端口   db 数据库名称   attribute 数据源参数    示例  查询指定逻辑库的资源  SHOW SCHEMA RESOURCES FROM sharding_db; +------+-------+-----------+------+------+---------------------------------+---------------------------+---------------------------+---------------+---------------+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | name | type | host | port | db | connection_timeout_milliseconds | idle_timeout_milliseconds | max_lifetime_milliseconds | max_pool_size | min_pool_size | read_only | other_attributes | +------+-------+-----------+------+------+---------------------------------+---------------------------+---------------------------+---------------+---------------+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | ds_0 | MySQL | 127.</description>
    </item>
    
    <item>
      <title>SQL 改写测试</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/module-test/rewrite-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/test/module-test/rewrite-test/</guid>
      <description>目标 面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。它包括正确性改写和优化改写两部分，所以 SQL 改写的测试都是基于这些改写方向进行校验的。
测试 SQL 改写测试用例位于 sharding-core/sharding-core-rewrite 下的 test 中。SQL 改写的测试主要依赖如下几个部分：
 测试引擎 环境配置 验证数据  测试引擎是 SQL 改写测试的入口，跟其他引擎一样，通过 Junit 的 Parameterized 逐条读取 test\resources 目录中测试类型下对应的 xml 文件，然后按读取顺序一一进行验证。
环境配置存放在 test\resources\yaml 路径中测试类型下对应的 yaml 中。配置了 dataSources，shardingRule，encryptRule 等信息，例子如下：
dataSources: db: !!com.zaxxer.hikari.HikariDataSource driverClassName: org.h2.Driver jdbcUrl: jdbc:h2:mem:db;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false;MODE=MYSQL username: sa password: ## sharding 规则 rules: - !SHARDING tables: t_account: actualDataNodes: db.t_account_${0..1} tableStrategy: standard: shardingColumn: account_id shardingAlgorithmName: account_table_inline keyGenerateStrategy: column: account_id keyGeneratorName: snowflake t_account_detail: actualDataNodes: db.</description>
    </item>
    
    <item>
      <title>XA 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/xa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/xa/</guid>
      <description>支持项  支持 Savepoint 嵌套事务； PostgreSQL/OpenGauss 事务块内，SQL 执行出现异常，执行 Commit，事务自动回滚； 支持数据分片后的跨库事务； 两阶段提交保证操作的原子性和数据的强一致性； 服务宕机重启后，提交/回滚中的事务可自动恢复； 支持同时使用 XA 和非 XA 的连接池。  不支持项  服务宕机后，在其它机器上恢复提交/回滚中的数据； MySQL 事务块内，SQL 执行出现异常，执行 Commit，数据保持一致。  通过 XA 语句控制的分布式事务  通过 XA START 可以手动开启 XA 事务，注意该事务完全由用户管理，ShardingSphere 只负责将语句转发至后端数据库； 服务宕机后，需要通过 XA RECOVER 获取未提交或回滚的事务，也可以在 COMMIT 时使用 ONE PHASE 跳过 PERPARE。  MySQL [(none)]&amp;gt; use test1 │MySQL [(none)]&amp;gt; use test2 Reading table information for completion of table and column names │Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A │You can turn off this feature to get a quicker startup with -A │ Database changed │Database changed MySQL [test1]&amp;gt; XA START &amp;#39;61c052438d3eb&amp;#39;; │MySQL [test2]&amp;gt; XA START &amp;#39;61c0524390927&amp;#39;; Query OK, 0 rows affected (0.</description>
    </item>
    
    <item>
      <title>使用 Docker</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/docker/</guid>
      <description>拉取官方 Docker 镜像 docker pull apache/shardingsphere-proxy 手动构建 Docker 镜像（可选） git clone https://github.com/apache/shardingsphere mvn clean install cd shardingsphere-distribution/shardingsphere-proxy-distribution mvn clean package -Prelease,docker 配置 ShardingSphere-Proxy 在 /${your_work_dir}/conf/ 创建 server.yaml 和 config-xxx.yaml 文件，进行服务器和分片规则配置。 配置规则，请参考配置手册。 配置模板，请参考配置模板
运行 Docker docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -e PORT=3308 -p13308:3308 apache/shardingsphere-proxy:latest 说明
 可以自定义端口 3308 和 13308。3308 表示 docker 容器端口, 13308 表示宿主机端口。 必须挂载配置路径到 /opt/shardingsphere-proxy/conf。  docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -e JVM_OPTS=&amp;#34;-Djava.awt.headless=true&amp;#34; -e PORT=3308 -p13308:3308 apache/shardingsphere-proxy:latest 说明
 可以自定义JVM相关参数到环境变量 JVM_OPTS 中。  docker run -d -v /${your_work_dir}/conf:/opt/shardingsphere-proxy/conf -v /${your_work_dir}/ext-lib:/opt/shardingsphere-proxy/ext-lib -p13308:3308 apache/shardingsphere-proxy:latest 说明</description>
    </item>
    
    <item>
      <title>使用 Spring Boot Starter</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/spring-boot-starter/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置事务管理器 @Configuration @EnableTransactionManagement public class TransactionConfiguration { @Bean public PlatformTransactionManager txManager(final DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean public JdbcTemplate jdbcTemplate(final DataSource dataSource) { return new JdbcTemplate(dataSource); } } 使用分布式事务 @Transactional @ShardingSphereTransactionType(TransactionType.XA) // 支持TransactionType.LOCAL, TransactionType.XA, TransactionType.BASE public void insert() { jdbcTemplate.execute(&amp;#34;INSERT INTO t_order (user_id, status) VALUES (?</description>
    </item>
    
    <item>
      <title>使用手册</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/scaling/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/scaling/usage/</guid>
      <description>使用手册 环境要求 纯 JAVA 开发，JDK 建议 1.8 以上版本。
支持的数据库及版本如下：
   源端 目标端     MySQL(5.1.15 ~ 5.7.x) MySQL(5.1.15 ~ 5.7.x)   PostgreSQL(9.4 ~ ) PostgreSQL(9.4 ~ )   openGauss(2.1.0) openGauss(2.1.0)    功能支持情况：
   功能 MySQL PostgreSQL openGauss     全量迁移 支持 支持 支持   增量迁移 支持 支持 支持   自动建表 支持 支持 支持   DATA_MATCH一致性校验 支持 支持 支持   CRC32_MATCH一致性校验 支持 不支持 不支持    注意：</description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/encrypt/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/encrypt/use-norms/</guid>
      <description>支持项  对数据库表中某个或多个列进行加解密； 兼容所有常用 SQL。  不支持项  需自行处理数据库中原始的存量数据； 加密字段无法支持查询不区分大小写功能； 加密字段无法支持比较操作，如：大于、小于、ORDER BY、BETWEEN、LIKE 等； 加密字段无法支持计算操作，如：AVG、SUM 以及计算表达式。  </description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/ha/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/ha/use-norms/</guid>
      <description>支持项  MySQL MGR 单主模式。  不支持项  MySQL MGR 多主模式。  </description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/observability/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/observability/use-norms/</guid>
      <description>源码编译 从 Github 下载 Apache ShardingSphere 源码，对源码进行编译，操作命令如下。
git clone --depth 1 https://github.com/apache/shardingsphere.git cd shardingsphere mvn clean install -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests -Prelease agent 包输出目录为 shardingsphere-agent/shardingsphere-agent-distribution/target/apache-shardingsphere-${latest.release.version}-shardingsphere-agent-bin.tar.gz
agent 配置  目录说明  创建 agent 目录，解压 agent 二进制包到 agent 目录。
mkdir agent tar -zxvf apache-shardingsphere-${latest.release.version}-shardingsphere-agent-bin.tar.gz -C agent cd agent tree . ├── conf │ ├── agent.yaml │ └── logback.xml ├── plugins │ ├── shardingsphere-agent-logging-base-${latest.release.version}.jar │ ├── shardingsphere-agent-metrics-prometheus-${latest.release.version}.jar │ ├── shardingsphere-agent-tracing-jaeger-${latest.release.version}.jar │ ├── shardingsphere-agent-tracing-opentelemetry-${latest.</description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/readwrite-splitting/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/readwrite-splitting/use-norms/</guid>
      <description>支持项  提供一主多从的读写分离配置，可独立使用，也可配合数据分片使用； 事务中的数据读写均用主库； 基于 Hint 的强制主库路由。  不支持项  主库和从库的数据同步； 主库和从库的数据同步延迟导致的数据不一致； 主库多写； 主从库间的事务一致性。主从模型中，事务中的数据读写均用主库。  </description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/scaling/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/scaling/use-norms/</guid>
      <description>支持项  将外围数据迁移至 Apache ShardingSphere 所管理的数据库； 将 Apache ShardingSphere 的数据节点进行扩容或缩容。  不支持项  无主键表扩缩容； 复合主键表扩缩容； 不支持在当前存储节点之上做迁移，需要准备一个全新的数据库集群作为迁移目标库。  </description>
    </item>
    
    <item>
      <title>使用规范</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/shadow/use-norms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/shadow/use-norms/</guid>
      <description>支持项  基于 Hint 的影子算法支持全部 SQL； 基于列的影子算法仅支持部分 SQL。  不支持项 基于 Hint 的影子算法  无。  基于列的影子算法  不支持 DDL； 不支持范围、分组和子查询，如：BETWEEN、GROUP BY &amp;hellip; HAVING 等。  SQL 支持列表：
 INSERT     SQL 是否支持     INSERT INTO table (column,&amp;hellip;) VALUES (value,&amp;hellip;) 支持   INSERT INTO table (column,&amp;hellip;) VALUES (value,&amp;hellip;),(value,&amp;hellip;),&amp;hellip; 支持   INSERT INTO table (column,&amp;hellip;) SELECT column1 from table1 where column1 = value1 不支持     SELECT/UPDATE/DELETE     条件类型 SQL 是否支持     = SELECT/UPDATE/DELETE &amp;hellip; WHERE column = value 支持   LIKE/NOT LIKE SELECT/UPDATE/DELETE &amp;hellip; WHERE column LIKE/NOT LIKE value 支持   IN/NOT IN SELECT/UPDATE/DELETE &amp;hellip; WHERE column IN/NOT IN (value1,value2,&amp;hellip;) 支持   BETWEEN SELECT/UPDATE/DELETE &amp;hellip; WHERE column BETWEEN value1 AND value2 不支持   GROUP BY &amp;hellip; HAVING&amp;hellip; SELECT/UPDATE/DELETE &amp;hellip; WHERE &amp;hellip; GROUP BY column HAVING column &amp;gt; value 不支持   子查询 SELECT/UPDATE/DELETE &amp;hellip; WHERE column = (SELECT column FROM table WHERE column = value) 不支持    </description>
    </item>
    
    <item>
      <title>分片算法</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/</guid>
      <description>自动分片算法 取模分片算法 类型：MOD
可配置属性：
   属性名称 数据类型 说明     sharding-count int 分片数量    哈希取模分片算法 类型：HASH_MOD
可配置属性：
   属性名称 数据类型 说明     sharding-count int 分片数量    基于分片容量的范围分片算法 类型：VOLUME_RANGE
可配置属性：
   属性名称 数据类型 说明     range-lower long 范围下界，超过边界的数据会报错   range-upper long 范围上界，超过边界的数据会报错   sharding-volume long 分片容量    基于分片边界的范围分片算法 类型：BOUNDARY_RANGE</description>
    </item>
    
    <item>
      <title>分页</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/use-norms/pagination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/use-norms/pagination/</guid>
      <description>完全支持 MySQL、PostgreSQL 和 Oracle 的分页查询，SQLServer 由于分页查询较为复杂，仅部分支持。
分页性能 性能瓶颈 查询偏移量过大的分页会导致数据库获取数据性能低下，以 MySQL 为例：
SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 这句 SQL 会使得 MySQL 在无法利用索引的情况下跳过 1,000,000 条记录后，再获取 10 条记录，其性能可想而知。 而在分库分表的情况下（假设分为2个库），为了保证数据的正确性，SQL 会改写为：
SELECT * FROM t_order ORDER BY id LIMIT 0, 1000010 即将偏移量前的记录全部取出，并仅获取排序后的最后 10 条记录。这会在数据库本身就执行很慢的情况下，进一步加剧性能瓶颈。 因为原SQL仅需要传输 10 条记录至客户端，而改写之后的SQL则会传输 1,000,010 * 2 的记录至客户端。
ShardingSphere 的优化 ShardingSphere 进行了 2 个方面的优化。
首先，采用流式处理 + 归并排序的方式来避免内存的过量占用。由于 SQL 改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。 与直觉不同，大多数人认为 ShardingSphere 会将 1,000,010 * 2 记录全部加载至内存，进而占用大量内存而导致内存溢出。 但由于每个结果集的记录是有序的，因此 ShardingSphere 每次比较仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。 按归并思想合并 m 个长度为 n 的已排序数组，时间复杂度为 O(mn(log m))，一般分片数量 m 都较小，可以认为时间复杂度为 O(n)，性能损耗很小。</description>
    </item>
    
    <item>
      <title>单表</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/single-table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/single-table/</guid>
      <description>定义 CREATE DEFAULT SINGLE TABLE RULE singleTableRuleDefinition ALTER DEFAULT SINGLE TABLE RULE singleTableRuleDefinition DROP DEFAULT SINGLE TABLE RULE singleTableRuleDefinition: RESOURCE = resourceName  RESOURCE 需使用 RDL 管理的数据源资源。  示例 Single Table Rule CREATE DEFAULT SINGLE TABLE RULE RESOURCE = ds_0 ALTER DEFAULT SINGLE TABLE RULE RESOURCE = ds_1 DROP DEFAULT SINGLE TABLE RULE </description>
    </item>
    
    <item>
      <title>单表</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/single-table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/single-table/</guid>
      <description>语法说明 SHOW SINGLE TABLE (tableRule | RULES) [FROM databaseName] SHOW SINGLE TABLES tableRule: RULE tableName 返回值说明 Single Table Rule    列 说明     name 规则名称   resource_name 数据源名称    Single Table    列 说明     table_name 单表名称   resource_name 单表所在的数据源名称    示例 single table rules
sql&amp;gt; show single table rules; +---------+---------------+ | name | resource_name | +---------+---------------+ | default | ds_1 | +---------+---------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>属性配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/props/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/props/</guid>
      <description>简介 Apache ShardingSphere 提供属性配置的方式配置系统级配置。
配置项说明    名称 数据类型 说明 默认值 动态生效     sql-show (?) boolean 是否在日志中打印 SQL。 打印 SQL 可以帮助开发者快速定位系统问题。日志内容包含：逻辑 SQL，真实 SQL 和 SQL 解析结果。
如果开启配置，日志将使用 Topic ShardingSphere-SQL，日志级别是 INFO。 false 是   sql-simple (?) boolean 是否在日志中打印简单风格的 SQL。 false 是   kernel-executor-size (?) int 用于设置任务处理线程池的大小。每个 ShardingSphereDataSource 使用一个独立的线程池，同一个 JVM 的不同数据源不共享线程池。 infinite 否   max-connections-size-per-query (?) int 一次查询请求在每个数据库实例中所能使用的最大连接数。 1 是   check-table-metadata-enabled (?) boolean 在程序启动和更新时，是否检查分片元数据的结构一致性。 false 是   proxy-frontend-flush-threshold (?</description>
    </item>
    
    <item>
      <title>应用性能监控集成</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/observability/apm-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/observability/apm-integration/</guid>
      <description>使用方法 使用 OpenTracing 协议  方法1：通过读取系统参数注入 APM 系统提供的 Tracer 实现类  启动时添加参数
-Dorg.apache.shardingsphere.tracing.opentracing.tracer.class=org.apache.skywalking.apm.toolkit.opentracing.SkywalkingTracer 调用初始化方法
ShardingTracer.init();  方法2：通过参数注入 APM 系统提供的 Tracer 实现类。  ShardingTracer.init(new SkywalkingTracer()); 注意：使用 SkyWalking 的 OpenTracing 探针时，不能同时使用 Apache ShardingSphere Agent 的 OpenTracing 插件，以防止两种插件互相冲突。
使用 SkyWalking 自动探针 请参考 SkyWalking 部署手册。
使用 OpenTelemetry 在 agent.yaml 中填写好配置即可，例如将 Traces 数据导出到 Zipkin。
OpenTelemetry: props: otel.resource.attributes: &amp;#34;service.name=shardingsphere-agent&amp;#34; otel.traces.exporter: &amp;#34;zipkin&amp;#34; otel.exporter.zipkin.endpoint: &amp;#34;http://127.0.0.1:9411/api/v2/spans&amp;#34; 效果展示 无论使用哪种方式，都可以方便的将 APM 信息展示在对接的系统中，以下以 SkyWalking 为例。
应用架构 使用 ShardingSphere-Proxy 访问两个数据库 192.168.0.1:3306 和 192.168.0.2:3306，且每个数据库中有两个分表。</description>
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/data-source/</guid>
      <description>ShardingSphere-JDBC 支持所有的数据库 JDBC 驱动和连接池。
配置示例 示例的数据库驱动为 MySQL，连接池为 HikariCP，可以更换为其他数据库驱动和连接池。当使用 ShardingSphere JDBC 时，JDBC 池的属性名取决于各自 JDBC 池自己的定义，并不由 ShardingSphere 硬定义，相关的处理可以参考类org.apache.shardingsphere.infra.datasource.pool.creator.DataSourcePoolCreator。
Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(); // 配置第 1 个数据源 HikariDataSource dataSource1 = new HikariDataSource(); dataSource1.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource1.setJdbcUrl(&amp;#34;jdbc:mysql://localhost:3306/ds_1&amp;#34;); dataSource1.setUsername(&amp;#34;root&amp;#34;); dataSource1.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds_1&amp;#34;, dataSource1); // 配置第 2 个数据源 HikariDataSource dataSource2 = new HikariDataSource(); dataSource2.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource2.setJdbcUrl(&amp;#34;jdbc:mysql://localhost:3306/ds_2&amp;#34;); dataSource2.setUsername(&amp;#34;root&amp;#34;); dataSource2.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds_2&amp;#34;, dataSource2); // 配置其他数据源 ... </description>
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/data-source/</guid>
      <description>使用本地数据源 配置项说明 spring.shardingsphere.datasource.names= # 真实数据源名称，多个数据源用逗号区分 # &amp;lt;actual-data-source-name&amp;gt; 表示真实数据源名称 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.type= # 数据库连接池全类名 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.driver-class-name= # 数据库驱动类名，以数据库连接池自身配置为准 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.jdbc-url= # 数据库 URL 连接，以数据库连接池自身配置为准 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.username= # 数据库用户名，以数据库连接池自身配置为准 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.password= # 数据库密码，以数据库连接池自身配置为准 spring.shardingsphere.datasource.&amp;lt;actual-data-source-name&amp;gt;.&amp;lt;xxx&amp;gt;= # ... 数据库连接池的其它属性 配置示例 示例的数据库驱动为 MySQL，连接池为 HikariCP，可以更换为其他数据库驱动和连接池。当使用 ShardingSphere JDBC 时，JDBC 池的属性名取决于各自 JDBC 池自己的定义，并不由 ShardingSphere 硬定义，相关的处理可以参考类org.apache.shardingsphere.infra.datasource.pool.creator.DataSourcePoolCreator。例如对于 Alibaba Druid 1.2.9 而言，使用url代替如下示例中的jdbc-url是预期行为。
# 配置真实数据源 spring.shardingsphere.datasource.names=ds1,ds2 # 配置第 1 个数据源 spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://localhost:3306/ds1 spring.shardingsphere.datasource.ds1.username=root spring.shardingsphere.datasource.ds1.password= # 配置第 2 个数据源 spring.shardingsphere.datasource.ds2.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds2.driver-class-name=com.mysql.jdbc.Driver spring.shardingsphere.datasource.ds2.jdbc-url=jdbc:mysql://localhost:3306/ds2 spring.shardingsphere.datasource.ds2.username=root spring.shardingsphere.datasource.ds2.password= 使用 JNDI 数据源 如果计划使用 JNDI 配置数据库，在应用容器（如 Tomcat）中使用 ShardingSphere-JDBC 时， 可使用 spring.</description>
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/data-source/</guid>
      <description>任何配置成为 Spring Bean 的数据源对象即可与 ShardingSphere-JDBC 的 Spring 命名空间配合使用。
配置示例 示例的数据库驱动为 MySQL，连接池为 HikariCP，可以更换为其他数据库驱动和连接池。当使用 ShardingSphere JDBC 时，JDBC 池的属性名取决于各自 JDBC 池自己的定义，并不由 ShardingSphere 硬定义，相关的处理可以参考类org.apache.shardingsphere.infra.datasource.pool.creator.DataSourcePoolCreator。例如对于 Alibaba Druid 1.2.9 而言，使用url代替如下示例中的jdbcUrl是预期行为。
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:shardingsphere=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/datasource&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/datasource http://shardingsphere.apache.org/schema/shardingsphere/datasource/datasource.xsd &amp;#34;&amp;gt; &amp;lt;bean id=&amp;#34;ds1&amp;#34; class=&amp;#34;com.zaxxer.hikari.HikariDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;jdbcUrl&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/ds1&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;ds2&amp;#34; class=&amp;#34;com.zaxxer.hikari.HikariDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;jdbcUrl&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/ds2&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;shardingsphere:data-source id=&amp;#34;ds&amp;#34; database-name=&amp;#34;foo_schema&amp;#34; data-source-names=&amp;#34;ds1,ds2&amp;#34; rule-refs=&amp;#34;.</description>
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/</guid>
      <description>数据源配置分为单数据源配置和多数据源配置。ShardingSphere-JDBC 支持所有的数据库 JDBC 驱动和连接池。
示例的数据库驱动为 MySQL，连接池为 HikariCP，可以更换为其他数据库驱动和连接池。当使用 ShardingSphere JDBC 时，JDBC 池的属性名取决于各自 JDBC 池自己的定义，并不由 ShardingSphere 硬定义，相关的处理可以参考类org.apache.shardingsphere.infra.datasource.pool.creator.DataSourcePoolCreator。例如对于 Alibaba Druid 1.2.9 而言，使用url代替如下示例中的jdbcUrl是预期行为。
配置项说明 dataSources: # 数据源配置，可配置多个 &amp;lt;data-source-name&amp;gt; &amp;lt;data-source-name&amp;gt;: # 数据源名称 dataSourceClassName: # 数据源完整类名 driverClassName: # 数据库驱动类名，以数据库连接池自身配置为准 jdbcUrl: # 数据库 URL 连接，以数据库连接池自身配置为准 username: # 数据库用户名，以数据库连接池自身配置为准 password: # 数据库密码，以数据库连接池自身配置为准 # ... 数据库连接池的其它属性 配置示例 dataSources: ds_1: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/ds_1 username: root password: ds_2: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/ds_2 username: root password: # 配置其他数据源 </description>
    </item>
    
    <item>
      <title>数据节点</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/datanode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/datanode/</guid>
      <description>数据分片的最小单元，由数据源名称和真实表组成。 例：ds_0.t_order_0。
逻辑表与真实表的映射关系，可分为均匀分布和自定义分布两种形式。
均匀分布 指数据表在每个数据源内呈现均匀分布的态势， 例如：
db0 ├── t_order0 └── t_order1 db1 ├── t_order0 └── t_order1 数据节点的配置如下：
db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1 自定义分布 指数据表呈现有特定规则的分布， 例如：
db0 ├── t_order0 └── t_order1 db1 ├── t_order2 ├── t_order3 └── t_order4 数据节点的配置如下：
db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4 </description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.readwritesplitting.api.ReadwriteSplittingRuleConfiguration
可配置属性：
   名称 数据类型 说明     dataSources (+) Collection&amp;lt;ReadwriteSplittingDataSourceRuleConfiguration&amp;gt; 读写数据源配置   loadBalancers (*) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 从库负载均衡算法配置    主从数据源配置 类名称：org.apache.shardingsphere.readwritesplitting.api.rule.ReadwriteSplittingDataSourceRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     name String 读写分离数据源名称 -   type String 读写分离类型，分为静态和动态。如 Static、Dynamic -   props Properties 读写分离所需属性，如静态：write-data-source-name、read-data-source-names，动态：auto-aware-data-source-name -   loadBalancerName (?) String 读库负载均衡算法名称 轮询负载均衡算法    算法类型的详情，请参见内置负载均衡算法列表。 查询一致性路由的详情，请参见使用规范。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/readwrite-splitting/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册 spring.shardingsphere.rules.readwrite-splitting.data-sources.&amp;lt;readwrite-splitting-data-source-name&amp;gt;.type= # 读写分离类型，如: Static，Dynamic spring.shardingsphere.rules.readwrite-splitting.data-sources.&amp;lt;readwrite-splitting-data-source-name&amp;gt;.props.auto-aware-data-source-name= # 自动发现数据源名称（与数据库发现配合使用） spring.shardingsphere.rules.readwrite-splitting.data-sources.&amp;lt;readwrite-splitting-data-source-name&amp;gt;.props.write-data-source-name= # 写数据源名称 spring.shardingsphere.rules.readwrite-splitting.data-sources.&amp;lt;readwrite-splitting-data-source-name&amp;gt;.props.read-data-source-names= # 读数据源名称，多个从数据源用逗号分隔 spring.shardingsphere.rules.readwrite-splitting.data-sources.&amp;lt;readwrite-splitting-data-source-name&amp;gt;.load-balancer-name= # 负载均衡算法名称 # 负载均衡算法配置 spring.shardingsphere.rules.readwrite-splitting.load-balancers.&amp;lt;load-balance-algorithm-name&amp;gt;.type= # 负载均衡算法类型 spring.shardingsphere.rules.readwrite-splitting.load-balancers.&amp;lt;load-balance-algorithm-name&amp;gt;.props.xxx= # 负载均衡算法属性配置 算法类型的详情，请参见内置负载均衡算法列表。 查询一致性路由的详情，请参见使用规范。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/readwrite-splitting/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/readwrite-splitting/readwrite-splitting-5.1.2.xsd
&amp;lt;readwrite-splitting:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   data-source-rule (+) 标签 读写分离数据源规则配置    &amp;lt;readwrite-splitting:data-source-rule /&amp;gt;
   名称 类型 说明     id 属性 读写分离数据源规则名称   type 属性 读写分离类型，分为静态和动态。如 Static、Dynamic   props 标签 读写分离所需属性，如静态：write-data-source-name、read-data-source-names，动态：auto-aware-data-source-name   load-balance-algorithm-ref 属性 负载均衡算法名称    &amp;lt;readwrite-splitting:load-balance-algorithm /&amp;gt;
   名称 类型 说明     id 属性 负载均衡算法名称   type 属性 负载均衡算法类型   props (?</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/readwrite-splitting/</guid>
      <description>配置项说明 rules: - !READWRITE_SPLITTING dataSources: &amp;lt;data-source-name&amp;gt; (+): # 读写分离逻辑数据源名称 type: # 读写分离类型，比如：Static，Dynamic props: auto-aware-data-source-name: # 自动发现数据源名称（与数据库发现配合使用） write-data-source-name: # 写库数据源名称 read-data-source-names: # 读库数据源名称，多个从数据源用逗号分隔 loadBalancerName: # 负载均衡算法名称 # 负载均衡算法配置 loadBalancers: &amp;lt;load-balancer-name&amp;gt; (+): # 负载均衡算法名称 type: # 负载均衡算法类型 props: # 负载均衡算法属性配置 # ... 算法类型的详情，请参见内置负载均衡算法列表。 查询一致性路由的详情，请参见使用规范。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/readwirte-splitting-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/readwirte-splitting-rule/</guid>
      <description>资源操作 ADD RESOURCE write_ds ( HOST=127.0.0.1, PORT=3306, DB=ds_0, USER=root, PASSWORD=root ),read_ds ( HOST=127.0.0.1, PORT=3307, DB=ds_0, USER=root, PASSWORD=root ); 规则操作  创建读写分离规则  CREATE READWRITE_SPLITTING RULE group_0 ( WRITE_RESOURCE=write_ds, READ_RESOURCES(read_ds), TYPE(NAME=random) );  修改读写分离规则  ALTER READWRITE_SPLITTING RULE group_0 ( WRITE_RESOURCE=write_ds, READ_RESOURCES(read_ds), TYPE(NAME=random,PROPERTIES(read_weight=&amp;#39;2:0&amp;#39;)) );  删除读写分离规则  DROP READWRITE_SPLITTING RULE group_0;  删除数据源  DROP RESOURCE write_ds,read_ds;  删除分布式数据库  DROP DATABASE readwrite_splitting_db; </description>
    </item>
    
    <item>
      <title>路由引擎</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/route/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/route/</guid>
      <description>根据解析上下文匹配数据库和表的分片策略，并生成路由路径。 对于携带分片键的 SQL，根据分片键的不同可以划分为单片路由（分片键的操作符是等号）、多片路由（分片键的操作符是 IN）和范围路由（分片键的操作符是 BETWEEN）。 不携带分片键的 SQL 则采用广播路由。
分片策略通常可以采用由数据库内置或由用户方配置。 数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等。 由用户方配置的分片策略则更加灵活，可以根据使用方需求定制复合分片策略。 如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可，进而做到使分布式数据库具有的弹性伸缩的能力。 在 ShardingSphere 的线路规划中，弹性伸缩将于 4.x 开启。
分片路由 用于根据分片键进行路由的场景，又细分为直接路由、标准路由和笛卡尔积路由这 3 种类型。
直接路由 满足直接路由的条件相对苛刻，它需要通过 Hint（使用 HintAPI 直接指定路由至库表）方式分片，并且是只分库不分表的前提下，则可以避免 SQL 解析和之后的结果归并。 因此它的兼容性最好，可以执行包括子查询、自定义函数等复杂情况的任意 SQL。直接路由还可以用于分片键不在 SQL 中的场景。例如，设置用于数据库分片的键为 3，
hintManager.setDatabaseShardingValue(3); 假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：
String sql = &amp;#34;SELECT * FROM t_order&amp;#34;; try ( HintManager hintManager = HintManager.getInstance(); Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.</description>
    </item>
    
    <item>
      <title>配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/configuration/</guid>
      <description>RuleBuilder    SPI 名称 详细说明     RuleBuilder 用于将用户配置转化为规则对象       已知实现类 详细说明     AlgorithmProvidedReadwriteSplittingRuleBuilder 用于将基于算法的读写分离用户配置转化为读写分离规则对象   AlgorithmProvidedDatabaseDiscoveryRuleBuilder 用于将基于算法的数据库发现用户配置转化为数据库发现规则对象   AlgorithmProvidedShardingRuleBuilder 用于将基于算法的分片用户配置转化为分片规则对象   AlgorithmProvidedEncryptRuleBuilder 用于将基于算法的加密用户配置转化为加密规则对象   AlgorithmProvidedShadowRuleBuilder 用于将基于算法的影子库用户配置转化为影子库规则对象   ReadwriteSplittingRuleBuilder 用于将读写分离用户配置转化为读写分离规则对象   DatabaseDiscoveryRuleBuilder 用于将数据库发现用户配置转化为数据库发现规则对象   SingleTableRuleBuilder 用于将单表用户配置转化为单表规则对象   AuthorityRuleBuilder 用于将权限用户配置转化为权限规则对象   ShardingRuleBuilder 用于将分片用户配置转化为分片规则对象   EncryptRuleBuilder 用于将加密用户配置转化为加密规则对象   ShadowRuleBuilder 用于将影子库用户配置转化为影子库规则对象   TransactionRuleBuilder 用于将事务用户配置转化为事务规则对象   SQLParserRuleBuilder 用于将 SQL 解析用户配置转化为 SQL 解析规则对象    YamlRuleConfigurationSwapper    SPI 名称 详细说明     YamlRuleConfigurationSwapper 用于将 YAML 配置转化为标准用户配置       已知实现类 详细说明     ReadwriteSplittingRuleAlgorithmProviderConfigurationYamlSwapper 用于将基于算法的读写分离配置转化为读写分离标准配置   DatabaseDiscoveryRuleAlgorithmProviderConfigurationYamlSwapper 用于将基于算法的数据库发现配置转化为数据库发现标准配置   ShardingRuleAlgorithmProviderConfigurationYamlSwapper 用于将基于算法的分片配置转化为分片标准配置   EncryptRuleAlgorithmProviderConfigurationYamlSwapper 用于将基于算法的加密配置转化为加密标准配置   ShadowRuleAlgorithmProviderConfigurationYamlSwapper 用于将基于算法的影子库配置转化为影子库标准配置   ReadwriteSplittingRuleConfigurationYamlSwapper 用于将读写分离的 YAML 配置转化为读写分离标准配置   DatabaseDiscoveryRuleConfigurationYamlSwapper 用于将数据库发现的 YAML 配置转化为数据库发现标准配置   AuthorityRuleConfigurationYamlSwapper 用于将权限规则的 YAML 配置转化为权限规则标准配置   ShardingRuleConfigurationYamlSwapper 用于将分片的 YAML 配置转化为分片标准配置   EncryptRuleConfigurationYamlSwapper 用于将加密的 YAML 配置转化为加密标准配置   ShadowRuleConfigurationYamlSwapper 用于将影子库的 YAML 配置转化为影子库标准配置   TransactionRuleConfigurationYamlSwapper 用于将事务的 YAML 配置转化为事务标准配置   SingleTableRuleConfigurationYamlSwapper 用于将单表的 YAML 配置转化为单表标准配置   SQLParserRuleConfigurationYamlSwapper 用于将 SQL 解析的 YAML 配置转化为 SQL 解析标准配置    ShardingSphereYamlConstruct    SPI 名称 详细说明     ShardingSphereYamlConstruct 用于将定制化对象和 YAML 相互转化       已知实现类 详细说明     NoneShardingStrategyConfigurationYamlConstruct 用于将不分片策略对象和 YAML 相互转化    </description>
    </item>
    
    <item>
      <title>CREATE DEFAULT SHARDING STRATEGY</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-default-sharding-strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-default-sharding-strategy/</guid>
      <description>描述 CREATE DEFAULT SHARDING STRATEGY 语法用于创建默认的分片策略
语法定义 CreateDefaultShardingStrategy ::= &amp;#39;CREATE&amp;#39; &amp;#39;DEFAULT&amp;#39; &amp;#39;SHARDING&amp;#39; (&amp;#39;DATABASE&amp;#39; | &amp;#39;TABLE&amp;#39;) &amp;#39;STRATEGY&amp;#39; &amp;#39;(&amp;#39; shardingStrategy &amp;#39;)&amp;#39; shardingStrategy ::= &amp;#39;TYPE&amp;#39; &amp;#39;=&amp;#39; strategyType &amp;#39;,&amp;#39; ( &amp;#39;SHARDING_COLUMN&amp;#39; &amp;#39;=&amp;#39; columnName | &amp;#39;SHARDING_COLUMNS&amp;#39; &amp;#39;=&amp;#39; columnNames ) &amp;#39;,&amp;#39; ( &amp;#39;SHARDING_ALGORITHM&amp;#39; &amp;#39;=&amp;#39; algorithmName | algorithmDefinition ) algorithmDefinition ::= &amp;#39;TYPE&amp;#39; &amp;#39;(&amp;#39; &amp;#39;NAME&amp;#39; &amp;#39;=&amp;#39; algorithmType ( &amp;#39;,&amp;#39; &amp;#39;PROPERTIES&amp;#39; &amp;#39;(&amp;#39; propertyDefinition &amp;#39;)&amp;#39; )?&amp;#39;)&amp;#39; columnNames ::= columnName (&amp;#39;,&amp;#39; columnName)+ columnName ::= identifier algorithmName ::= identifier algorithmType ::= identifier 补充说明  当使用复合分片算法时，需要通过 SHARDING_COLUMNS 指定多个分片键 algorithmType 为分片算法类型，详细的分片算法类型信息请参考分片算法  示例 1.</description>
    </item>
    
    <item>
      <title>SHOW SHARDING TABLE RULE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/rule-query/sharding/show-sharding-table-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/rule-query/sharding/show-sharding-table-rule/</guid>
      <description>描述 SHOW SHARDING TABLE RULE 语法用于查询指定逻辑库中的分片规则。
语法 ShowShardingTableRule ::= &#39;SHOW&#39; &#39;SHARDING&#39; &#39;TABLE&#39; (&#39;RULE&#39; tableName | &#39;RULES&#39;) (&#39;FROM&#39; schemaName)? tableName ::= identifier schemaName ::= identifier 补充说明  未指定 schemaName 时，默认是当前使用的 SCHEMA。 如果也未使用 SCHEMA 则会提示 No database selected。  返回值说明    列 说明     table 逻辑表名   actual_data_nodes 实际的数据节点   actual_data_sources 实际的数据源（通过 RDL 创建的规则时显示）   database_strategy_type 数据库分片策略类型   database_sharding_column 数据库分片键   database_sharding_algorithm_type 数据库分片算法类型   database_sharding_algorithm_props 数据库分片算法参数   table_strategy_type 表分片策略类型   table_sharding_column 表分片键   table_sharding_algorithm_type 表分片算法类型   table_sharding_algorithm_props 表分片算法参数   key_generate_column 分布式主键生成列   key_generator_type 分布式主键生成器类型   key_generator_props 分布式主键生成器参数    示例  查询指定逻辑库的分片规则  SHOW SHARDING TABLE RULES FROM sharding_db; +--------------+-------------------+---------------------+------------------------+--------------------------+----------------------------------+-----------------------------------+---------------------+-----------------------+-------------------------------+--------------------------------+---------------------+--------------------+---------------------+ | table | actual_data_nodes | actual_data_sources | database_strategy_type | database_sharding_column | database_sharding_algorithm_type | database_sharding_algorithm_props | table_strategy_type | table_sharding_column | table_sharding_algorithm_type | table_sharding_algorithm_props | key_generate_column | key_generator_type | key_generator_props | +--------------+-------------------+---------------------+------------------------+--------------------------+----------------------------------+-----------------------------------+---------------------+-----------------------+-------------------------------+--------------------------------+---------------------+--------------------+---------------------+ | t_order | | ds_0,ds_1 | | | | | mod | order_id | mod | sharding-count=4 | | | | | t_order_item | | ds_0,ds_1 | | | | | mod | order_id | mod | sharding-count=4 | | | | +--------------+-------------------+---------------------+------------------------+--------------------------+----------------------------------+-----------------------------------+---------------------+-----------------------+-------------------------------+--------------------------------+---------------------+--------------------+---------------------+ 2 rows in set (0.</description>
    </item>
    
    <item>
      <title>SHOW UNUSED RESOURCE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/resource-query/show-unused-resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rql/resource-query/show-unused-resource/</guid>
      <description>描述 SHOW UNUSED RESOURCE 语法用于查询指定逻辑库中还未被规则引用的资源。
语法 ShowUnusedResource ::= &amp;#39;SHOW&amp;#39; &amp;#39;UNUSED&amp;#39; &amp;#39;SCHEMA&amp;#39;? &amp;#39;RESOURCES&amp;#39; (&amp;#39;FROM&amp;#39; schemaName)? schemaName ::= identifier 特别说明  未指定 schemaName 时，默认是当前使用的 SCHEMA； 如未使用 SCHEMA 则会提示 No database selected。  返回值说明    列 说明     name 数据源名称   type 数据源类型   host 数据源地址   port 数据源端口   db 数据库名称   attribute 数据源参数    示例  查询指定逻辑库的资源  SHOW UNUSED SCHEMA RESOURCES FROM sharding_db; +------+-------+-----------+------+------+---------------------------------+---------------------------+---------------------------+---------------+---------------+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | name | type | host | port | db | connection_timeout_milliseconds | idle_timeout_milliseconds | max_lifetime_milliseconds | max_pool_size | min_pool_size | read_only | other_attributes | +------+-------+-----------+------+------+---------------------------------+---------------------------+---------------------------+---------------+---------------+-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | ds_0 | MySQL | 127.</description>
    </item>
    
    <item>
      <title>Spring 命名空间配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/spring-namespace-configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/spring-namespace-configuration/</guid>
      <description>ShardingSphere-5.0.0-beta 数据分片 配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding-5.0.0.xsd
&amp;lt;sharding:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   table-rules (?) 标签 分片表规则配置   auto-table-rules (?) 标签 自动化分片表规则配置   binding-table-rules (?) 标签 绑定表规则配置   broadcast-table-rules (?) 标签 广播表规则配置   default-database-strategy-ref (?) 属性 默认分库策略名称   default-table-strategy-ref (?) 属性 默认分表策略名称   default-key-generate-strategy-ref (?) 属性 默认分布式序列策略名称    &amp;lt;sharding:table-rules /&amp;gt;
   名称 类型 说明     table-rule (+) 标签 分片表规则配置    &amp;lt;sharding:table-rule /&amp;gt;</description>
    </item>
    
    <item>
      <title>SQLServer</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/sqlserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/sqlserver/</guid>
      <description>SQLServer 不支持的 SQL 清单如下：
TODO</description>
    </item>
    
    <item>
      <title>SQLServer</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/sqlserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/sqlserver/</guid>
      <description>SQLServer 不支持的 SQL 清单如下：
TODO
源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-sqlserver</description>
    </item>
    
    <item>
      <title>使用 Helm</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/helm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/startup/helm/</guid>
      <description>使用 Helm 在 Kubernetes 集群中引导 ShardingSphere-Proxy 实例进行安装。
快速入门 helm repo add shardingsphere https://shardingsphere.apache.org/charts helm install shardingsphere-proxy shardingsphere/apache-shardingsphere-proxy 操作步骤 必要条件   kubernetes 1.18+
  kubectl
  helm 3.2.0+
  可以动态申请 PV(Persistent Volumes) 的 StorageClass 已持久化数据。
安装 在线安装 将 ShardingSphere-Proxy 添加到 Helm 本地仓库：
helm repo add shardingsphere https://shardingsphere.apache.org/charts 以 ShardingSphere-Proxy 命名安装 charts：
helm install shardingsphere-proxy shardingsphere/apache-shardingsphere-proxy 源码安装 cd apache-shardingsphere-proxy/charts/governance helm dependency build cd ../.. helm dependency build cd .</description>
    </item>
    
    <item>
      <title>使用 Spring 命名空间</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/spring-namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/spring-namespace/</guid>
      <description>引入 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core-spring-namespace&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 BASE 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-base-seata-at&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置事务管理器 &amp;lt;!-- ShardingDataSource 的相关配置 --&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;bean id=&amp;#34;transactionManager&amp;#34; class=&amp;#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;shardingDataSource&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;jdbcTemplate&amp;#34; class=&amp;#34;org.springframework.jdbc.core.JdbcTemplate&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;shardingDataSource&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;tx:annotation-driven /&amp;gt; &amp;lt;!-- 开启自动扫描 @ShardingSphereTransactionType 注解，使用 Spring 原生的 AOP 在类和方法上进行增强 --&amp;gt; &amp;lt;sharding:tx-type-annotation-driven /&amp;gt; 使用分布式事务 @Transactional @ShardingSphereTransactionType(TransactionType.XA) // 支持TransactionType.LOCAL, TransactionType.</description>
    </item>
    
    <item>
      <title>保留字</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/reserved-word/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/reserved-word/</guid>
      <description>资源定义 ADD, DROP, RESOURCE, IF, EXISTS, HOST, PORT, DB, USER, PASSWORD, PROPERTIES, URL 规则定义 SHARDING CREATE, SHARDING, TABLE, RULE, ALGORITHM, DATANODES, DATABASE_STRATEGY, TABLE_STRATEGY, KEY_GENERATE_STRATEGY, RESOURCES, SHARDING_COLUMN, TYPE, SHARDING_COLUMN, KEY_GENERATOR, SHARDING_ALGORITHM, COLUMN, NAME, PROPERTIES 补充说明  上述保留字大小写不敏感  </description>
    </item>
    
    <item>
      <title>内核</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/kernel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/kernel/</guid>
      <description>SQLRouter    SPI 名称 详细说明     SQLRouter 用于处理路由结果       已知实现类 详细说明     ReadwriteSplittingSQLRouter 用于处理读写分离路由结果   DatabaseDiscoverySQLRouter 用于处理数据库发现路由结果   SingleTableSQLRouter 用于处理单表路由结果   ShardingSQLRouter 用于处理分片路由结果   ShadowSQLRouter 用于处理影子库路由结果    SQLRewriteContextDecorator    SPI 名称 详细说明     SQLRewriteContextDecorator 用于处理 SQL 改写结果       已知实现类 详细说明     ShardingSQLRewriteContextDecorator 用于处理分片 SQL 改写结果   EncryptSQLRewriteContextDecorator 用于处理加密 SQL 改写结果    SQLExecutionHook    SPI 名称 详细说明     SQLExecutionHook SQL 执行过程监听器       已知实现类 详细说明     TransactionalSQLExecutionHook 基于事务的 SQL 执行过程监听器    ResultProcessEngine    SPI 名称 详细说明     ResultProcessEngine 用于处理结果集       已知实现类 详细说明     ShardingResultMergerEngine 用于处理分片结果集归并   EncryptResultDecoratorEngine 用于处理加密结果集改写    StoragePrivilegeHandler    SPI 名称 详细说明     StoragePrivilegeHandler 使用数据库方言处理权限信息       已知实现类 详细说明     PostgreSQLPrivilegeHandler 使用 PostgreSQL 方言处理权限信息   SQLServerPrivilegeHandler 使用 SQLServer 方言处理权限信息   OraclePrivilegeHandler 使用 Oracle 方言处理权限信息   MySQLPrivilegeHandler 使用 MySQL 方言处理权限信息    DynamicDataSourceStrategy    SPI 名称 详细说明     DynamicDataSourceStrategy 动态数据源获取策略       已知实现类 详细说明     DatabaseDiscoveryDynamicDataSourceStrategy 使用数据库自动发现的功能获取动态数据源    </description>
    </item>
    
    <item>
      <title>分布式事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/transaction/</guid>
      <description>配置项说明 使用 LOCAL 事务 rules: - !TRANSACTION defaultType: LOCAL 使用 XA 事务 rules: - !TRANSACTION defaultType: XA providerType: Narayana </description>
    </item>
    
    <item>
      <title>分布式序列算法</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/keygen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/keygen/</guid>
      <description>雪花算法 类型：SNOWFLAKE
可配置属性：
   属性名称 数据类型 说明 默认值     max-vibration-offset (?) int 最大抖动上限值，范围[0, 4096)。注：若使用此算法生成值作分片值，建议配置此属性。此算法在不同毫秒内所生成的 key 取模 2^n (2^n一般为分库或分表数) 之后结果总为 0 或 1。为防止上述分片问题，建议将此属性值配置为 (2^n)-1 1   max-tolerate-time-difference-milliseconds (?) long 最大容忍时钟回退时间，单位：毫秒 10 毫秒    UUID 类型：UUID
可配置属性：无</description>
    </item>
    
    <item>
      <title>分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/sharding/</guid>
      <description>分片键 用于将数据库（表）水平拆分的数据库字段。 例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。
分片算法 用于将数据分片的算法，支持 =、&amp;gt;=、&amp;lt;=、&amp;gt;、&amp;lt;、BETWEEN 和 IN 进行分片。 分片算法可由开发者自行实现，也可使用 Apache ShardingSphere 内置的分片算法语法糖，灵活度非常高。
自动化分片算法 分片算法语法糖，用于便捷的托管所有数据节点，使用者无需关注真实表的物理分布。 包括取模、哈希、范围、时间等常用分片算法的实现。
自定义分片算法 提供接口让应用开发者自行实现与业务实现紧密相关的分片算法，并允许使用者自行管理真实表的物理分布。 自定义分片算法又分为：
 标准分片算法  用于处理使用单一键作为分片键的 =、IN、BETWEEN AND、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;= 进行分片的场景。
 复合分片算法  用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。
 Hint 分片算法  用于处理使用 Hint 行分片的场景。
分片策略 包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。 真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。
强制分片路由 对于分片字段并非由 SQL 而是其他外置条件决定的场景，可使用 SQL Hint 注入分片值。 例：按照员工登录主键分库，而数据库中并无此字段。 SQL Hint 支持通过 Java API 和 SQL 注释（待实现）两种方式使用。 详情请参见强制分片路由。</description>
    </item>
    
    <item>
      <title>改写引擎</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/rewrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/rewrite/</guid>
      <description>工程师面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。 它包括正确性改写和优化改写两部分。
正确性改写 在包含分表的场景中，需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。除此之外，还包括补列和分页信息修正等内容。
标识符改写 需要改写的标识符包括表名称、索引名称以及 Schema 名称。
表名称改写是指将找到逻辑表在原始 SQL 中的位置，并将其改写为真实表的过程。表名称改写是一个典型的需要对 SQL 进行解析的场景。 从一个最简单的例子开始，若逻辑 SQL 为：
SELECT order_id FROM t_order WHERE order_id=1; 假设该 SQL 配置分片键 order_id，并且 order_id=1 的情况，将路由至分片表 1。那么改写之后的 SQL 应该为：
SELECT order_id FROM t_order_1 WHERE order_id=1; 在这种最简单的 SQL 场景中，是否将 SQL 解析为抽象语法树似乎无关紧要，只要通过字符串查找和替换就可以达到 SQL 改写的效果。 但是下面的场景，就无法仅仅通过字符串的查找替换来正确的改写 SQL 了：
SELECT order_id FROM t_order WHERE order_id=1 AND remarks=&amp;#39; t_order xxx&amp;#39;; 正确改写的 SQL 应该是：
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=&amp;#39; t_order xxx&amp;#39;; 而非：</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/encrypt-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/encrypt-rule/</guid>
      <description>资源操作 ADD RESOURCE ds_0 ( HOST=127.0.0.1, PORT=3306, DB=ds_0, USER=root, PASSWORD=root ); 规则操作  创建加密规则  CREATE ENCRYPT RULE t_encrypt ( COLUMNS( (NAME=user_id,PLAIN=user_plain,CIPHER=user_cipher,TYPE(NAME=AES,PROPERTIES(&amp;#39;aes-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))), (NAME=order_id,PLAIN=order_plain,CIPHER =order_cipher,TYPE(NAME=RC4,PROPERTIES(&amp;#39;rc4-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))) ));  创建加密表  CREATE TABLE `t_encrypt` ( `id` int(11) NOT NULL, `user_id` varchar(45) DEFAULT NULL, `order_id` varchar(45) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  修改加密规则  ALTER ENCRYPT RULE t_encrypt ( COLUMNS( (NAME=user_id,PLAIN=user_plain,CIPHER=user_cipher,TYPE(NAME=AES,PROPERTIES(&amp;#39;aes-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))) ));  删除加密规则  DROP ENCRYPT RULE t_encrypt;  删除数据源  DROP RESOURCE ds_0;  删除分布式数据库  DROP DATABASE encrypt_db; </description>
    </item>
    
    <item>
      <title>柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/concept/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/concept/base/</guid>
      <description>柔性事务在 2008 年发表的一篇论文中被最早提到， 它提倡采用最终一致性放宽对强一致性的要求，以达到事务处理并发度的提升。
TCC 和 Saga 是两种常见实现方案。 他们主张开发者自行实现对数据库的反向操作，来达到数据在回滚时仍能够保证最终一致性。 SEATA 实现了 SQL 反向操作的自动生成，可以使柔性事务不再必须由开发者介入才能使用。
Apache ShardingSphere 集成了 SEATA 作为柔性事务的使用方案。</description>
    </item>
    
    <item>
      <title>柔性事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/transaction/use-norms/base/</guid>
      <description>支持项  支持数据分片后的跨库事务； 支持 RC 隔离级别； 通过 undo 快照进行事务回滚； 支持服务宕机后的，自动恢复提交中的事务。  不支持项  不支持除 RC 之外的隔离级别。  待优化项  Apache ShardingSphere 和 SEATA 重复 SQL 解析。  </description>
    </item>
    
    <item>
      <title>规则配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/rules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/yaml-config/rules/</guid>
      <description>ShardingSphere-Proxy 的规则配置与 ShardingSphere-JDBC 一致，请参考 ShardingSphere-JDBC 规则配置。</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/readwrite-splitting/</guid>
      <description>语法说明 CREATE READWRITE_SPLITTING RULE readwriteSplittingRuleDefinition [, readwriteSplittingRuleDefinition] ... ALTER READWRITE_SPLITTING RULE readwriteSplittingRuleDefinition [, readwriteSplittingRuleDefinition] ... DROP READWRITE_SPLITTING RULE ruleName [, ruleName] ... readwriteSplittingRuleDefinition: ruleName ([staticReadwriteSplittingRuleDefinition | dynamicReadwriteSplittingRuleDefinition] [, loadBanlancerDefinition]) staticReadwriteSplittingRuleDefinition: WRITE_RESOURCE=writeResourceName, READ_RESOURCES(resourceName [, resourceName] ... ) dynamicReadwriteSplittingRuleDefinition: AUTO_AWARE_RESOURCE=resourceName loadBanlancerDefinition: TYPE(NAME=loadBanlancerType [, PROPERTIES([algorithmProperties] )] ) algorithmProperties: algorithmProperty [, algorithmProperty] ... algorithmProperty: key=value  支持创建静态读写分离规则和动态读写分离规则； 动态读写分离规则依赖于数据库发现规则； loadBanlancerType 指定负载均衡算法类型，请参考 负载均衡算法； 重复的 ruleName 将无法被创建。  示例 // Static CREATE READWRITE_SPLITTING RULE ms_group_0 ( WRITE_RESOURCE=write_ds, READ_RESOURCES(read_ds_0,read_ds_1), TYPE(NAME=random) ); // Dynamic CREATE READWRITE_SPLITTING RULE ms_group_1 ( AUTO_AWARE_RESOURCE=group_0, TYPE(NAME=random,PROPERTIES(read_weight=&amp;#39;2:1&amp;#39;)) ); ALTER READWRITE_SPLITTING RULE ms_group_1 ( WRITE_RESOURCE=write_ds, READ_RESOURCES(read_ds_0,read_ds_1,read_ds_2), TYPE(NAME=random,PROPERTIES(read_weight=&amp;#39;2:0&amp;#39;)) ); DROP READWRITE_SPLITTING RULE ms_group_1; </description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/readwrite-splitting/</guid>
      <description>语法说明 SHOW READWRITE_SPLITTING RULES [FROM databaseName] 返回值说明    列 说明     name 规则名称   auto_aware_data_source_name 自动发现数据源名称（配置动态读写分离规则显示）   write_data_source_name 写数据源名称   read_data_source_names 读数据源名称列表   load_balancer_type 负载均衡算法类型   load_balancer_props 负载均衡算法参数    示例 静态读写分离规则
mysql&amp;gt; show readwrite_splitting rules; +------------+-----------------------------+------------------------+------------------------+--------------------+---------------------+ | name | auto_aware_data_source_name | write_data_source_name | read_data_source_names | load_balancer_type | load_balancer_props | +------------+-----------------------------+------------------------+------------------------+--------------------+---------------------+ | ms_group_0 | | ds_primary | ds_slave_0, ds_slave_1 | random | | +------------+-----------------------------+------------------------+------------------------+--------------------+---------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>高可用</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/ha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/ha/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.dbdiscovery.api.config.DatabaseDiscoveryRuleConfiguration
可配置属性：
   名称 数据类型 说明     dataSources (+) Collection&amp;lt;DatabaseDiscoveryDataSourceRuleConfiguration&amp;gt; 数据源配置   discoveryHeartbeats (+) Map&amp;lt;String, DatabaseDiscoveryHeartBeatConfiguration&amp;gt; 监听心跳配置   discoveryTypes (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 数据库发现类型配置    数据源配置 类名称：org.apache.shardingsphere.dbdiscovery.api.config.rule.DatabaseDiscoveryDataSourceRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     groupName (+) String 数据库发现组名称 -   dataSourceNames (+) Collection&amp;lt;String&amp;gt; 数据源名称，多个数据源用逗号分隔 如：ds_0, ds_1 -   discoveryHeartbeatName (+) String 监听心跳名称 -   discoveryTypeName (+) String 数据库发现类型名称 -    监听心跳配置 类名称：org.</description>
    </item>
    
    <item>
      <title>高可用</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/ha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/ha/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册 spring.shardingsphere.rules.database-discovery.data-sources.&amp;lt;database-discovery-data-source-name&amp;gt;.data-source-names= # 数据源名称，多个数据源用逗号分隔 如：ds_0, ds_1 spring.shardingsphere.rules.database-discovery.data-sources.&amp;lt;database-discovery-data-source-name&amp;gt;.discovery-heartbeat-name= # 检测心跳名称 spring.shardingsphere.rules.database-discovery.data-sources.&amp;lt;database-discovery-data-source-name&amp;gt;.discovery-type-name= # 数据库发现类型名称 spring.shardingsphere.rules.database-discovery.discovery-heartbeats.&amp;lt;discovery-heartbeat-name&amp;gt;.props.keep-alive-cron= # cron 表达式，如：&#39;0/5 * * * * ?&#39; spring.shardingsphere.rules.database-discovery.discovery-types.&amp;lt;discovery-type-name&amp;gt;.type= # 数据库发现类型，如：MySQL.MGR spring.shardingsphere.rules.database-discovery.discovery-types.&amp;lt;discovery-type-name&amp;gt;.props.group-name= # 数据库发现类型必要参数，如 MGR 的 group-name </description>
    </item>
    
    <item>
      <title>高可用</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/ha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/ha/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/database-discovery/database-discovery-5.1.2.xsd
&amp;lt;database-discovery:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   data-source-rule (+) 标签 数据源规则配置   discovery-heartbeat (+) 标签 检测心跳规则配置    &amp;lt;database-discovery:data-source-rule /&amp;gt;
   名称 类型 说明     id 属性 数据源规则名称   data-source-names 属性 数据源名称，多个数据源用逗号分隔 如：ds_0, ds_1   discovery-heartbeat-name 属性 检测心跳名称   discovery-type-name 属性 数据库发现类型名称    &amp;lt;database-discovery:discovery-heartbeat /&amp;gt;</description>
    </item>
    
    <item>
      <title>高可用</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/ha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/ha/</guid>
      <description>配置项说明 rules: - !DB_DISCOVERY dataSources: &amp;lt;data-source-name&amp;gt; (+): # 逻辑数据源名称 dataSourceNames: # 数据源名称列表 - &amp;lt;data-source&amp;gt; - &amp;lt;data-source&amp;gt; discoveryHeartbeatName: # 检测心跳名称 discoveryTypeName: # 数据库发现类型名称 # 心跳检测配置 discoveryHeartbeats: &amp;lt;discovery-heartbeat-name&amp;gt; (+): # 心跳名称 props: keep-alive-cron: # cron 表达式，如：&amp;#39;0/5 * * * * ?&amp;#39; # 数据库发现类型配置 discoveryTypes: &amp;lt;discovery-type-name&amp;gt; (+): # 数据库发现类型名称 type: # 数据库发现类型，如：MySQL.MGR  props (?): group-name: 92504d5b-6dec-11e8-91ea-246e9612aaf1 # 数据库发现类型必要参数，如 MGR 的 group-name </description>
    </item>
    
    <item>
      <title>Atomikos 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/atomikos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/atomikos/</guid>
      <description>Apache ShardingSphere 默认的 XA 事务管理器为 Atomikos。
数据恢复 在项目的 logs 目录中会生成 xa_tx.log, 这是 XA 崩溃恢复时所需的日志，请勿删除。
修改配置 可以通过在项目的 classpath 中添加 jta.properties 来定制化 Atomikos 配置项。
详情请参见 Atomikos 官方文档。</description>
    </item>
    
    <item>
      <title>CREATE SHARDING BINDING TABLE RULE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-binding-table-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-binding-table-rule/</guid>
      <description>描述 CREATE SHARDING BINDING TABLE RULE 语法用于为具有分片规则的表（分片表）添加绑定关系并创建绑定规则
语法定义 CreateBindingTableRule ::= &amp;#39;CREATE&amp;#39; &amp;#39;SHARDING&amp;#39; &amp;#39;BINDING&amp;#39; &amp;#39;TABLE&amp;#39; &amp;#39;RULES&amp;#39; bindingRelationshipDefinition (&amp;#39;,&amp;#39; bindingRelationshipDefinition )* bindingRelationshipDefinition ::= &amp;#39;(&amp;#39; tableName (&amp;#39;,&amp;#39; tableName)* &amp;#39;)&amp;#39; tableName ::= identifier 补充说明  只有分片表才能创建绑定关系 一个分片表只能具有一个绑定关系 添加绑定关系的分片表需要使用相同的资源，并且分片节点个数相同。例如 ds_${0..1}.t_order_${0..1} 与 ds_${0..1}.t_order_item_${0..1} 添加绑定关系的分片表需要对分片键使用相同的分片算法。例如 t_order_${order_id % 2} 与 t_order_item_${order_item_id % 2} 只能存在一个绑定规则，但可包含多个绑定关系，因此无法重复执行 CREATE SHARDING BINDING TABLE RULE 。当绑定规则已经存在但还需要添加绑定关系时，需要使用 ALTER SHARDING BINDING TABLE RULE 来修改绑定规则  示例 1.创建绑定关系 -- 创建绑定关系之前需要先创建分片表 t_order,t_order_item CREATE SHARDING BINDING TABLE RULES (t_order,t_order_item); 2.</description>
    </item>
    
    <item>
      <title>DROP RESOURCE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/resource-definition/drop-resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/resource-definition/drop-resource/</guid>
      <description>描述 DROP RESOURCE 语法用于从当前逻辑库中移除资源。
语法 DropResource ::= &amp;#39;DROP&amp;#39; &amp;#39;RESOURCE&amp;#39; ( &amp;#39;IF&amp;#39; &amp;#39;EXISTS&amp;#39; )? dataSourceName ( &amp;#39;,&amp;#39; dataSourceName )* ( &amp;#39;IGNORE&amp;#39; &amp;#39;SINGLE&amp;#39; &amp;#39;TABLES&amp;#39; )? 补充说明  DROP RESOURCE 只会移除 Proxy 中的资源，不会删除与资源对应的真实数据源 无法移除已经被规则使用的资源。移除被规则使用的资源时会提示 Resources are still in used. 将要移除的资源中仅包含 SINGLE TABLE RULE，且用户确认可以忽略该限制时，可添加 IGNORE SINGLE TABLES 关键字移除资源  示例  移除资源  DROP RESOURCE ds_0;  移除多个资源  DROP RESOURCE ds_1, ds_2;  忽略单表移除资源  DROP RESOURCE ds_3 IGNORE SINGLE TABLES;  如果资源存在则移除  DROP RESOURCE IF EXISTS ds_4; 保留字 DROP、 RESOURCE、 IF、 EXISTS、 IGNORE、 SINGLE、 TABLES  相关链接  保留字  </description>
    </item>
    
    <item>
      <title>Oracle</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/oracle/</guid>
      <description>Oracle 不支持的 SQL 清单如下：
TODO</description>
    </item>
    
    <item>
      <title>Oracle</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/oracle/</guid>
      <description>Oracle 不支持的 SQL 清单如下：
TODO
源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-oracle</description>
    </item>
    
    <item>
      <title>Spring Boot Start 配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/api-change-history/shardingsphere-jdbc/spring-boot-starter/</guid>
      <description>5.0.0-alpha 数据分片 配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置 # 标准分片表配置 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.actual-data-nodes= # 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况 # 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一 # 用于单分片键的标准分片场景 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-column= # 分片列名称 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.standard.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称 # 用于多分片键的复合分片场景 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-columns= # 分片列名称，多个列以逗号分隔 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.complex.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称 # 用于Hint 的分片策略 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.database-strategy.hint.&amp;lt;sharding-algorithm-name&amp;gt;.sharding-algorithm-name= # 分片算法名称 # 分表策略，同分库策略 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.table-strategy.xxx= # 省略 # 自动分片表配置 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.actual-data-sources= # 数据源名 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-column= # 分片列名称 spring.shardingsphere.rules.sharding.auto-tables.&amp;lt;auto-table-name&amp;gt;.sharding-strategy.standard.sharding-algorithm= # 自动分片算法名称 # 分布式序列策略配置 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.column= # 分布式序列列名称 spring.shardingsphere.rules.sharding.tables.&amp;lt;table-name&amp;gt;.key-generate-strategy.key-generator-name= # 分布式序列算法名称 spring.shardingsphere.rules.sharding.binding-tables[0]= # 绑定表规则列表 spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表规则列表 spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表规则列表 spring.</description>
    </item>
    
    <item>
      <title>执行引擎</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/execute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/execute/</guid>
      <description>ShardingSphere 采用一套自动化的执行引擎，负责将路由和改写完成之后的真实 SQL 安全且高效发送到底层数据源执行。 它不是简单地将 SQL 通过 JDBC 直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题。 执行引擎的目标是自动化的平衡资源控制与执行效率。
连接模式 从资源控制的角度看，业务方访问数据库的连接数量应当有所限制。 它能够有效地防止某一业务操作过多的占用资源，从而将数据库连接的资源耗尽，以致于影响其他业务的正常访问。 特别是在一个数据库实例中存在较多分表的情况下，一条不包含分片键的逻辑 SQL 将产生落在同库不同表的大量真实 SQL ，如果每条真实SQL都占用一个独立的连接，那么一次查询无疑将会占用过多的资源。
从执行效率的角度看，为每个分片查询维持一个独立的数据库连接，可以更加有效的利用多线程来提升执行效率。 为每个数据库连接开启独立的线程，可以将 I/O 所产生的消耗并行处理。为每个分片维持一个独立的数据库连接，还能够避免过早的将查询结果数据加载至内存。 独立的数据库连接，能够持有查询结果集游标位置的引用，在需要获取相应数据时移动游标即可。
以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有一个独立数据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。
一方面是对数据库连接资源的控制保护，一方面是采用更优的归并模式达到对中间件内存资源的节省，如何处理好两者之间的关系，是 ShardingSphere 执行引擎需要解决的问题。 具体来说，如果一条 SQL 在经过 ShardingSphere 的分片后，需要操作某数据库实例下的 200 张表。 那么，是选择创建 200 个连接并行执行，还是选择创建一个连接串行执行呢？效率与资源控制又应该如何抉择呢？
针对上述场景，ShardingSphere 提供了一种解决思路。 它提出了连接模式（Connection Mode）的概念，将其划分为内存限制模式（MEMORY_STRICTLY）和连接限制模式（CONNECTION_STRICTLY）这两种类型。
内存限制模式 使用此模式的前提是，ShardingSphere 对一次操作所耗费的数据库连接数量不做限制。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，则对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化。 并且在 SQL 满足条件情况下，优先选择流式归并，以防止出现内存溢出或避免频繁垃圾回收情况。
连接限制模式 使用此模式的前提是，ShardingSphere 严格控制对一次操作所耗费的数据库连接数量。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，那么只会创建唯一的数据库连接，并对其 200 张表串行处理。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。 这样即可以防止对一次请求对数据库连接占用过多所带来的问题。该模式始终选择内存归并。
内存限制模式适用于 OLAP 操作，可以通过放宽对数据库连接的限制提升系统吞吐量； 连接限制模式适用于 OLTP 操作，OLTP 通常带有分片键，会路由到单一的分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/encrypt/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.encrypt.api.config.EncryptRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     tables (+) Collection&amp;lt;EncryptTableRuleConfiguration&amp;gt; 加密表规则配置    encryptors (+) Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 加解密算法名称和配置    queryWithCipherColumn (?) boolean 是否使用加密列进行查询。在有原文列的情况下，可以使用原文列进行查询 true    加密表规则配置 类名称：org.apache.shardingsphere.encrypt.api.config.rule.EncryptTableRuleConfiguration
可配置属性：
   名称 数据类型 说明     name String 表名称   columns (+) Collection&amp;lt;EncryptColumnRuleConfiguration&amp;gt; 加密列规则配置列表   queryWithCipherColumn (?) boolean 该表是否使用加密列进行查询    加密列规则配置 类名称：org.apache.shardingsphere.encrypt.api.config.rule.EncryptColumnRuleConfiguration</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/encrypt/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册 spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.query-with-cipher-column= # 该表是否使用加密列进行查询 spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.cipher-column= # 加密列名称 spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.assisted-query-column= # 查询列名称 spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.plain-column= # 原文列名称 spring.shardingsphere.rules.encrypt.tables.&amp;lt;table-name&amp;gt;.columns.&amp;lt;column-name&amp;gt;.encryptor-name= # 加密算法名称 # 加密算法配置 spring.shardingsphere.rules.encrypt.encryptors.&amp;lt;encrypt-algorithm-name&amp;gt;.type= # 加密算法类型 spring.shardingsphere.rules.encrypt.encryptors.&amp;lt;encrypt-algorithm-name&amp;gt;.props.xxx= # 加密算法属性配置 spring.shardingsphere.rules.encrypt.queryWithCipherColumn= # 是否使用加密列进行查询。在有原文列的情况下，可以使用原文列进行查询 算法类型的详情，请参见内置加密算法列表。</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/encrypt/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt-5.1.2.xsd
&amp;lt;encrypt:rule /&amp;gt;
   名称 类型 说明 默认值     id 属性 Spring Bean Id    queryWithCipherColumn (?) 属性 是否使用加密列进行查询。在有原文列的情况下，可以使用原文列进行查询 true   table (+) 标签 加密表配置     &amp;lt;encrypt:table /&amp;gt;
   名称 类型 说明     name 属性 加密表名称   column (+) 标签 加密列配置   query-with-cipher-column(?) 属性 该表是否使用加密列进行查询。在有原文列的情况下，可以使用原文列进行查询    &amp;lt;encrypt:column /&amp;gt;
   名称 类型 说明     logic-column 属性 加密列逻辑名称   cipher-column 属性 加密列名称   assisted-query-column (?</description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/</guid>
      <description>配置项说明 rules: - !ENCRYPT tables: &amp;lt;table-name&amp;gt; (+): # 加密表名称 columns: &amp;lt;column-name&amp;gt; (+): # 加密列名称 cipherColumn: # 密文列名称 assistedQueryColumn (?): # 查询辅助列名称 plainColumn (?): # 原文列名称 encryptorName: # 加密算法名称 queryWithCipherColumn(?): # 该表是否使用加密列进行查询 # 加密算法配置 encryptors: &amp;lt;encrypt-algorithm-name&amp;gt; (+): # 加解密算法名称 type: # 加解密算法类型 props: # 加解密算法属性配置 # ... queryWithCipherColumn: # 是否使用加密列进行查询。在有原文列的情况下，可以使用原文列进行查询 算法类型的详情，请参见内置加密算法列表。</description>
    </item>
    
    <item>
      <title>数据库发现</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/db-discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/db-discovery/</guid>
      <description>语法说明 CREATE DB_DISCOVERY RULE ruleDefinition [, ruleDefinition] ... ALTER DB_DISCOVERY RULE ruleDefinition [, ruleDefinition] ... DROP DB_DISCOVERY RULE ruleName [, ruleName] ... CREATE DB_DISCOVERY TYPE databaseDiscoveryTypeDefinition [, databaseDiscoveryTypeDefinition] ... ALTER DB_DISCOVERY TYPE databaseDiscoveryTypeDefinition [, databaseDiscoveryTypeDefinition] ... DROP DB_DISCOVERY TYPE discoveryTypeName [, discoveryTypeName] ... CREATE DB_DISCOVERY HEARTBEAT databaseDiscoveryHeartbaetDefinition [, databaseDiscoveryHeartbaetDefinition] ... ALTER DB_DISCOVERY HEARTBEAT databaseDiscoveryHeartbaetDefinition [, databaseDiscoveryHeartbaetDefinition] ... DROP DB_DISCOVERY HEARTBEAT discoveryHeartbeatName [, discoveryHeartbeatName] ... ruleDefinition: (databaseDiscoveryRuleDefinition | databaseDiscoveryRuleConstruction) databaseDiscoveryRuleDefinition ruleName (resources, typeDefinition, heartbeatDefinition) databaseDiscoveryRuleConstruction ruleName (resources, TYPE = discoveryTypeName, HEARTBEAT = discoveryHeartbeatName) databaseDiscoveryTypeDefinition discoveryTypeName (typeDefinition) databaseDiscoveryHeartbaetDefinition discoveryHeartbeatName (PROPERTIES (properties)) resources: RESOURCES(resourceName [, resourceName] .</description>
    </item>
    
    <item>
      <title>数据库发现</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/db-discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/db-discovery/</guid>
      <description>语法说明 SHOW DB_DISCOVERY RULES [FROM databaseName] SHOW DB_DISCOVERY TYPES [FROM databaseName] SHOW DB_DISCOVERY HEARTBEATS [FROM databaseName] 返回值说明 DB Discovery Rule    列 说明     group_name 规则名称   data_source_names 数据源名称列表   primary_data_source_name 主数据源名称   discovery_type 数据库发现服务类型   discovery_heartbeat 数据库发现服务心跳    DB Discovery Type    列 说明     name 类型名称   type 类型种类   props 类型参数    DB Discovery Heartbeat    列 说明     name 心跳名称   props 心跳参数    示例 DB Discovery Rule</description>
    </item>
    
    <item>
      <title>数据源</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/data-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/data-source/</guid>
      <description>DatabaseType    SPI 名称 详细说明     DatabaseType 支持的数据库类型       已知实现类 详细说明     SQL92DatabaseType 遵循 SQL92 标准的数据库类型   MySQLDatabaseType MySQL 数据库   MariaDBDatabaseType MariaDB 数据库   PostgreSQLDatabaseType PostgreSQL 数据库   OracleDatabaseType Oracle 数据库   SQLServerDatabaseType SQLServer 数据库   H2DatabaseType H2 数据库   OpenGaussDatabaseType OpenGauss 数据库    DialectTableMetaDataLoader    SPI 名称 详细说明     DialectTableMetaDataLoader 用于使用数据库方言快速加载元数据       已知实现类 详细说明     MySQLTableMetaDataLoader 使用 MySQL 方言加载元数据   OracleTableMetaDataLoader 使用 Oracle 方言加载元数据   PostgreSQLTableMetaDataLoader 使用 PostgreSQL 方言加载元数据   SQLServerTableMetaDataLoader 使用 SQLServer 方言加载元数据   H2TableMetaDataLoader 使用 H2 方言加载元数据   OpenGaussTableMetaDataLoader 使用 OpenGauss 方言加载元数据    DataSourcePoolMetaData    SPI 名称 详细说明     DataSourcePoolMetaData 数据源连接池元数据       已知实现类 详细说明     DBCPDataSourcePoolMetaData DBCP 数据库连接池元数据   HikariDataSourcePoolMetaData Hikari 数据源连接池元数据    DataSourcePoolActiveDetector    SPI 名称 详细说明     DataSourcePoolActiveDetector 数据源连接池活跃探测器       已知实现类 详细说明     DefaultDataSourcePoolActiveDetector 默认数据源连接池活跃探测器   HikariDataSourcePoolActiveDetector Hikari 数据源连接池活跃探测器    </description>
    </item>
    
    <item>
      <title>行表达式</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/inline-expression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/inline-expression/</guid>
      <description>实现动机 配置的简化与一体化是行表达式所希望解决的两个主要问题。
在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。 通过行表达式可以有效地简化数据节点配置工作量。
对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。 通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
语法说明 行表达式的使用非常直观，只需要在配置中使用 ${ expression } 或 $-&amp;gt;{ expression } 标识行表达式即可。 目前支持数据节点和分片算法这两个部分的配置。 行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。 例如：
${begin..end} 表示范围区间
${[unit1, unit2, unit_x]} 表示枚举值
行表达式中如果出现连续多个 ${ expression } 或 $-&amp;gt;{ expression } 表达式，整个表达式最终的结果将会根据每个子表达式的结果进行笛卡尔组合。
例如，以下行表达式：
${[&amp;#39;online&amp;#39;, &amp;#39;offline&amp;#39;]}_table${1..3} 最终会解析为：
online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3 配置 数据节点 对于均匀分布的数据节点，如果数据结构如下：
db0 ├── t_order0 └── t_order1 db1 ├── t_order0 └── t_order1 用行表达式可以简化为：
db${0..1}.t_order${0..1} 或者：
db$-&amp;gt;{0..1}.t_order$-&amp;gt;{0..1} 对于自定义的数据节点，如果数据结构如下：
db0 ├── t_order0 └── t_order1 db1 ├── t_order2 ├── t_order3 └── t_order4 用行表达式可以简化为：</description>
    </item>
    
    <item>
      <title>负载均衡算法</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/load-balance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/load-balance/</guid>
      <description>轮询算法 类型：ROUND_ROBIN
可配置属性：无
随机访问算法 类型：RANDOM
可配置属性：无
权重访问算法 类型：WEIGHT
可配置属性：
 使用中的读库都必须配置权重
    属性名称 数据类型 说明     - &amp;lt;read-data_source-name&amp;gt; (+) double 属性名字使用读库名字，参数填写读库对应的权重值。权重参数范围最小值 &amp;gt; 0，合计 &amp;lt;= Double.MAX_VALUE。    </description>
    </item>
    
    <item>
      <title>CREATE SHARDING BROADCAST TABLE RULE</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-broadcast-table-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-broadcast-table-rule/</guid>
      <description>描述 CREATE SHARDING BROADCAST TABLE RULE 语法用于为需要广播的表（广播表）创建广播规则
语法定义 CreateDefaultShardingStrategy ::= &amp;#39;CREATE&amp;#39; &amp;#39;DEFAULT&amp;#39; &amp;#39;SHARDING&amp;#39; (&amp;#39;DATABASE&amp;#39; | &amp;#39;TABLE&amp;#39;) &amp;#39;STRATEGY&amp;#39; &amp;#39;(&amp;#39; shardingStrategy &amp;#39;)&amp;#39; shardingStrategy ::= &amp;#39;TYPE&amp;#39; &amp;#39;=&amp;#39; strategyType &amp;#39;,&amp;#39; ( &amp;#39;SHARDING_COLUMN&amp;#39; &amp;#39;=&amp;#39; columnName | &amp;#39;SHARDING_COLUMNS&amp;#39; &amp;#39;=&amp;#39; columnNames ) &amp;#39;,&amp;#39; ( &amp;#39;SHARDING_ALGORITHM&amp;#39; &amp;#39;=&amp;#39; algorithmName | algorithmDefinition ) algorithmDefinition ::= &amp;#39;TYPE&amp;#39; &amp;#39;(&amp;#39; &amp;#39;NAME&amp;#39; &amp;#39;=&amp;#39; algorithmType ( &amp;#39;,&amp;#39; &amp;#39;PROPERTIES&amp;#39; &amp;#39;(&amp;#39; propertyDefinition &amp;#39;)&amp;#39; )?&amp;#39;)&amp;#39; columnNames ::= columnName (&amp;#39;,&amp;#39; columnName)+ columnName ::= identifier algorithmName ::= identifier algorithmType ::= identifier 补充说明  tableName 可使用已经存在的表或者将要创建的表 只能存在一个广播规则，但可包含多个广播表，因此无法重复执行 CREATE SHARDING BROADCAST TABLE RULE。当广播规则已经存在但还需要添加广播表时，需要使用 ALTER BROADCAST TABLE RULE 来修改广播规则  示例 创建广播规则 -- 将 t_province， t_city 添加到广播规则中 CREATE SHARDING BROADCAST TABLE RULES (t_province, t_city); </description>
    </item>
    
    <item>
      <title>Narayana 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/narayana/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/narayana/</guid>
      <description>引入 Maven 依赖 &amp;lt;properties&amp;gt; &amp;lt;narayana.version&amp;gt;5.9.1.Final&amp;lt;/narayana.version&amp;gt; &amp;lt;jboss-transaction-spi.version&amp;gt;7.6.0.Final&amp;lt;/jboss-transaction-spi.version&amp;gt; &amp;lt;jboss-logging.version&amp;gt;3.2.1.Final&amp;lt;/jboss-logging.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-narayana&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.narayana.jta&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jta&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${narayana.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.narayana.jts&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;narayana-jts-integration&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${narayana.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jboss-transaction-spi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${jboss-transaction-spi.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.logging&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jboss-logging&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${jboss-logging.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 定制化配置项 可以通过在项目的 classpath 中添加 jbossts-properties.xml 来定制化 Narayana 配置项。
详情请参见 Narayana 官方文档。
设置 XA 事务管理类型 Yaml:
- !TRANSACTION defaultType: XA providerType: Narayana SpringBoot:</description>
    </item>
    
    <item>
      <title>SQL 解析</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sql-parser/</guid>
      <description>DatabaseTypedSQLParserFacade    SPI 名称 详细说明     DatabaseTypedSQLParserFacade 配置用于 SQL 解析的词法分析器和语法分析器入口       Implementation Class Description     MySQLParserFacade 基于 MySQL 的 SQL 解析器入口   PostgreSQLParserFacade 基于 PostgreSQL 的 SQL 解析器入口   SQLServerParserFacade 基于 SQLServer 的 SQL 解析器入口   OracleParserFacade 基于 Oracle 的 SQL 解析器入口   SQL92ParserFacade 基于 SQL92 的 SQL 解析器入口   OpenGaussParserFacade 基于 openGauss 的 SQL 解析器入口    SQLVisitorFacade    SPI 名称 详细说明     SQLVisitorFacade SQL 语法树访问器入口       Implementation Class Description     MySQLStatementSQLVisitorFacade 基于 MySQL 的提取 SQL 语句的语法树访问器   PostgreSQLStatementSQLVisitorFacade 基于 PostgreSQL 的提取 SQL 语句的语法树访问器   SQLServerStatementSQLVisitorFacade 基于 SQLServer 的提取 SQL 语句的语法树访问器   OracleStatementSQLVisitorFacade 基于 Oracle 的提取 SQL 语句的语法树访问器   SQL92StatementSQLVisitorFacade 基于 SQL92 的提取 SQL 语句的语法树访问器   OpenGaussStatementSQLVisitorFacade 基于 openGauss 的提取 SQL 语句的语法树访问器    </description>
    </item>
    
    <item>
      <title>SQL92</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/sql92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/feature-support/sql92/</guid>
      <description>SQL92 不支持的 SQL 清单如下：
TODO</description>
    </item>
    
    <item>
      <title>SQL92</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/sql92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/db-compatibility/sql-parser/sql92/</guid>
      <description>SQL92 不支持的 SQL 清单如下：
TODO
源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-sql92</description>
    </item>
    
    <item>
      <title>分布式主键</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/key-generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/key-generator/</guid>
      <description>实现动机 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。
目前有许多第三方解决方案可以完美解决这个问题，如 UUID 等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求， Apache ShardingSphere 不仅提供了内置的分布式主键生成器，例如 UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。
内置的主键生成器 UUID 采用 UUID.randomUUID() 的方式产生分布式主键。
NanoID 生成长度为 21 的字符串分布式主键。
SNOWFLAKE 在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法（snowflake）生成 64bit 的长整型数据。
雪花算法是由 Twitter 公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。
实现原理 在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。 例如 MySQL 的 Innodb 存储引擎的主键。
使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。
 符号位（1bit）  预留的符号位，恒为零。
 时间戳位（41bit）  41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。 通过计算可知：
Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L); 结果约等于 69.</description>
    </item>
    
    <item>
      <title>加密算法</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/encrypt/</guid>
      <description>MD5 加密算法 类型：MD5
可配置属性：无
AES 加密算法 类型：AES
可配置属性：
   名称 数据类型 说明     aes-key-value String AES 使用的 KEY    RC4 加密算法 类型：RC4
可配置属性：
   名称 数据类型 说明     rc4-key-value String RC4 使用的 KEY    SM3 加密算法 类型：SM3
可配置属性：
   名称 数据类型 说明     sm3-salt String SM3 使用的 SALT（空或 8 Bytes）    SM4 加密算法 类型：SM4</description>
    </item>
    
    <item>
      <title>归并引擎</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/merge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/sharding/merge/</guid>
      <description>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。
ShardingSphere 支持的结果归并从功能上分为遍历、排序、分组、分页和聚合 5 种类型，它们是组合而非互斥的关系。 从结构划分，可分为流式归并、内存归并和装饰者归并。流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。
由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此，在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。
流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。
内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。
装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这 2 种类型。
遍历归并 它是最为简单的归并方式。 只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。
排序归并 由于在 SQL 中存在 ORDER BY 语句，因此每个数据结果集自身是有序的，因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，归并排序是最适合此场景的排序算法。
ShardingSphere 在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现 Java 的 Comparable 接口完成），并将其放入优先级队列。 每次获取下一条数据时，只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。
通过一个例子来说明 ShardingSphere 的排序归并，下图是一个通过分数进行排序的示例图。 图中展示了 3 张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，但是 3 个数据结果集之间是无序的。 将 3 个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0 的第一个数据值最大，t_score_2 的第一个数据值次之，t_score_1 的第一个数据值最小，因此优先级队列根据 t_score_0，t_score_2 和 t_score_1 的方式排序队列。
下图则展现了进行 next 调用的时候，排序归并是如何进行的。 通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_0 将会被弹出队列，并且将当前游标指向的数据值（也就是 100）返回至查询客户端，并且将游标下移一位之后，重新放入优先级队列。 而优先级队列也会根据 t_score_0 的当前数据结果集指向游标的数据值（这里是 90）进行排序，根据当前数值，t_score_0 排列在队列的最后一位。 之前队列中排名第二的 t_score_2 的数据结果集则自动排在了队列首位。
在进行第二次 next 时，只需要将目前排列在队列首位的 t_score_2 弹出队列，并且将其数据结果集游标指向的值返回至客户端，并下移游标，继续加入队列排队，以此类推。 当一个结果集中已经没有数据了，则无需再次加入队列。</description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/shadow/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.shadow.api.config.ShadowRuleConfiguration
可配置属性：
   名称 数据类型 说明 默认值     dataSources Map&amp;lt;String, ShadowDataSourceConfiguration&amp;gt; 影子数据源映射名称和配置    tables Map&amp;lt;String, ShadowTableConfiguration&amp;gt; 影子表名称和配置    defaultShadowAlgorithmName String 默认影子算法名称    shadowAlgorithms Map&amp;lt;String, ShardingSphereAlgorithmConfiguration&amp;gt; 影子算法名称和配置 无    影子数据源配置 类名称：org.apache.shardingsphere.shadow.api.config.datasource.ShadowDataSourceConfiguration
可配置属性：
   名称 数据类型 说明     sourceDataSourceName String 生产数据源名称   shadowDataSourceName String 影子数据源名称    影子表配置 类名称：org.apache.shardingsphere.shadow.api.config.table.ShadowTableConfiguration
可配置属性：
   名称 数据类型 说明     dataSourceNames Collection&amp;lt;String&amp;gt; 影子表关联影子数据源映射名称列表   shadowAlgorithmNames Collection&amp;lt;String&amp;gt; 影子表关联影子算法名称列表    影子算法配置 算法类型的详情，请参见内置影子算法列表。</description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/shadow/</guid>
      <description>配置项说明 spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册 spring.shardingsphere.rules.shadow.data-sources.shadow-data-source.source-data-source-name= # 生产数据源名称 spring.shardingsphere.rules.shadow.data-sources.shadow-data-source.shadow-data-source-name= # 影子数据源名称 spring.shardingsphere.rules.shadow.tables.&amp;lt;table-name&amp;gt;.data-source-names= # 影子表关联影子数据源名称列表（多个值用&amp;quot;,&amp;quot;隔开） spring.shardingsphere.rules.shadow.tables.&amp;lt;table-name&amp;gt;.shadow-algorithm-names= # 影子表关联影子算法名称列表（多个值用&amp;quot;,&amp;quot;隔开） spring.shardingsphere.rules.shadow.defaultShadowAlgorithmName= # 默认影子算法名称，选配项。 spring.shardingsphere.rules.shadow.shadow-algorithms.&amp;lt;shadow-algorithm-name&amp;gt;.type= # 影子算法类型 spring.shardingsphere.rules.shadow.shadow-algorithms.&amp;lt;shadow-algorithm-name&amp;gt;.props.xxx= # 影子算法属性配置 </description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/shadow/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/shadow/shadow-5.1.2.xsd
&amp;lt;shadow:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   data-source(?) 标签 影子数据源配置   default-shadow-algorithm-name(?) 标签 默认影子算法配置   shadow-table(?) 标签 影子表配置    &amp;lt;shadow:data-source /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   source-data-source-name 属性 生产数据源名称   shadow-data-source-name 属性 影子数据源名称    &amp;lt;shadow:default-shadow-algorithm-name /&amp;gt;
   名称 类型 说明     name 属性 默认影子算法名称    &amp;lt;shadow:shadow-table /&amp;gt;</description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/shadow/</guid>
      <description>配置项说明 rules: - !SHADOW dataSources: shadowDataSource: sourceDataSourceName: # 生产数据源名称 shadowDataSourceName: # 影子数据源名称  tables: &amp;lt;table-name&amp;gt;: dataSourceNames: # 影子表关联影子数据源名称列表 - &amp;lt;shadow-data-source&amp;gt; shadowAlgorithmNames: # 影子表关联影子算法名称列表 - &amp;lt;shadow-algorithm-name&amp;gt; defaultShadowAlgorithmName: # 默认影子算法名称 shadowAlgorithms: &amp;lt;shadow-algorithm-name&amp;gt; (+): # 影子算法名称 type: # 影子算法类型 props: # 影子算法属性配置 # ... </description>
    </item>
    
    <item>
      <title>影子库压测</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/shadow-rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/shadow-rule/</guid>
      <description>资源操作 ADD RESOURCE ds_0 ( HOST=127.0.0.1, PORT=3306, DB=ds_0, USER=root, PASSWORD=root ),ds_1 ( HOST=127.0.0.1, PORT=3306, DB=ds_1, USER=root, PASSWORD=root ),ds_2 ( HOST=127.0.0.1, PORT=3306, DB=ds_2, USER=root, PASSWORD=root ); 规则操作  创建影子库压测规则  CREATE SHADOW RULE group_0( SOURCE=ds_0, SHADOW=ds_1, t_order((simple_hint_algorithm, TYPE(NAME=SIMPLE_HINT, PROPERTIES(&amp;#34;foo&amp;#34;=&amp;#34;bar&amp;#34;))),(TYPE(NAME=REGEX_MATCH, PROPERTIES(&amp;#34;operation&amp;#34;=&amp;#34;insert&amp;#34;,&amp;#34;column&amp;#34;=&amp;#34;user_id&amp;#34;, &amp;#34;regex&amp;#34;=&amp;#39;[1]&amp;#39;)))), t_order_item((TYPE(NAME=SIMPLE_HINT, PROPERTIES(&amp;#34;foo&amp;#34;=&amp;#34;bar&amp;#34;)))));  修改影子库压测规则  ALTER SHADOW RULE group_0( SOURCE=ds_0, SHADOW=ds_2, t_order_item((TYPE(NAME=SIMPLE_HINT, PROPERTIES(&amp;#34;foo&amp;#34;=&amp;#34;bar&amp;#34;)))));  删除影子库压测规则  DROP SHADOW RULE group_0;  删除数据源  DROP RESOURCE ds_0,ds_1,ds_2; 删除分布式数据库  DROP DATABASE foo_db; </description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/encrypt/</guid>
      <description>语法说明 CREATE ENCRYPT RULE encryptRuleDefinition [, encryptRuleDefinition] ... ALTER ENCRYPT RULE encryptRuleDefinition [, encryptRuleDefinition] ... DROP ENCRYPT RULE tableName [, tableName] ... encryptRuleDefinition: tableName(COLUMNS(columnDefinition [, columnDefinition] ...), QUERY_WITH_CIPHER_COLUMN=queryWithCipherColumn) columnDefinition: (NAME=columnName [, PLAIN=plainColumnName] , CIPHER=cipherColumnName, encryptAlgorithm) encryptAlgorithm: TYPE(NAME=encryptAlgorithmType [, PROPERTIES([algorithmProperties] )] ) algorithmProperties: algorithmProperty [, algorithmProperty] ... algorithmProperty: key=value  PLAIN 指定明文数据列，CIPHER 指定密文数据列； encryptAlgorithmType 指定加密算法类型，请参考 加密算法； 重复的 tableName 将无法被创建； queryWithCipherColumn 支持大写或小写的 true 或 false。  示例 CREATE ENCRYPT RULE t_encrypt ( COLUMNS( (NAME=user_id,PLAIN=user_plain,CIPHER=user_cipher,TYPE(NAME=AES,PROPERTIES(&amp;#39;aes-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))), (NAME=order_id, CIPHER =order_cipher,TYPE(NAME=MD5)) ),QUERY_WITH_CIPHER_COLUMN=true), t_encrypt_2 ( COLUMNS( (NAME=user_id,PLAIN=user_plain,CIPHER=user_cipher,TYPE(NAME=AES,PROPERTIES(&amp;#39;aes-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))), (NAME=order_id, CIPHER=order_cipher,TYPE(NAME=MD5)) ), QUERY_WITH_CIPHER_COLUMN=FALSE); ALTER ENCRYPT RULE t_encrypt ( COLUMNS( (NAME=user_id,PLAIN=user_plain,CIPHER=user_cipher,TYPE(NAME=AES,PROPERTIES(&amp;#39;aes-key-value&amp;#39;=&amp;#39;123456abc&amp;#39;))), (NAME=order_id,CIPHER=order_cipher,TYPE(NAME=MD5)) ), QUERY_WITH_CIPHER_COLUMN=TRUE); DROP ENCRYPT RULE t_encrypt,t_encrypt_2; </description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/encrypt/</guid>
      <description>语法说明 SHOW ENCRYPT RULES [FROM databaseName] SHOW ENCRYPT TABLE RULE tableName [from databaseName]  支持查询所有的数据加密规则和指定逻辑表名查询。  返回值说明    列 说明     table 逻辑表名   logic_column 逻辑列名   logic_data_type 逻辑列数据类型   cipher_column 密文列名   cipher_data_type 密文列数据类型   plain_column 明文列名   plain_data_type 明文列数据类型   assisted_query_column 辅助查询列名   assisted_query_data_type 辅助查询列数据类型   encryptor_type 加密算法类型   encryptor_props 加密算法参数   query_with_cipher_column 是否使用加密列进行查询    示例 显示加密规则</description>
    </item>
    
    <item>
      <title>数据库发现</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/db-discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/usage/db-discovery/</guid>
      <description>资源操作 ADD RESOURCE ds_0 ( HOST=127.0.0.1, PORT=3306, DB=ds_0, USER=root, PASSWORD=root ),ds_1 ( HOST=127.0.0.1, PORT=3306, DB=ds_1, USER=root, PASSWORD=root ),ds_2 ( HOST=127.0.0.1, PORT=3306, DB=ds_2, USER=root, PASSWORD=root ); 规则操作  创建数据库发现规则  CREATE DB_DISCOVERY RULE db_discovery_group_0 ( RESOURCES(ds_0, ds_1), TYPE(NAME=mgr,PROPERTIES(&amp;#39;group-name&amp;#39;=&amp;#39;92504d5b-6dec&amp;#39;)), HEARTBEAT(PROPERTIES(&amp;#39;keep-alive-cron&amp;#39;=&amp;#39;0/5 * * * * ?&amp;#39;)) );  修改数据库发现规则  ALTER DB_DISCOVERY RULE db_discovery_group_0 ( RESOURCES(ds_0, ds_1, ds_2), TYPE(NAME=mgr,PROPERTIES(&amp;#39;group-name&amp;#39;=&amp;#39;92504d5b-6dec&amp;#39;)), HEARTBEAT(PROPERTIES(&amp;#39;keep-alive-cron&amp;#39;=&amp;#39;0/5 * * * * ?&amp;#39;)) );  删除数据库发现规则  DROP DB_DISCOVERY RULE db_discovery_group_0;  删除数据库发现类型  DROP DB_DISCOVERY TYPE db_discovery_group_0_mgr;  删除数据库发现心跳  DROP DB_DISCOVERY HEARTBEAT db_discovery_group_0_heartbeat;  删除数据源  DROP RESOURCE ds_0,ds_1,ds_2;  删除分布式数据库  DROP DATABASE discovery_db; </description>
    </item>
    
    <item>
      <title>Bitronix 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/bitronix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/bitronix/</guid>
      <description>引入 Maven 依赖 &amp;lt;properties&amp;gt; &amp;lt;btm.version&amp;gt;2.1.3&amp;lt;/btm.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 使用 XA 事务时，需要引入此模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-transaction-xa-bitronix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.btm&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;btm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${btm.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 定制化配置项 详情请参见 Bitronix 官方文档。
设置 XA 事务管理类型 Yaml:
- !TRANSACTION defaultType: XA providerType: Bitronix SpringBoot:
spring: shardingsphere: props: xa-transaction-manager-type: Bitronix Spring Namespace:
&amp;lt;shardingsphere:data-source id=&amp;#34;xxx&amp;#34; data-source-names=&amp;#34;xxx&amp;#34; rule-refs=&amp;#34;xxx&amp;#34;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;#34;xa-transaction-manager-type&amp;#34;&amp;gt;Bitronix&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/shardingsphere:data-source&amp;gt; </description>
    </item>
    
    <item>
      <title>CREATE SHARDING KEY GENERATOR</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-key-generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/reference/distsql/syntax/rdl/rule-definition/sharding/create-sharding-key-generator/</guid>
      <description>描述 CREATE SHARDING KEY GENERATOR 语法用于为当前所选的逻辑库添加分布式主键生成器
语法定义 CreateShardingAlgorithm ::= &amp;#39;CREATE&amp;#39; &amp;#39;SHARDING&amp;#39; &amp;#39;KEY&amp;#39; &amp;#39;GENERATOR&amp;#39; keyGeneratorName &amp;#39;(&amp;#39; algorithmDefinition &amp;#39;)&amp;#39; algorithmDefinition ::= &amp;#39;TYPE&amp;#39; &amp;#39;(&amp;#39; &amp;#39;NAME&amp;#39; &amp;#39;=&amp;#39; algorithmType ( &amp;#39;,&amp;#39; &amp;#39;PROPERTIES&amp;#39; &amp;#39;(&amp;#39; propertyDefinition &amp;#39;)&amp;#39; )?&amp;#39;)&amp;#39; propertyDefinition ::= ( key &amp;#39;=&amp;#39; value ) ( &amp;#39;,&amp;#39; key &amp;#39;=&amp;#39; value )* keyGeneratorName ::= identifier algorithmType ::= identifier 补充说明  algorithmType 为分布式主键生成算法类型，详细的分布式主键生成算法类型信息请参考分布式序列算法类型  示例 创建分布式主键生成器 CREATE SHARDING KEY GENERATOR snowflake_key_generator ( TYPE(NAME=SNOWFLAKE, PROPERTIES(&amp;#34;max-vibration-offset&amp;#34;=3)) ); 保留字 CREATE、SHARDING、KEY、GENERATOR、TYPE、NAME、PROPERTIES  相关链接  保留字  </description>
    </item>
    
    <item>
      <title>SQL 解析</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sql-parser/</guid>
      <description>配置项说明 spring.shardingsphere.rules.sql-parser.sql-comment-parse-enabled= # 是否解析 SQL 注释 spring.shardingsphere.rules.sql-parser.sql-statement-cache.initial-capacity= # SQL 语句本地缓存初始容量 spring.shardingsphere.rules.sql-parser.sql-statement-cache.maximum-size= # SQL 语句本地缓存最大容量 spring.shardingsphere.rules.sql-parser.parse-tree-cache.initial-capacity= # 解析树本地缓存初始容量 spring.shardingsphere.rules.sql-parser.parse-tree-cache.maximum-size= # 解析树本地缓存最大容量 </description>
    </item>
    
    <item>
      <title>SQL 解析</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sql-parser/</guid>
      <description>配置项说明 rules: - !SQL_PARSER sqlCommentParseEnabled: # 是否解析 SQL 注释 sqlStatementCache: # SQL 语句本地缓存配置项 initialCapacity: # 本地缓存初始容量 maximumSize: # 本地缓存最大容量 parseTreeCache: # 解析树本地缓存配置项 initialCapacity: # 本地缓存初始容量 maximumSize: # 本地缓存最大容量 </description>
    </item>
    
    <item>
      <title>SQL解析</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/sql-parser/</guid>
      <description>配置入口 类名称：org.apache.shardingsphere.parser.config.SQLParserRuleConfiguration
可配置属性：
   名称 数据类型 说明     sqlCommentParseEnabled (?) boolean 是否解析 SQL 注释   parseTreeCache (?) CacheOption 解析语法树本地缓存配置   sqlStatementCache (?) CacheOption SQL 语句本地缓存配置    本地缓存配置 类名称：org.apache.shardingsphere.sql.parser.api.CacheOption
可配置属性：
   名称 数据类型 说明 默认值     initialCapacity int 本地缓存初始容量 语法树本地缓存默认值 128，SQL 语句缓存默认值 2000   maximumSize long 本地缓存最大容量 语法树本地缓存默认值 1024，SQL 语句缓存默认值 65535    </description>
    </item>
    
    <item>
      <title>SQL解析</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/sql-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/sql-parser/</guid>
      <description>配置项说明 命名空间：http://shardingsphere.apache.org/schema/shardingsphere/sql-parser/sql-parser-5.1.2.xsd
&amp;lt;sql-parser:rule /&amp;gt;
   名称 类型 说明     id 属性 Spring Bean Id   sql-comment-parse-enable 属性 是否解析 SQL 注释   parse-tree-cache-ref 属性 解析树本地缓存名称   sql-statement-cache-ref 属性 SQL 语句本地缓存名称    &amp;lt;sql-parser:cache-option /&amp;gt;
   名称 类型 说明     id 属性 本地缓存配置项名称   initial-capacity 属性 本地缓存初始容量   maximum-size 属性 本地缓存最大容量    </description>
    </item>
    
    <item>
      <title>代理端</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/proxy/</guid>
      <description>DatabaseProtocolFrontendEngine    SPI 名称 详细说明     DatabaseProtocolFrontendEngine 用于 ShardingSphere-Proxy 解析与适配访问数据库的协议       已知实现类 详细说明     MySQLFrontendEngine 基于 MySQL 的数据库协议实现   PostgreSQLFrontendEngine 基于 PostgreSQL 的数据库协议实现   OpenGaussFrontendEngine 基于 openGauss 的数据库协议实现    AuthorityProvideAlgorithm    SPI 名称 详细说明     AuthorityProviderAlgorithm 用户权限加载逻辑       已知实现类 Type 详细说明     NativeAuthorityProviderAlgorithm（已弃用） NATIVE 基于后端数据库存取 server.</description>
    </item>
    
    <item>
      <title>属性配置</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/props/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/props/</guid>
      <description>Apache ShardingSphere 提供属性配置的方式配置系统级配置。
配置项说明    名称 数据类型 说明 默认值     sql-show (?) boolean 是否在日志中打印 SQL
打印 SQL 可以帮助开发者快速定位系统问题。日志内容包含：逻辑 SQL，真实 SQL 和 SQL 解析结果。
如果开启配置，日志将使用 Topic ShardingSphere-SQL，日志级别是 INFO false   sql-simple (?) boolean 是否在日志中打印简单风格的 SQL false   kernel-executor-size (?) int 用于设置任务处理线程池的大小
每个 ShardingSphereDataSource 使用一个独立的线程池，同一个 JVM 的不同数据源不共享线程池 infinite   max-connections-size-per-query (?) int 一次查询请求在每个数据库实例中所能使用的最大连接数 1   check-table-metadata-enabled (?) boolean 在程序启动和更新时，是否检查分片元数据的结构一致性 false   check-duplicate-table-enabled (?</description>
    </item>
    
    <item>
      <title>强制分片路由</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/hint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/features/sharding/concept/hint/</guid>
      <description>实现动机 通过解析 SQL 语句提取分片键列与值并进行分片是 Apache ShardingSphere 对 SQL 零侵入的实现方式。 若 SQL 语句中没有分片条件，则无法进行分片，需要全路由。
在一些应用场景中，分片条件并不存在于 SQL，而存在于外部业务逻辑。 因此需要提供一种通过外部指定分片结果的方式，在 Apache ShardingSphere 中叫做 Hint。
实现机制 Apache ShardingSphere 使用 ThreadLocal 管理分片键值。 可以通过编程的方式向 HintManager 中添加分片条件，该分片条件仅在当前线程内生效。
除了通过编程的方式使用强制分片路由，Apache ShardingSphere 还可以通过 SQL 中的特殊注释的方式引用 Hint，使开发者可以采用更加透明的方式使用该功能。
指定了强制分片路由的 SQL 将会无视原有的分片逻辑，直接路由至指定的真实数据节点。</description>
    </item>
    
    <item>
      <title>影子库压测</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rdl/rule-definition/shadow/</guid>
      <description>语法说明 CREATE SHADOW RULE shadowRuleDefinition [, shadowRuleDefinition] ... ALTER SHADOW RULE shadowRuleDefinition [, shadowRuleDefinition] ... CREATE SHADOW ALGORITHM shadowAlgorithm [, shadowAlgorithm] ... ALTER SHADOW ALGORITHM shadowAlgorithm [, shadowAlgorithm] ... DROP SHADOW RULE ruleName [, ruleName] ... DROP SHADOW ALGORITHM algorithmName [, algorithmName] ... CREATE DEFAULT SHADOW ALGORITHM NAME = algorithmName shadowRuleDefinition: ruleName(resourceMapping, shadowTableRule [, shadowTableRule] ...) resourceMapping: SOURCE=resourceName, SHADOW=resourceName shadowTableRule: tableName(shadowAlgorithm [, shadowAlgorithm] ...) shadowAlgorithm: ([algorithmName, ] TYPE(NAME=shadowAlgorithmType, PROPERTIES([algorithmProperties] ...))) algorithmProperties: algorithmProperty [, algorithmProperty] .</description>
    </item>
    
    <item>
      <title>影子库压测</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-proxy/distsql/syntax/rql/rule-query/shadow/</guid>
      <description>语法说明 SHOW SHADOW shadowRule | RULES [FROM databaseName] SHOW SHADOW TABLE RULES [FROM databaseName] SHOW SHADOW ALGORITHMS [FROM databaseName] shadowRule: RULE ruleName  支持查询所有影子规则和指定表查询； 支持查询所有表规则； 支持查询所有影子算法。  返回值说明 Shadow Rule    列 说明     rule_name 规则名称   source_name 源数据库   shadow_name 影子数据库   shadow_table 影子表    Shadow Table Rule    列 说明     shadow_table 影子表   shadow_algorithm_name 影子算法名称    Shadow Algorithms    列 说明     shadow_algorithm_name 影子算法名称   type 算法类型   props 算法参数   is_default 是否默认    Shadow Rule status    列 说明     status 是否启用    示例 SHOW SHADOW RULES</description>
    </item>
    
    <item>
      <title>影子算法</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/shadow/</guid>
      <description>列影子算法 列值匹配影子算法 类型：VALUE_MATCH
可配置属性：
   属性名称 数据类型 说明     column String 影子列   operation String SQL 操作类型（INSERT, UPDATE, DELETE, SELECT）   value String 影子列匹配的值    列正则表达式匹配影子算法 类型：REGEX_MATCH
可配置属性：
   属性名称 数据类型 说明     column String 匹配列   operation String SQL 操作类型（INSERT, UPDATE, DELETE, SELECT）   regex String 影子列匹配正则表达式    Hint 影子算法 简单 Hint 匹配影子算法 类型：SIMPLE_HINT</description>
    </item>
    
    <item>
      <title>混合规则</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/mix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/mix/</guid>
      <description>混合配置的规则项之间的叠加使用是通过数据源名称和表名称关联的。
如果前一个规则是面向数据源聚合的，下一个规则在配置数据源时，则需要使用前一个规则配置的聚合后的逻辑数据源名称； 同理，如果前一个规则是面向表聚合的，下一个规则在配置表时，则需要使用前一个规则配置的聚合后的逻辑表名称。
配置项说明 # 数据源配置 # 数据源名称，多数据源以逗号分隔 spring.shardingsphere.datasource.names= write-ds0,write-ds1,write-ds0-read0,write-ds1-read0 spring.shardingsphere.datasource.write-ds0.jdbc-url= # 数据库 URL 连接 spring.shardingsphere.datasource.write-ds0.type= # 数据库连接池类名称 spring.shardingsphere.datasource.write-ds0.driver-class-name= # 数据库驱动类名 spring.shardingsphere.datasource.write-ds0.username= # 数据库用户名 spring.shardingsphere.datasource.write-ds0.password= # 数据库密码 spring.shardingsphere.datasource.write-ds0.xxx= # 数据库连接池的其它属性 spring.shardingsphere.datasource.write-ds1.jdbc-url= # 数据库 URL 连接 # 忽略其他数据库配置项 spring.shardingsphere.datasource.write-ds0-read0.jdbc-url= # 数据库 URL 连接 # 忽略其他数据库配置项 spring.shardingsphere.datasource.write-ds1-read0.jdbc-url= # 数据库 URL 连接 # 忽略其他数据库配置项 # 分片规则配置 # 分库策略 spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=user_id spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=default-database-strategy-inline # 绑定表规则，多组绑定规则使用数组形式配置 spring.shardingsphere.rules.sharding.binding-tables[0]=t_user,t_user_detail # 绑定表名称，多个表之间以逗号分隔 spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表名称，多个表之间以逗号分隔 spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表名称，多个表之间以逗号分隔 # 广播表规则配置 spring.</description>
    </item>
    
    <item>
      <title>混合规则</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/mix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/mix/</guid>
      <description>混合配置的规则项之间的叠加使用是通过数据源名称和表名称关联的。
如果前一个规则是面向数据源聚合的，下一个规则在配置数据源时，则需要使用前一个规则配置的聚合后的逻辑数据源名称； 同理，如果前一个规则是面向表聚合的，下一个规则在配置表时，则需要使用前一个规则配置的聚合后的逻辑表名称。
配置项说明 dataSources: # 配置真实存在的数据源作为名称 write_ds: # ...省略具体配置 read_ds_0: # ...省略具体配置 read_ds_1: # ...省略具体配置 rules: - !SHARDING # 配置数据分片规则 tables: t_user: actualDataNodes: ds.t_user_${0..1} # 数据源名称 `ds` 使用读写分离配置的逻辑数据源名称 tableStrategy: standard: shardingColumn: user_id shardingAlgorithmName: t_user_inline shardingAlgorithms: t_user_inline: type: INLINE props: algorithm-expression: t_user_${user_id % 2} - !ENCRYPT # 配置数据加密规则 tables: t_user: # 表名称 `t_user` 使用数据分片配置的逻辑表名称 columns: pwd: plainColumn: plain_pwd cipherColumn: cipher_pwd encryptorName: encryptor_aes encryptors: encryptor_aes: type: aes props: aes-key-value: 123456abc - !</description>
    </item>
    
    <item>
      <title>Seata 事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/seata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/special-api/transaction/seata/</guid>
      <description>启动 Seata 服务 按照 seata-work-shop 中的步骤，下载并启动 Seata 服务器。
创建日志表 在每一个分片数据库实例中执创建 undo_log 表（以 MySQL 为例）。
CREATE TABLE IF NOT EXISTS `undo_log` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &amp;#39;increment id&amp;#39;, `branch_id` BIGINT(20) NOT NULL COMMENT &amp;#39;branch transaction id&amp;#39;, `xid` VARCHAR(100) NOT NULL COMMENT &amp;#39;global transaction id&amp;#39;, `context` VARCHAR(128) NOT NULL COMMENT &amp;#39;undo_log context,such as serialization&amp;#39;, `rollback_info` LONGBLOB NOT NULL COMMENT &amp;#39;rollback info&amp;#39;, `log_status` INT(11) NOT NULL COMMENT &amp;#39;0:normal status,1:defense status&amp;#39;, `log_created` DATETIME NOT NULL COMMENT &amp;#39;create datetime&amp;#39;, `log_modified` DATETIME NOT NULL COMMENT &amp;#39;modify datetime&amp;#39;, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8 COMMENT =&amp;#39;AT transaction mode undo table&amp;#39;; 修改配置 在 classpath 中增加 seata.</description>
    </item>
    
    <item>
      <title>数据分片</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sharding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sharding/</guid>
      <description>ShardingAlgorithm    SPI 名称 详细说明     ShardingAlgorithm 分片算法       已知实现类 详细说明     BoundaryBasedRangeShardingAlgorithm 基于分片边界的范围分片算法   VolumeBasedRangeShardingAlgorithm 基于分片容量的范围分片算法   ComplexInlineShardingAlgorithm 基于行表达式的复合分片算法   AutoIntervalShardingAlgorithm 基于可变时间范围的分片算法   ClassBasedShardingAlgorithm 基于自定义类的分片算法   HintInlineShardingAlgorithm 基于行表达式的 Hint 分片算法   IntervalShardingAlgorithm 基于固定时间范围的分片算法   HashModShardingAlgorithm 基于哈希取模的分片算法   InlineShardingAlgorithm 基于行表达式的分片算法   ModShardingAlgorithm 基于取模的分片算法   CosIdModShardingAlgorithm 基于 CosId 的取模分片算法   CosIdIntervalShardingAlgorithm 基于 CosId 的固定时间范围的分片算法   CosIdSnowflakeIntervalShardingAlgorithm 基于 CosId 的雪花ID固定时间范围的分片算法    KeyGenerateAlgorithm    SPI 名称 详细说明     KeyGenerateAlgorithm 分布式主键生成算法       已知实现类 详细说明     SnowflakeKeyGenerateAlgorithm 基于雪花算法的分布式主键生成算法   UUIDKeyGenerateAlgorithm 基于 UUID 的分布式主键生成算法   CosIdKeyGenerateAlgorithm 基于 CosId 的分布式主键生成算法   CosIdSnowflakeKeyGenerateAlgorithm 基于 CosId 的雪花算法分布式主键生成算法   NanoIdKeyGenerateAlgorithm 基于 NanoId 的分布式主键生成算法    DatetimeService    SPI 名称 详细说明     DatetimeService 获取当前时间进行路由       已知实现类 详细说明     DatabaseDatetimeServiceDelegate 从数据库中获取当前时间进行路由   SystemDatetimeService 从应用系统时间中获取当前时间进行路由    DatabaseSQLEntry    SPI 名称 详细说明     DatabaseSQLEntry 获取当前时间的数据库方言       已知实现类 详细说明     MySQLDatabaseSQLEntry 从 MySQL 获取当前时间的数据库方言   PostgreSQLDatabaseSQLEntry 从 PostgreSQL 获取当前时间的数据库方言   OracleDatabaseSQLEntry 从 Oracle 获取当前时间的数据库方言   SQLServerDatabaseSQLEntry 从 SQLServer 获取当前时间的数据库方言    </description>
    </item>
    
    <item>
      <title>混合规则</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/mix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/java-api/rules/mix/</guid>
      <description>混合配置的规则项之间的叠加使用是通过数据源名称和表名称关联的。
如果前一个规则是面向数据源聚合的，下一个规则在配置数据源时，则需要使用前一个规则配置的聚合后的逻辑数据源名称； 同理，如果前一个规则是面向表聚合的，下一个规则在配置表时，则需要使用前一个规则配置的聚合后的逻辑表名称。
配置项说明 /* 数据源配置 */ HikariDataSource writeDataSource0 = new HikariDataSource(); writeDataSource0.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); writeDataSource0.setJdbcUrl(&amp;#34;jdbc:mysql://localhost:3306/db0?serverTimezone=UTC&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;#34;); writeDataSource0.setUsername(&amp;#34;root&amp;#34;); writeDataSource0.setPassword(&amp;#34;&amp;#34;); HikariDataSource writeDataSource1 = new HikariDataSource(); // ...忽略其他数据库配置项  HikariDataSource read0OfwriteDataSource0 = new HikariDataSource(); // ...忽略其他数据库配置项  HikariDataSource read1OfwriteDataSource0 = new HikariDataSource(); // ...忽略其他数据库配置项  HikariDataSource read0OfwriteDataSource1 = new HikariDataSource(); // ...忽略其他数据库配置项  HikariDataSource read1OfwriteDataSource1 = new HikariDataSource(); // ...忽略其他数据库配置项  Map&amp;lt;String, DataSource&amp;gt; datasourceMaps = new HashMap&amp;lt;&amp;gt;(6); datasourceMaps.put(&amp;#34;write_ds0&amp;#34;, writeDataSource0); datasourceMaps.put(&amp;#34;write_ds0_read0&amp;#34;, read0OfwriteDataSource0); datasourceMaps.put(&amp;#34;write_ds0_read1&amp;#34;, read1OfwriteDataSource0); datasourceMaps.put(&amp;#34;write_ds1&amp;#34;, writeDataSource1); datasourceMaps.</description>
    </item>
    
    <item>
      <title>混合规则</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/mix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/spring-namespace/rules/mix/</guid>
      <description>混合配置的规则项之间的叠加使用是通过数据源名称和表名称关联的。
如果前一个规则是面向数据源聚合的，下一个规则在配置数据源时，则需要使用前一个规则配置的聚合后的逻辑数据源名称； 同理，如果前一个规则是面向表聚合的，下一个规则在配置表时，则需要使用前一个规则配置的聚合后的逻辑表名称。
配置项说明 &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:shardingsphere=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/datasource&amp;#34; xmlns:readwrite-splitting=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/readwrite-splitting&amp;#34; xmlns:encrypt=&amp;#34;http://shardingsphere.apache.org/schema/shardingsphere/encrypt&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://shardingsphere.apache.org/schema/shardingsphere/datasource http://shardingsphere.apache.org/schema/shardingsphere/datasource/datasource.xsd http://shardingsphere.apache.org/schema/shardingsphere/readwrite-splitting http://shardingsphere.apache.org/schema/shardingsphere/readwrite-splitting/readwrite-splitting.xsd http://shardingsphere.apache.org/schema/shardingsphere/encrypt http://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt.xsd &amp;#34;&amp;gt; &amp;lt;bean id=&amp;#34;write_ds0&amp;#34; class=&amp;#34; com.zaxxer.hikari.HikariDataSource&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;jdbcUrl&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/write_ds?useSSL=false&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=UTF-8&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;read_ds0_0&amp;#34; class=&amp;#34; com.zaxxer.hikari.HikariDataSource&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;!-- 省略详细数据源配置详情 --&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;read_ds0_1&amp;#34; class=&amp;#34; com.zaxxer.hikari.HikariDataSource&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;!-- 省略详细数据源配置详情 --&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;write_ds1&amp;#34; class=&amp;#34; com.zaxxer.hikari.HikariDataSource&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;!-- 省略详细数据源配置详情 --&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;read_ds1_0&amp;#34; class=&amp;#34; com.</description>
    </item>
    
    <item>
      <title>读写分离</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/readwrite-splitting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/readwrite-splitting/</guid>
      <description>ReadwriteSplittingType    SPI 名称 详细说明     ReadwriteSplittingType 读写分离类型       已知实现类 详细说明     StaticReadwriteSplittingType 静态读写分离类型   DynamicReadwriteSplittingType 动态读写分离类型    ReplicaLoadBalanceAlgorithm    SPI 名称 详细说明     ReplicaLoadBalanceAlgorithm 读库负载均衡算法       已知实现类 详细说明     RoundRobinReplicaLoadBalanceAlgorithm 基于轮询的读库负载均衡算法   RandomReplicaLoadBalanceAlgorithm 基于随机的读库负载均衡算法   WeightReplicaLoadBalanceAlgorithm 基于权重的读库负载均衡算法    </description>
    </item>
    
    <item>
      <title>不支持项</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/unsupported/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/user-manual/shardingsphere-jdbc/unsupported/</guid>
      <description>DataSource 接口  不支持 timeout 相关操作。  Connection 接口  不支持存储过程，函数，游标的操作； 不支持执行 native SQL； 不支持 savepoint 相关操作； 不支持 Schema/Catalog 的操作； 不支持自定义类型映射。  Statement 和 PreparedStatement 接口  不支持返回多结果集的语句（即存储过程，非 SELECT 多条数据）； 不支持国际化字符的操作。  ResultSet 接口  不支持对于结果集指针位置判断； 不支持通过非 next 方法改变结果指针位置； 不支持修改结果集内容； 不支持获取国际化字符； 不支持获取 Array。  JDBC 4.1  不支持 JDBC 4.1 接口新功能。  查询所有未支持方法，请阅读 org.apache.shardingsphere.driver.jdbc.unsupported 包。</description>
    </item>
    
    <item>
      <title>高可用</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/ha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/ha/</guid>
      <description>DatabaseDiscoveryProviderAlgorithm    SPI 名称 详细说明     DatabaseDiscoveryProviderAlgorithm 数据库发现算法       已知实现类 详细说明     MGRDatabaseDiscoveryProviderAlgorithm 基于 MySQL MGR 的数据库发现算法   MySQLNormalReplicationDatabaseDiscoveryProviderAlgorithm 基于 MySQL 主从同步的数据库发现算法   OpenGaussNormalReplicationDatabaseDiscoveryProviderAlgorithm 基于 openGauss 主从同步的数据库发现算法    </description>
    </item>
    
    <item>
      <title>分布式事务</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/transaction/</guid>
      <description>ShardingSphereTransactionManager    SPI 名称 详细说明     ShardingSphereTransactionManager 分布式事务管理器       已知实现类 详细说明     XAShardingSphereTransactionManager 基于 XA 的分布式事务管理器   SeataATShardingSphereTransactionManager 基于 Seata 的分布式事务管理器    XATransactionManagerProvider    SPI 名称 详细说明     XATransactionManagerProvider XA 分布式事务管理器       已知实现类 详细说明     AtomikosTransactionManagerProvider 基于 Atomikos 的 XA 分布式事务管理器   NarayanaXATransactionManagerProvider 基于 Narayana 的 XA 分布式事务管理器   BitronixXATransactionManagerProvider 基于 Bitronix 的 XA 分布式事务管理器    XADataSourceDefinition    SPI 名称 详细说明     XADataSourceDefinition 非 XA 数据源自动转化为 XA 数据源       已知实现类 详细说明     MySQLXADataSourceDefinition 非 XA 的 MySQL 数据源自动转化为 XA 的 MySQL 数据源   MariaDBXADataSourceDefinition 非 XA 的 MariaDB 数据源自动转化为 XA 的 MariaDB 数据源   PostgreSQLXADataSourceDefinition 非 XA 的 PostgreSQL 数据源自动转化为 XA 的 PostgreSQL 数据源   OracleXADataSourceDefinition 非 XA 的 Oracle 数据源自动转化为 XA 的 Oracle 数据源   SQLServerXADataSourceDefinition 非 XA 的 SQLServer 数据源自动转化为 XA 的 SQLServer 数据源   H2XADataSourceDefinition 非 XA 的 H2 数据源自动转化为 XA 的 H2 数据源    DataSourcePropertyProvider    SPI 名称 详细说明     DataSourcePropertyProvider 用于获取数据源连接池的标准属性       已知实现类 详细说明     HikariCPPropertyProvider 用于获取 HikariCP 连接池的标准属性    </description>
    </item>
    
    <item>
      <title>弹性伸缩</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/scaling/</guid>
      <description>ScalingEntry    SPI 名称 详细说明     ScalingEntry 弹性伸缩入口       已知实现类 详细说明     MySQLScalingEntry 基于 MySQL 的弹性伸缩入口   PostgreSQLScalingEntry 基于 PostgreSQL 的弹性伸缩入口   OpenGaussScalingEntry 基于 openGauss 的弹性伸缩入口    JobCompletionDetectAlgorithm    SPI 名称 详细说明     JobCompletionDetectAlgorithm 作业是否接近完成检测算法       已知实现类 详细说明     IdleRuleAlteredJobCompletionDetectAlgorithm 基于增量迁移任务空闲时长的检测算法    DataConsistencyCalculateAlgorithm    SPI 名称 详细说明     DataConsistencyCalculateAlgorithm 校验数据一致性使用的算法       已知实现类 详细说明     DataMatchDataConsistencyCalculateAlgorithm 根据数据逐条校验数据一致性的算法   CRC32MatchDataConsistencyCalculateAlgorithm 使用 CRC32 校验数据一致性的算法    </description>
    </item>
    
    <item>
      <title>SQL 检查</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sql-check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/sql-check/</guid>
      <description>SQLChecker    SPI 名称 详细说明     SQLChecker SQL 检查器       已知实现类 详细说明     AuthorityChecker 权限检查器    </description>
    </item>
    
    <item>
      <title>数据加密</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/encryption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/encryption/</guid>
      <description>EncryptAlgorithm    SPI 名称 详细说明     EncryptAlgorithm 数据加密算法       已知实现类 详细说明     MD5EncryptAlgorithm 基于 MD5 的数据加密算法   AESEncryptAlgorithm 基于 AES 的数据加密算法   RC4EncryptAlgorithm 基于 RC4 的数据加密算法   SM4EncryptAlgorithm 基于 SM4 的数据加密算法   SM3EncryptAlgorithm 基于 SM3 的数据加密算法    QueryAssistedEncryptAlgorithm    SPI 名称 详细说明     QueryAssistedEncryptAlgorithm 包含查询辅助列的数据加密算法       已知实现类 详细说明     无     </description>
    </item>
    
    <item>
      <title>影子库</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/shadow/</guid>
      <description>ShadowAlgorithm    SPI 名称 详细说明     ShadowAlgorithm 影子库路由算法       已知实现类 详细说明     ColumnValueMatchShadowAlgorithm 基于字段值匹配影子算法   ColumnRegexMatchShadowAlgorithm 基于字段值正则匹配影子算法   SimpleHintShadowAlgorithm 基于 Hint 简单匹配影子算法    </description>
    </item>
    
    <item>
      <title>可观察性</title>
      <link>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/agent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/5.1.2/cn/dev-manual/agent/</guid>
      <description>PluginDefinitionService    SPI 名称 详细说明     PluginDefinitionService Agent 插件定义       已知实现类 详细说明     PrometheusPluginDefinitionService Prometheus plugin   BaseLoggingPluginDefinitionService Logging plugin   JaegerPluginDefinitionService Jaeger plugin   OpenTelemetryTracingPluginDefinitionService OpenTelemetryTracing plugin   OpenTracingPluginDefinitionService OpenTracing plugin   ZipkinPluginDefinitionService Zipkin plugin    PluginBootService    SPI 名称 详细说明     PluginBootService 插件启动服务定义       已知实现类 详细说明     PrometheusPluginBootService Prometheus plugin 启动类   BaseLoggingPluginBootService Logging plugin 启动类   JaegerTracingPluginBootService Jaeger plugin 启动类   OpenTelemetryTracingPluginBootService OpenTelemetryTracing plugin 启动类   OpenTracingPluginBootService OpenTracing plugin 启动类   ZipkinTracingPluginBootService Zipkin plugin 启动类    </description>
    </item>
    
  </channel>
</rss>